<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiChen</title>
  
  <subtitle>He who thinks wins</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xichen.pub/"/>
  <updated>2018-01-20T08:45:52.682Z</updated>
  <id>http://xichen.pub/</id>
  
  <author>
    <name>Lin Xueyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>latex（二）完全卸载</title>
    <link href="http://xichen.pub/2017/12/28/2017-12-28-latex%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD/"/>
    <id>http://xichen.pub/2017/12/28/2017-12-28-latex（二）完全卸载/</id>
    <published>2017-12-28T14:16:00.000Z</published>
    <updated>2018-01-20T08:45:52.682Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>sudo apt-get purge texlive*</code></li><li><code>rm -rf /usr/local/texlive/*</code> and <code>rm -rf ~/.texlive*</code></li><li><code>rm -rf /usr/local/share/texmf</code></li><li><code>rm -rf /var/lib/texmf</code></li><li><code>rm -rf /etc/texmf</code></li><li><code>sudo apt-get remove tex-common --purge</code></li><li><code>rm -rf ~/.texlive</code></li><li><code>find -L /usr/local/bin/ -lname /usr/local/texlive/*/bin/* | xargs rm</code></li></ol><p>This finds all the files in <code>/usr/local/bin</code> which point to a location within <code>/usr/local/texlive/*/bin/*</code> and removes them; because we’ve already deleted all of <code>/usr/local/texlive</code>, these are dead links. To see which files are being deleted, replace <code>xargs rm</code> with <code>xargs -t rm</code> (or tee off to a log file, or whatever).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get purge texlive*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -rf /usr/local/texlive/*&lt;/code&gt; and &lt;code&gt;rm -rf ~/.texlive*&lt;/code&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="latex" scheme="http://xichen.pub/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>latex（一）安装与配置</title>
    <link href="http://xichen.pub/2017/12/12/2017-12-12-latex%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://xichen.pub/2017/12/12/2017-12-12-latex（一）安装与配置/</id>
    <published>2017-12-12T14:16:00.000Z</published>
    <updated>2018-01-05T00:45:28.296Z</updated>
    
    <content type="html"><![CDATA[<p>2017年不到20天就到2018年了，才开始把latex用在写论文上。<br>原来只是学了用latex写公式，嫌latex的配置太麻烦，总想拿mardown结合latex搞事情，结果啥也没做到。<br>只好亲自入用latex编译论文的坑了。</p><p>latex就是为写论文带来便利。一定不能在安装和配置上花太多时间，不然就舍本逐末了。</p><h1 id="Linux-发行版下原版-TeX-Live-2017-的安装"><a href="#Linux-发行版下原版-TeX-Live-2017-的安装" class="headerlink" title="Linux 发行版下原版 TeX Live 2017 的安装"></a>Linux 发行版下原版 TeX Live 2017 的安装</h1><blockquote><p>在安装前，TeX Live 2017 的手册可以在 TUG 的 TeX Live 目录下找到：<a href="https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf" target="_blank" rel="noopener">https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf</a>。可以先阅读其中的安装部分。<br>在 Linux 上安装原版 TeX Live 2017，与在 Windows 等其他系统下安装并无区别。<br>可以从 CTAN 镜象下载 ISO 文件，然后挂载到一个目录下，运行里面的 install-tl 脚本进行安装；也可以在 CTAN 的网站上只下载 install-tl 脚本运行，在线安装。<br>install-tl 是一个 Perl 脚本，在绝大多数发行版下都可以直接运行。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="通过系统仓库"><a href="#通过系统仓库" class="headerlink" title="通过系统仓库"></a>通过系统仓库</h2><p>首先，对于 Arch 等滚动更新发行版的用户来说，推荐使用官方仓库来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S texlive-most texlive-lang</span><br></pre></td></tr></table></figure><p>但是 <code>Debian/Ubuntu</code> 等的软件源往往会比较旧，为了体验最新的 <code>TeX Live</code> （虽然并没有什么卵差别），因此还是要用 <code>ISO</code> 映像安装。</p><h2 id="通过iso文件"><a href="#通过iso文件" class="headerlink" title="通过iso文件"></a>通过iso文件</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><a href="http://mirror.lzu.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">官方镜像: texlive2017.iso</a></li><li><a href="https://mirrors.xjtu.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">XJTU 镜像: texlive2017.iso</a>（校内用户请选择该源）</li><li><a href="http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">USTC 镜像: texlive2017.iso</a>（校内用户请选择该源）</li></ul><p>镜像站目录里的 <code>texlive.iso</code> 就是最新的 <code>texlive2017.iso</code>。</p><p>下载完成后可以选择进行校验避免出错，具体来说镜像站目录里会有 <code>md5</code> 和 <code>sha512</code> 两个 <code>hash</code> 文件以及一个 <code>GPG</code> 签名文件。<code>TeX Live 2016</code> 以后调整了基础架构，安装时会校验包的完整性，如果有 <code>GPG</code> 还会校验⽹络更新的签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GnuPG 校验签名，不懂请跳过，根据我的校验应当无误</span></span><br><span class="line">gpg --verify texlive2017.iso.sha512.asc</span><br><span class="line"><span class="comment"># MD5 校验</span></span><br><span class="line">md5sum texlive2017.iso</span><br><span class="line"><span class="comment"># SHA-512 校验</span></span><br><span class="line">sha512sum texlive2017.iso</span><br><span class="line"><span class="comment"># 与官方提供的 Hash 对比</span></span><br><span class="line">cat texlive2017.iso.md5 texlive2017.iso.sha512</span><br></pre></td></tr></table></figure><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>如果之前系统里已经装过 TeX Live，建议先删除。</p><p>对于 Linux 来说比较简单，只需要把安装目录（默认为 <code>/usr/local/texlive</code> 里的文件夹丢进 trash 即可），此外用户目录里修改过的一些配置也不要忘记。</p><p>如果想把有关依赖也卸载了，参考<a href="https://linxueyuanstdio.github.io/2017/12/latex-二-完全卸载/" target="_blank" rel="noopener">下一篇blog</a></p><p>如果是包管理安装的方式，例如 Ubuntu 用户，可以按照这样卸载：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> purge texlive*</span><br></pre></td></tr></table></figure><p>因为 TeX Live 里的安装脚本是 Perl 写的，如果稍后要用图形界面安装，需要更新下依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo apt-get install perl-tk</span><br><span class="line"><span class="comment"># CentOS/Fedora/RHEL</span></span><br><span class="line">sudo yum install perl-Tk</span><br><span class="line"><span class="comment"># Fedora 22+</span></span><br><span class="line">sudo dnf install perl-Tk</span><br><span class="line"><span class="comment"># OpenSUSE</span></span><br><span class="line">sudo zypper install perl-tk</span><br></pre></td></tr></table></figure><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>如果能借助软件或文管等方式解决映像挂载问题就直接跳过，否则就在下载好的镜像目录执行以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop texlive2017.iso /mnt</span><br><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line"><span class="comment"># 在 shell 里直接安装</span></span><br><span class="line">sudo ./install-tl</span><br><span class="line"><span class="comment"># 以 GUI 方式安装</span></span><br><span class="line">sudo ./install-tl -gui=perltk</span><br></pre></td></tr></table></figure><p>图形界面大概长这样：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-12/2.png" width="700"><br><br><br><div class="image-caption"><br>图形界面<br></div><br></div><p>默认是安装在 <code>/usr/local/texlive</code> 目录下，可以更改为 <code>/home</code> 等，否则无脑下一步即可。</p><p>根据硬件性能不同，安装过程一般不会短于 3 分钟。</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-12/3.png" width="700"><br><br><br><div class="image-caption"><br>安装过程<br></div><br></div><p>安装结束后可以卸载映像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure><h3 id="通过命令行边下载边安装"><a href="#通过命令行边下载边安装" class="headerlink" title="通过命令行边下载边安装"></a>通过命令行边下载边安装</h3><p>去这里<a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">https://www.tug.org/texlive/</a>找对应的安装包，我下载的是<code>install-tl-unx.tar.gz</code>。</p><p>下载完后，随便找个临时目录解压。</p><p>默认是安装在 <code>/usr/local/texlive/</code> 路径下，需要以超级用户权限安装，在解压下的目录运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install-tl</span><br></pre></td></tr></table></figure></p><p>然后在文本界面下按提示进行交互式安装。当然，也可以安装在本地的用户路径下（如 ~/texlive/），这样就不再需要特殊权限。</p><p>如果是进行网络安装，默认会自动选择一个 CTAN 镜象。</p><p>这种方法在国内安装很慢，1h才下300多个文件。</p><p>国内往往需要用 <code>-repository</code> 选项手工指定镜象服务器地址，URL 地址需要指定到 <code>texlive/tlnet/</code> 路径下。</p><p>推荐用清华的镜象：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install-tl -repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/</span><br></pre></td></tr></table></figure></p><p>这种方法安装快，1h轻松安装完毕。</p><p>更方便的方式则是在图形界面下进行安装，此时需要确保系统安装了 <code>perl-tk</code> 等相关 Perl 图形界面库。运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install-tl -gui</span><br></pre></td></tr></table></figure><p>即可按界面中的提示安装。或者运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install-tl -gui=wizard</span><br></pre></td></tr></table></figure><p>使用图形界面的安装向导，向导方式比前面的方式配置项少一些，但更容易使用。</p><p>不过没啥用。还是建议用清华镜像那个命令快一点，不需要这么花俏。</p><h1 id="修改环境变量，使编辑器等能找到texlive"><a href="#修改环境变量，使编辑器等能找到texlive" class="headerlink" title="修改环境变量，使编辑器等能找到texlive"></a>修改环境变量，使编辑器等能找到texlive</h1><p>对于 <code>bash</code> 等 <code>Bourne</code> 兼容的 <code>shell</code>，在用户目录的 <code>~/.bashrc</code> 文件中添加一些环境变量，具体路径由安装的位置确定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TeX Live 2017</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/usr/<span class="built_in">local</span>/texlive/2017/bin/x86_64-linux</span><br><span class="line"><span class="comment"># 如果是32位最后改为'i386-linux'</span></span><br><span class="line"><span class="built_in">export</span> MANPATH=<span class="variable">$&#123;MANPATH&#125;</span>:/usr/<span class="built_in">local</span>/texlive/2017/texmf-dist/doc/man</span><br><span class="line"><span class="built_in">export</span> INFOPATH=<span class="variable">$&#123;INFOPATH&#125;</span>:/usr/<span class="built_in">local</span>/texlive/2017/texmf-dist/doc/info</span><br></pre></td></tr></table></figure><p>如果是 <code>csh</code> 或 <code>tcsh</code>，则在 <code>~/.cshrc</code> 中添加内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TeX Live 2017</span></span><br><span class="line">setenv PATH /usr/<span class="built_in">local</span>/texlive/2017/bin/x86_64-linux:<span class="variable">$PATH</span></span><br><span class="line">setenv MANPATH /usr/<span class="built_in">local</span>/texlive/2017/texmf-dist/doc/man:<span class="variable">$MANPATH</span></span><br><span class="line">setenv INFOPATH /usr/<span class="built_in">local</span>/texlive/2017/texmf-dist/doc/info:<span class="variable">$INFOPATH</span></span><br></pre></td></tr></table></figure><p>对于 <code>Debian/Ubuntu</code> 用户，可以安装下我根据 官方说明 制作的 <code>texlive-local_2017-1_all.deb</code> 来申明下包管理里的依赖关系，避免版本冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i texlive-local_2017-1_all.deb</span><br><span class="line"><span class="comment"># 显示安装的 TeX Live 版本信息</span></span><br><span class="line">dpkg -l | grep texlive-local</span><br></pre></td></tr></table></figure><p>至于其他发行版的 <code>texlive-dummy</code> 可去 <code>CTAN</code> 搜索。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>安装完成后，如果一切都设置好，那么运行以下一些简单测试命令，在当前目录应该会得到正确的输出，如果有命令报错，请自行解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示 TeX 版本应为 3.14159265</span></span><br><span class="line">tex --version</span><br><span class="line"><span class="comment"># 处理一个基本文件，显示无法找到说明环境变量设置有误</span></span><br><span class="line">latex sample2e.tex</span><br><span class="line"><span class="comment"># 预览上一步得到的 dvi 文件</span></span><br><span class="line">xdvi sample2e.dvi</span><br><span class="line"><span class="comment"># pdfTeX 编译直接输出一份 PDF</span></span><br><span class="line">pdftex sample2e.tex</span><br><span class="line"><span class="comment"># 测试 XeTeX 能否访问系统字体</span></span><br><span class="line">xetex opentype-info.tex</span><br></pre></td></tr></table></figure><p>安装之后就可以使用 texdoc 命令阅读安装在本地手册了，对 TeX Live 不甚熟悉的用户最好运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">texdoc texlive-zh</span><br></pre></td></tr></table></figure><p>命令再次阅读 TeX Live 2017 的手册。</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>TeX Live 的更新工具 <code>tlmgr</code>（TeX Live Manager）图形性能比较差，特别是在 <code>Windows</code> 上，故推荐终端里直接更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tlmgr 只能在 root 权限下运行</span></span><br><span class="line">su</span><br><span class="line"><span class="comment"># 更新 tlmgr 宏包管理器</span></span><br><span class="line">tlmgr update -self</span><br><span class="line"><span class="comment"># 更新所有宏包</span></span><br><span class="line">tlmgr update -all</span><br><span class="line"><span class="comment"># 官方的 CTAN 镜像源速度可能比较慢，校内用户推荐换成 XJTU，支持 http 或 https</span></span><br><span class="line">tlmgr update -all -repository https://mirrors.xjtu.edu.cn/CTAN/systems/texlive/tlnet/</span><br></pre></td></tr></table></figure><p>如果钟爱图形界面，带上 <code>-gui</code> 参数即可。校内用户记得把默认软件包仓库改为 <code>XJTU</code> 的镜像源地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"><span class="comment"># 指定图形界面语言为中文</span></span><br><span class="line">tlmgr -gui -gui-lang zh_CN</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul><li>关于 Linux 上的编辑器，理论上只要是文本编辑器均可。由于可选择的方案太多，取决于个人的使用习惯，这里只推荐两个适合入门的自由软件 <code>Texmaker</code> 和 <code>TeXstudio</code>（fork 自前者）。</li><li>关于 Linux 上的字体，因为版权问题，所以 <code>Times New Roman</code> 和<code>宋体</code>就成了很多 LaTeX 初学者的困扰。</li></ul><p>推荐的办法是 <code>ctex</code> 宏集处理中文，使用 <code>Fandol 开源字体</code>，默认效果好于 Windows 的<code>中易宋体</code>，另外也可使用<code>思源宋体</code>；而西文和数学字符则用 <code>mathptmx</code> 或 <code>newtx</code> 宏包处理，使用开源的 <code>Nimbus Roman No9 L</code> 字体代替 <code>Times New Roman</code>，差别不大。</p><p>对字体有严格要求，可以复制 Windows 下的字体到 <code>~/.fonts</code> 目录下，记得用 <code>fc-cache -fsv</code> 命令更新下字体缓存。</p><p>关于 LaTeX 教程或者说手册，推荐两本 <a href="http://www.dralpha.com/zh/index.htm" target="_blank" rel="noopener">包太雷的 lnotes2</a> 和 <a href="https://github.com/CTeX-org/lshort-cn/" target="_blank" rel="noopener">lshort 中文版</a>。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>按照 TeX Live 手册的说明，安装之后，还有一些工作需要做：</p><ul><li>如果在安装时没有选择在系统目录为可执行文件创建符号链接，就需要手工修改 ~/.profile 文件设置 PATH 环境变量。<ul><li>export MANPATH=”/usr/local/texlive/2017/texmf-dist/doc/man”</li><li>export INFOPATH=”/usr/local/texlive/2017/texmf-dist/doc/info”</li><li>export PATH=”/usr/local/texlive/2017/bin/x86_64-linux:$PATH”</li></ul></li><li>XeTeX 会使用 fontconfig 库来通过字体名搜索字体。TeX Live 的字体目录默认并不在 fongconfig 的搜索目录之列，因此需要按文档要求，将 TeX Live 安装目录下的 <code>texmf-var/fonts/conf/texlive-fontconfig.conf</code> 文件，复制到 <code>/etc/fonts/conf.d/09-texlive.conf</code>，然后运行 fc-cache，以确保 XeTeX 能搜索到字体。否则，TeX Live 自带的 OpenType 字体就只能以字体文件名的方式调用，非常不便。此外这样也能让系统的其他软件使用 TeX Live 安装的字体。<ul><li>建议先复制到临时文件夹，改名后，再<code>sudo mv</code></li></ul></li><li><p>如果需要以字体文件名调用 Linux 系统安装的字体，例如使用 CJK 宏包调用来自 Windows 的字体，那么还需要修改 TeX Live 安装目录的 texmf.cnf 文件，在其中设置 OSFONTDIR 变量，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSFONTDIR = ~/.fonts//;/usr/share/fonts//;/usr/share/fonts-droid//</span><br></pre></td></tr></table></figure><p>可能需要用<code>sudo gedit texmf.cnf</code>才修改得了。当然，这一步骤对多数用户的用处并不大。</p></li><li>在<code>/usr/bin/</code>目录下创建符号链接才能用pdflatex进行编译<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/texlive/2017/bin/x86_64-linux/pdflatex pdflatex</span><br></pre></td></tr></table></figure></li></ul><h1 id="安装LaTeX编辑器：TeXstudio"><a href="#安装LaTeX编辑器：TeXstudio" class="headerlink" title="安装LaTeX编辑器：TeXstudio"></a>安装LaTeX编辑器：TeXstudio</h1><p>去官网下deb包然后安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i XXX.deb</span><br></pre></td></tr></table></figure></p><p>打开TeXstudio，在倒数第二个选项(o)配置一下。首先配置语言为中文，然后编译器选pdflatex，其他的千万不要动。</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-12/0.png" width="700"><br><br><br><div class="image-caption"><br>配置语言为中文<br></div><br></div><div class="image-package"><br><img src="/assets/blog/img/2017-12-12/1.png" width="700"><br><br><br><div class="image-caption"><br>编译器选pdflatex<br></div><br></div><h1 id="其他宏包"><a href="#其他宏包" class="headerlink" title="其他宏包"></a>其他宏包</h1><h2 id="XeLatex"><a href="#XeLatex" class="headerlink" title="XeLatex"></a>XeLatex</h2><p><code>XeLatex</code> 是 <code>texlive-xetex</code> 包的一部分，用来支持中文。<br>安装的话需要运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install texlive-xetex</span><br></pre></td></tr></table></figure></p><p>加上依赖有1G大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年不到20天就到2018年了，才开始把latex用在写论文上。&lt;br&gt;原来只是学了用latex写公式，嫌latex的配置太麻烦，总想拿mardown结合latex搞事情，结果啥也没做到。&lt;br&gt;只好亲自入用latex编译论文的坑了。&lt;/p&gt;
&lt;p&gt;latex就是为写
      
    
    </summary>
    
    
      <category term="latex" scheme="http://xichen.pub/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>Web App 相关技术</title>
    <link href="http://xichen.pub/2017/12/10/2017-12-10-web-app/"/>
    <id>http://xichen.pub/2017/12/10/2017-12-10-web-app/</id>
    <published>2017-12-10T06:06:05.000Z</published>
    <updated>2018-01-05T05:03:59.281Z</updated>
    
    <content type="html"><![CDATA[<p>把技能点点在移动前端…</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>参考： <a href="http://junmer.github.io/mobile-dev-get-started/" target="_blank" rel="noopener">移动 Web 开发入门</a></li></ul><p>上面这个 slide 资料讲的非常好，算是一个入门的介绍吧。带我们建立基本的移动 web 开发知识体系和常见问题的实践。包含以下几个方面：</p><ul><li><p>基本概念</p><ul><li><p>Native</p><p>  本地应用 使用 Java \ Objective-C \ Swift 开发</p></li><li><p>WebApp</p><p>  网页应用 html5 开发</p></li><li><p>Hybrid</p><p>  混合应用 ooxx(native, web)</p></li><li><p>对比</p></li></ul></li><li><p>视觉</p><ul><li>设备的像素</li><li>文字单位使用 rem</li><li>viewport 属性</li><li>横屏竖屏</li><li>Flex 伸缩布局</li><li>响应式设计</li><li>软键盘</li><li>隐藏地址栏</li><li>苹果设备添加到主屏图标</li></ul></li><li>交互<ul><li>Touch</li><li>click 延迟</li><li>Scroll</li><li>Gestures(hammer –A javascript library for multi-touch gestures)</li><li>手指友好设计</li><li>HTML5 APIS（图像，摇动，声音等）</li></ul></li><li>实践<ul><li>屏蔽点击元素时的阴影</li><li>图像（像素、矢量图标、base64 减少请求、lazyload）</li><li>CSS3（合理使用渐变/圆角/阴影、代替 js 动画、translate3d、解决动画闪烁）</li><li>localStorage</li><li>避免（iframe、fixed + input）</li><li>SPA 或 Multi page</li><li>can I use</li><li>压缩合并</li><li>@G/3G 下建立连接时间</li></ul></li><li><p>调试</p><ul><li>浏览器自己的调试工具，模拟手机设备</li><li><p>weinre</p><p>  关于 weinre 我写了一篇博客介绍它。<a href="http://gaohaoyang.github.io/2015/06/18/weinre/" target="_blank" rel="noopener">Weinre –WebApp 调试工具</a></p></li></ul></li></ul><hr><h2 id="head-标签"><a href="#head-标签" class="headerlink" title="head 标签"></a>head 标签</h2><p>参考：</p><ul><li><a href="http://www.css88.com/archives/5480" target="_blank" rel="noopener">移动前端不得不了解的html5 head 头标签</a></li></ul><p>上面的链接详细的讲解了：</p><ul><li>DOCTYPE</li><li>charset</li><li>lang属性</li><li>优先使用 IE 最新版本和 Chrome</li><li>360 使用Google Chrome Frame</li><li>SEO 优化部分：页面标题<code>&lt;title&gt;</code>标签(head 头部必须)，页面关键词 keywords，页面描述内容 description，定义网页作者 author，网页搜索引擎索引方式</li><li><p>为移动设备添加 viewport</p><p>  <code>viewport</code> 可以让布局在移动浏览器上显示的更好。 通常会写</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> =<span class="string">"viewport"</span> <span class="attr">content</span> =<span class="string">"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>content 参数：</p><ul><li>width viewport 宽度(数值/device-width)</li><li>height viewport 高度(数值/device-height)</li><li>initial-scale 初始缩放比例</li><li>maximum-scale 最大缩放比例</li><li>minimum-scale 最小缩放比例</li><li>user-scalable 是否允许用户缩放(yes/no)</li></ul></li><li><p>ios 设备，iOS 图标，Android，Windows 8</p></li></ul><p><strong>总结：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> <span class="comment">&lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-cmn-Hans"</span>&gt;</span> <span class="comment">&lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明文档使用的字符编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">'utf-8'</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面描述 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"不超过150个字符"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面关键词 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 网页作者 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"name, email@gmail.com"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 搜索引擎抓取 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为移动设备添加 viewport --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- iOS 设备 begin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-title"</span> <span class="attr">content</span>=<span class="string">"标题"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-itunes-app"</span> <span class="attr">content</span>=<span class="string">"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置苹果工具栏颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telphone=no, email=no"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 避免IE使用兼容模式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"HandheldFriendly"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"MobileOptimized"</span> <span class="attr">content</span>=<span class="string">"320"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"screen-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"full-screen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-fullscreen"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"browsermode"</span> <span class="attr">content</span>=<span class="string">"application"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-page-mode"</span> <span class="attr">content</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-tap-highlight"</span> <span class="attr">content</span>=<span class="string">"no"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iOS 图标 begin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-57x57-precomposed.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">sizes</span>=<span class="string">"114x114"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-114x114-precomposed.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">sizes</span>=<span class="string">"144x144"</span> <span class="attr">href</span>=<span class="string">"/apple-touch-icon-144x144-precomposed.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iOS 图标 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- iOS 启动画面 begin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"768x1004"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-768x1004.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"1536x2008"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-1536x2008.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"1024x748"</span> <span class="attr">href</span>=<span class="string">"/Default-Portrait-1024x748.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"2048x1496"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-2048x1496.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPad 横屏 2048x1496（Retina） --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-320x480.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"640x960"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-640x960.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">sizes</span>=<span class="string">"640x1136"</span> <span class="attr">href</span>=<span class="string">"/splash-screen-640x1136.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- iOS 启动画面 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- iOS 设备 end --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-TileColor"</span> <span class="attr">content</span>=<span class="string">"#000"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Windows 8 磁贴颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-TileImage"</span> <span class="attr">content</span>=<span class="string">"icon.png"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Windows 8 磁贴图标 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"alternate"</span> <span class="attr">type</span>=<span class="string">"application/rss+xml"</span> <span class="attr">title</span>=<span class="string">"RSS"</span> <span class="attr">href</span>=<span class="string">"/rss.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加 RSS 订阅 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"shortcut icon"</span> <span class="attr">type</span>=<span class="string">"image/ico"</span> <span class="attr">href</span>=<span class="string">"/favicon.ico"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 添加 favicon icon --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="页面切换动画"><a href="#页面切换动画" class="headerlink" title="页面切换动画"></a>页面切换动画</h2><ul><li><a href="http://www.w3cplus.com/mobile/mobile-terminal-refactoring-slider.html" target="_blank" rel="noopener">移动端重构系列13——页面切换</a></li><li><a href="http://www.w3cplus.com/css3/css3-3d-transform.html" target="_blank" rel="noopener">CSS3 3D Transform</a></li></ul><p>关于 HammerJS 的一个中文文档</p><ul><li><a href="http://www.cnblogs.com/iamlilinfeng/p/4239957.html" target="_blank" rel="noopener">Hammer.js</a></li></ul><hr><h2 id="CSS-Processing"><a href="#CSS-Processing" class="headerlink" title="CSS Processing"></a>CSS Processing</h2><blockquote><p>CSS语言由于其自身语言设计的问题，加上一些浏览器兼容性问题，往往会使得我们在写它的时候，要写很多冗余代码，或者为了兼容性对同一个样式设定写好几遍。针对这些问题，诞生了CSS预处理和后处理的概念及相关方法、工具。</p><p>这些工具和方法帮助我们能够更加高效地书写可维护性更强的CSS代码。</p></blockquote><p>这里我尝试使用了 Sass，果然很好用。下面记录几个 sass 教程。</p><ul><li><a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="noopener">Sass入门-w3cplus</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">SASS用法指南-阮一峰</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先要有 ruby 环境。</p><p>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 <a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> 源，然后添加淘宝的源 <a href="https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入" target="_blank" rel="noopener">https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入</a> sass 安装命令 <code>gem install sass</code> 了。</p><pre><code>$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org$ gem install sass</code></pre><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre><code>sass --watch style.scss:style.css --style expanded</code></pre><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong><code>rem</code></strong></p><p>字体单位使用 rem，用户在手机上设置了字体大小时，不会打破布局，造成混乱。</p><ul><li><a href="http://www.w3cplus.com/css3/define-font-size-with-css3-rem" target="_blank" rel="noopener">CSS3的REM设置字体大小-w3cplus</a></li><li><a href="http://www.iyunlu.com/view/css-xhtml/76.html" target="_blank" rel="noopener">响应式十日谈第一日：使用 rem 设置文字大小-一丝</a></li></ul><hr><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><blockquote><p>安全是大家经常容易忽视，但其实一旦出现影响会非常大的问题，尤其对于没有经历过企业开发，或者没有踩过坑的同学，如果等到公司工作，做实际项目后非常容易发生安全问题。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>WEB基本攻击大致可以分为三大类：“资源枚举”、“参数操纵” 和 “其它攻击”</p><ul><li>资源枚举</li><li>参数操纵<ul><li>SQL注入</li><li>XPath注入</li><li>cgi命令执行</li><li>XXS（cross-site scripting跨域脚本攻击）其重点是“跨域”和“客户端执行”<ul><li>Reflected XSS ——基于反射的XSS攻击。主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。</li><li>DOM-based or local XSS——基于DOM或本地的XSS攻击</li><li>Stored XSS——基于存储的XSS攻击</li></ul></li><li>会话劫持</li></ul></li><li>其它攻击<ul><li>CSRF（cross-site request forgery）跨站请求伪造</li><li>钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。</li><li>拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。</li></ul></li></ul><h3 id="关于-XSS"><a href="#关于-XSS" class="headerlink" title="关于 XSS"></a>关于 XSS</h3><blockquote><p><strong>跨网站脚本</strong>（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p><p>——维基百科</p></blockquote><h3 id="XSS-防护"><a href="#XSS-防护" class="headerlink" title="XSS 防护"></a>XSS 防护</h3><ol><li><p>浏览器解析顺序：</p><p> HTML Parser &gt;&gt; CSS Parser &gt;&gt; JavaScript Parser</p></li><li><p>浏览器解码顺序：</p><p> HTML Decoding &gt;&gt; URL Decoding &gt;&gt; JavaScript Decoding</p></li><li><p>具体的防护方式：</p><ul><li>验证输入并且基于语境和按照正确的顺序转义不可信数据<ul><li>HTML 中的字符串</li><li>HTML 属性中的字符串</li><li>事件句柄属性和 JavaScript 中的字符串</li><li>HTML 属性中的 URL 路径</li><li>HTML 风格属性和 CSS 中的字符串</li><li>JavaScript 中的 HTML</li></ul></li><li>始终遵循白名单优于黑名单的做法</li><li>使用 UTF-8 为默认的字符编码以及设置 content 为 text/html</li><li>不要将用户可以控制的文本放在<meta>标签前。通过使用不同的字符集注射可以导致 XSS。</li><li>使用 &lt;!DOCTYPE html&gt;</li><li>使用推荐的 HTTP 响应头进行 XSS 防护</li><li>防止 CRLF 注入/HTTP 响应拆分</li><li>禁止 TRACE 和其他非必要方法</li></ul></li></ol><p>对于 innerHTML 的方式输出的，我们可以采用如下的方式转码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转码 XSS 防护</span></span><br><span class="line"><span class="comment"> * @param  &#123;String&#125; str 用户输入的字符串</span></span><br><span class="line"><span class="comment"> * @return &#123;String&#125;     转码后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#x27;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/\//g</span>, <span class="string">"&amp;#x2f;"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="http://www.cnblogs.com/vajoy/p/4176908.html" target="_blank" rel="noopener">浅谈WEB安全性（前端向）</a></li><li><a href="http://www.freebuf.com/articles/web/40520.html" target="_blank" rel="noopener">XSS的原理分析与解剖</a></li><li><a href="http://www.fooying.com/chinese-translationthe-ultimate-xss-protection-cheatsheet-for-developers/" target="_blank" rel="noopener">原创翻译：给开发者的终极XSS防护备忘录</a></li></ul><hr><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote><p>在自己做一些小项目时，可能是学校的一些网站项目，流量可能日均都不超过500，而且大多是校园局域网内访问；或者是开发一些实验室的MIS系统，这辈子你都不会去使用你开发的这个系统。在这样一些项目中，性能优化往往会被你忽略。</p><p>但是如果你是做一个日均PV数万、数十万、甚至更大的量级，开发的页面会被全国各地，不同网络条件的用户来进行访问。这个时候，性能问题就无法忽视了。在当今的网络条件下，如果你的页面3秒都无法完成首屏渲染，一定会让你的网站流失很多用户。</p><p>整个网站的性能优化有很多的环节和工作，大多数时候，不是前端工程师单独就能完成的，尤其在职能划分明确的公司中，往往需要前后端、运维、DBA等多个职位协同完成。所以，在我们的课程中，主要让你了解整个性能优化都涉及哪些方面的工作，同时，我们会专注介绍一些在前端领域可以重点关注的技术点。</p></blockquote><p>这里就是网页的打开速度，如果你的网页打开速度很慢，那么一定会有用户的流失。所以性能优化很重要。</p><ul><li>网页内容<ul><li>减少http请求次数</li><li>减少DNS查询次数</li><li>避免页面跳转</li><li>缓存Ajax</li><li>延迟加载</li><li>提前加载</li><li>减少DOM元素数量</li><li>根据域名划分内容</li><li>减少iframe数量</li><li>避免404</li></ul></li><li>服务器<ul><li>使用CDN</li><li>添加Expires 或Cache-Control报文头</li><li>Gzip压缩传输文件</li><li>配置ETags</li><li>尽早flush输出</li><li>使用GET Ajax请求</li><li>避免空的图片src</li></ul></li><li>Cookie<ul><li>减少Cookie大小</li><li>页面内容使用无cookie域名</li></ul></li><li>CSS<ul><li>将样式表置顶</li><li>避免CSS表达式</li><li>用\<link\>代替@import</link\></li><li>避免使用Filters</li></ul></li><li>Javascript<ul><li>将脚本置底</li><li>使用外部Javascirpt和CSS文件</li><li>精简Javascript和CSS</li><li>去除重复脚本</li><li>减少DOM访问</li><li>使用智能事件处理</li></ul></li><li>图片<ul><li>优化图像</li><li>优化CSS Sprite</li><li>不要在HTML中缩放图片</li><li>使用小且可缓存的favicon.ico</li></ul></li><li>移动客户端<ul><li>保持单个内容小于25KB</li><li>打包组建成符合文档</li></ul></li></ul><p>具体细节参考文章：</p><ul><li><a href="http://www.cnblogs.com/developersupport/p/webpage-performance-best-practices.html" target="_blank" rel="noopener">毫秒必争，前端网页性能最佳实践</a></li></ul><p>我在 ToDo 这个任务中主要使用了 CDN 来加载静态资源。比如我使用了 <a href="http://cdn.code.baidu.com/" target="_blank" rel="noopener">百度静态资源公共库</a>。引用了里面的 fontawesome，速度果然比在 GitHub 仓库里快很多。下一步是压缩我自己写的静态资源。</p><p>其他参考资料：</p><ul><li><a href="http://www.oschina.net/translate/front-end-performance-for-web-designers-and-front-end-developers#section:maximising-parallelisation" target="_blank" rel="noopener">给网页设计师和前端开发者看的前端性能优化</a></li><li><a href="http://www.zhangxinxu.com/wordpress/?p=3152" target="_blank" rel="noopener">梳理：提高前端性能方面的处理以及不足</a></li><li><a href="http://www.cnblogs.com/mofish/archive/2010/10/12/1849062.html" target="_blank" rel="noopener">css sprite原理优缺点及使用</a></li><li><a href="http://www.qianduan.net/css-sprites-useful-technique-or-potential-nuisance/" target="_blank" rel="noopener">CSS Sprites：鱼翅还是三鹿？</a></li><li><a href="http://www.cnblogs.com/leefreeman/p/3998757.html" target="_blank" rel="noopener">大型网站的灵魂——性能</a></li><li><a href="http://web.jobbole.com/35339/" target="_blank" rel="noopener">编写高效的 CSS 选择器</a></li></ul><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote><p>对于一个复杂项目，特别是多人协作的复杂项目，如何合理划分模块，如何更加方便地进行模块加载，如何管理模块之间的依赖，是一个项目团队都会面临的问题，目前业界已经有了一些较为普遍的解决方案，如AMD。这个部分希望你能够通过学习JavaScript的模块化，学习如何合理地规划项目模块，合理使用模块化工具来优化你的项目代码结构。</p></blockquote><p>一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。</p><p>根据AMD规范，我们可以使用 <code>define</code> 定义模块，使用 <code>require</code> 调用模块。</p><p>目前，通行的 js 模块规范主要有两种：<code>CommonJS</code> 和 <code>AMD</code>。</p><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p>AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是 CommonJS</p><p>模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。</p><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。</p><p>详细 API 如下：</p><ul><li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="noopener">AMD（中文版）</a>)</li></ul><hr><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。Node.JS 首先采用了 js 模块化的概念。</p><p>根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。</p><p>输出模块变量的最好方法是使用 module.exports 对象。</p><hr><h3 id="为什么要用-requireJS"><a href="#为什么要用-requireJS" class="headerlink" title="为什么要用 requireJS"></a>为什么要用 requireJS</h3><p>试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p><p>RequireJS就是为了解决这两个问题而诞生的：</p><blockquote><p>（1）实现js文件的异步加载，避免网页失去响应；<br>（2）管理模块之间的依赖性，便于代码的编写和维护。</p></blockquote><h4 id="requireJS"><a href="#requireJS" class="headerlink" title="requireJS"></a>requireJS</h4><ul><li><a href="http://requirejs.org/" target="_blank" rel="noopener">requireJS 官网</a></li><li><a href="http://www.requirejs.cn/" target="_blank" rel="noopener">requireJS 中文网</a></li></ul><hr><h3 id="AMD和CMD"><a href="#AMD和CMD" class="headerlink" title="AMD和CMD"></a>AMD和CMD</h3><p>CMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。</p><blockquote><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p></blockquote><ul><li><a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="noopener">CMD 模块定义规范</a></li></ul><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</p><blockquote><p>AMD:提前执行（异步加载：依赖先执行）+延迟执行<br>CMD:延迟执行（运行到需加载，根据顺序执行）</p></blockquote><hr><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">Javascript模块化编程（一）：模块的写法–阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程（三）：require.js的用法</a></li><li><a href="http://segmentfault.com/a/1190000000733959" target="_blank" rel="noopener">详解 JavaScript 模块开发</a></li><li><a href="http://www.cnblogs.com/jinguangguo/archive/2013/04/06/3002515.html?utm_source=tuicool" target="_blank" rel="noopener">浅谈模块化的JavaScript</a></li><li><a href="http://div.io/topic/430" target="_blank" rel="noopener">再谈 SeaJS 与 RequireJS 的差异</a></li><li>玩转AMD系列 by erik@EFE<ul><li><a href="http://efe.baidu.com/blog/dissecting-amd-preface/" target="_blank" rel="noopener">玩转AMD - 写在前面</a></li><li><a href="http://efe.baidu.com/blog/dissecting-amd-what/" target="_blank" rel="noopener">玩转AMD - 设计思路</a></li><li><a href="http://efe.baidu.com/blog/dissecting-amd-how/" target="_blank" rel="noopener">玩转AMD - 应用实践</a></li><li><a href="http://efe.baidu.com/blog/dissecting-amd-loader/" target="_blank" rel="noopener">玩转AMD - Loader</a>   </li></ul></li></ul><hr><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><blockquote><p>业界目前有非常多的前端开发工具，完成一些开发过程中可以自动化完成的工作，提高研发效率，并且可以提高多人协作时的开发过程一致性，提高整个项目的运维效率。</p><p>在EFE日常工作中，我们是基于EDP，完成项目开发过程中的项目构建、包管理、调试、单测、静态检测、打包、压缩、优化、项目部署等一系列所有工作。</p></blockquote><p>注：</p><p>如果网络不好，可以使用 <a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a>。</p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://div.io/topic/439" target="_blank" rel="noopener">前端工程与模块化框架</a></li><li><a href="http://mweb.baidu.com/p/baidusearch-front-end-road.html" target="_blank" rel="noopener">手机百度前端工程化之路</a></li><li><a href="http://www.infoq.com/cn/articles/yunlong-on-fis" target="_blank" rel="noopener">对话百度前端工程师张云龙：F.I.S与前端工业化</a></li><li><a href="https://github.com/ecomfe/edp" target="_blank" rel="noopener">EDP</a></li><li><a href="http://www.w3cplus.com/tools/grunt-tutorial-start-grunt.html" target="_blank" rel="noopener">Grunt教程——初涉Grunt</a></li><li><a href="http://www.open-open.com/lib/view/open1417068223049.html" target="_blank" rel="noopener">gulp入门指南</a></li><li><a href="http://www.w3ctech.com/topic/134" target="_blank" rel="noopener">Gulp开发教程（翻译）</a></li><li><a href="http://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp 中文网</a></li><li><a href="https://github.com/ericdum/mujiang.info/issues/6" target="_blank" rel="noopener">npm的package.json中文文档</a></li></ul><hr><h2 id="最终作品"><a href="#最终作品" class="headerlink" title="最终作品"></a>最终作品</h2><p>在任务三中，做了一个 PC 端的 ToDo 应用。任务四是将它优化，以适应移动端设备。</p><h3 id="ToDo-WebApp-Version"><a href="#ToDo-WebApp-Version" class="headerlink" title="ToDo WebApp Version"></a>ToDo WebApp Version</h3><ul><li><a href="https://github.com/baidu-ife/ife/tree/master/task/task0004" target="_blank" rel="noopener">任务四要求</a></li><li><a href="https://github.com/Gaohaoyang/ToDo-WebApp" target="_blank" rel="noopener">源代码</a></li><li><a href="http://gaohaoyang.github.io/ToDo-WebApp/" target="_blank" rel="noopener">在线 demo</a></li><li><p>手机查看 ↓ 二维码 ↓</p><p>  <img src="http://7q5cdt.com1.z0.glb.clouddn.com/task4-code-todoWebApp.png" alt="todoWebApp"></p></li><li><p><a href="http://gaohaoyang.github.io" target="_blank" rel="noopener">我的博客 HyG</a></p></li></ul><h3 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h3><ul><li><p><strong>数据存储</strong></p><p>  以 JSON 模拟数据表的形式存储于 LocalStorage 中</p><pre><code>使用数据库的思想，构建3张表。cateJson 分类childCateJson 子分类taskJson 任务分类表 cate----------------------id* | name | child(FK)----------------------子分类表 childCate--------------------------------id* | pid(FK) | name | child(FK)--------------------------------任务表 task----------------------------------------------id* | pid(FK) | finish | name | date | content----------------------------------------------</code></pre></li><li><p><strong>使用 <code>Sass</code> 重构了 CSS 代码</strong></p><p>  使用分块、继承等方式，使得代码更加清晰明了。</p></li><li><p><strong>响应式布局</strong></p><p>  针对手机端细节做了很多调整，更符合手机上的视觉交互习惯。</p></li><li><p><strong>加入页面切换效果</strong></p><p>  使用 <code>translate3d()</code>，纯 CSS3 切换动画效果。</p></li><li><p><strong>处理了 XSS 防护</strong></p><p>  对可能造成破坏的字符进行转码。</p></li><li><p><strong>性能优化</strong></p><p>  使用 CDN 处理静态资源 fontAwesome，压缩静态资源等</p></li><li><p><strong>模块化</strong></p><p>  使用 requireJS 模块化 JavaScript 代码。重构 JavaScript 代码。优化之前写的耦合性高的绑定事件，重新绑定事件，降低耦合性。期间根据具体需求重写了事件代理的代码。</p></li><li><p><strong>前端工程化</strong></p><p>  使用 gulp，自动编译 Sass，压缩 CSS 和 JavaScript 代码。并且配置了自动流程。</p></li></ul><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="webkit-tap-highlight-color-属性"><a href="#webkit-tap-highlight-color-属性" class="headerlink" title="-webkit-tap-highlight-color 属性"></a><code>-webkit-tap-highlight-color</code> 属性</h3><p>感谢 <a href="https://github.com/fiona23" target="_blank" rel="noopener">fiona</a> 指出。</p><p>safari移动端点击的时候会闪一下加上 <code>-webkit-tap-highlight-color: transparent;</code> 就不会闪了。</p><p>参考：</p><ul><li><a href="http://www.css88.com/webkit/-webkit-tap-highlight-color/" target="_blank" rel="noopener"><code>-webkit-tap-highlight-color</code>  css88</a></li><li><a href="http://ued.ctrip.com/webkitcss/prop/tap-highlight-color.html" target="_blank" rel="noopener"><code>-webkit-tap-highlight-color</code> 属性</a></li></ul><hr><h3 id="textarea-标签-disabled-颜色"><a href="#textarea-标签-disabled-颜色" class="headerlink" title="textarea 标签 disabled 颜色"></a>textarea 标签 disabled 颜色</h3><ul><li><p>为什么用 disabled 属性？</p><p>  因为我发现仅仅使用 readonly 属性，在 IE 下是显示光标的。于是使用 disabled。</p></li><li><p>出现的问题</p><p>  各家浏览器对于 disabled 属性有自己的样式设定，比如 IE 下是灰色的。苹果设备下也是。改变这些样式的方法也不是统一的。如果要兼容 Safari 必须加上</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">-webkit-text-fill-<span class="attribute">color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">-webkit-<span class="attribute">opacity</span>: <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>于是最终代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">-webkit-text-fill-color</span>: <span class="built_in">rgba</span>(0, 0, 0, 1);</span><br><span class="line">    <span class="attribute">-webkit-opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考：<a href="http://stackoverflow.com/a/4648315" target="_blank" rel="noopener">Disabled input text color 中的评论</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把技能点点在移动前端…&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;参考： &lt;a href=&quot;http://junmer.github.io/mobile-d
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://xichen.pub/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://xichen.pub/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://xichen.pub/tags/HTML/"/>
    
      <category term="CSS" scheme="http://xichen.pub/tags/CSS/"/>
    
      <category term="Sass" scheme="http://xichen.pub/tags/Sass/"/>
    
      <category term="移动端" scheme="http://xichen.pub/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="XSS" scheme="http://xichen.pub/tags/XSS/"/>
    
      <category term="AMD" scheme="http://xichen.pub/tags/AMD/"/>
    
      <category term="requireJS" scheme="http://xichen.pub/tags/requireJS/"/>
    
      <category term="CommonJS" scheme="http://xichen.pub/tags/CommonJS/"/>
    
      <category term="性能优化" scheme="http://xichen.pub/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="WebApp" scheme="http://xichen.pub/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>Git Tips</title>
    <link href="http://xichen.pub/2017/12/09/2017-12-9-git-tips/"/>
    <id>http://xichen.pub/2017/12/09/2017-12-9-git-tips/</id>
    <published>2017-12-09T13:36:00.000Z</published>
    <updated>2018-01-05T00:45:28.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h2><h3 id="克隆库"><a href="#克隆库" class="headerlink" title="克隆库"></a>克隆库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/php/php-src.git</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/php/php-src.git <span class="comment"># 只抓取最近的一次 commit</span></span><br></pre></td></tr></table></figure><h2 id="历史管理"><a href="#历史管理" class="headerlink" title="历史管理"></a>历史管理</h2><h3 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline filename <span class="comment"># 一行显示</span></span><br><span class="line">git show xxxx <span class="comment"># 查看某次修改</span></span><br></pre></td></tr></table></figure><h3 id="标签功能"><a href="#标签功能" class="headerlink" title="标签功能"></a>标签功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="comment"># 显示所有标签</span></span><br><span class="line">git tag -l <span class="string">'v1.4.2.*'</span> <span class="comment"># 显示 1.4.2 开头标签</span></span><br><span class="line">git tag v1.3 <span class="comment"># 简单打标签   </span></span><br><span class="line">git tag -a v1.2 9fceb02 <span class="comment"># 后期加注标签</span></span><br><span class="line">git tag -a v1.4 -m <span class="string">'my version 1.4'</span> <span class="comment"># 增加标签并注释， -a 为 annotated 缩写</span></span><br><span class="line">git show v1.4 <span class="comment"># 看某一标签详情</span></span><br><span class="line">git push origin v1.5 <span class="comment"># 分享某个标签</span></span><br><span class="line">git push origin --tags <span class="comment"># 分享所有标签</span></span><br></pre></td></tr></table></figure><h3 id="回滚操作"><a href="#回滚操作" class="headerlink" title="回滚操作"></a>回滚操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset 9fceb02 <span class="comment"># 保留修改</span></span><br><span class="line">git reset 9fceb02 --hard <span class="comment"># 删除之后的修改</span></span><br></pre></td></tr></table></figure><h3 id="取消文件的修改"><a href="#取消文件的修改" class="headerlink" title="取消文件的修改"></a>取消文件的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- a.php <span class="comment">#  取消单个文件</span></span><br><span class="line">git checkout -- <span class="comment"># 取消所有文件的修改</span></span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm a.php  <span class="comment"># 直接删除文件</span></span><br><span class="line">git rm --cached a.php <span class="comment"># 删除文件暂存状态</span></span><br></pre></td></tr></table></figure><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv a.php ./<span class="built_in">test</span>/a.php</span><br></pre></td></tr></table></figure><h3 id="查看文件修改"><a href="#查看文件修改" class="headerlink" title="查看文件修改"></a>查看文件修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff          <span class="comment"># 查看未暂存的文件更新 </span></span><br><span class="line">git diff --cached <span class="comment"># 查看已暂存文件的更新</span></span><br></pre></td></tr></table></figure><h3 id="暂存和恢复当前staging"><a href="#暂存和恢复当前staging" class="headerlink" title="暂存和恢复当前staging"></a>暂存和恢复当前staging</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 暂存当前分支的修改</span></span><br><span class="line">git stash apply <span class="comment"># 恢复最近一次暂存</span></span><br><span class="line">git stash list <span class="comment"># 查看暂存内容</span></span><br><span class="line">git stash apply stash@&#123;2&#125; <span class="comment"># 指定恢复某次暂存内容</span></span><br><span class="line">git stash drop stash@&#123;0&#125; <span class="comment"># 删除某次暂存内容</span></span><br></pre></td></tr></table></figure><h3 id="修改-commit-历史纪录"><a href="#修改-commit-历史纪录" class="headerlink" title="修改 commit 历史纪录"></a>修改 commit 历史纪录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 0580eab8</span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop <span class="comment"># 只创建分支</span></span><br><span class="line">git checkout -b master develop <span class="comment"># 创建并切换到 develop 分支</span></span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment"># 切换到 master 分支</span></span><br><span class="line">git merge --no-ff develop <span class="comment"># 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录</span></span><br><span class="line">git rebase develop <span class="comment"># rebase 当前分支到 develop</span></span><br><span class="line">git branch -d develop <span class="comment"># 删除 develop 分支</span></span><br></pre></td></tr></table></figure><h3 id="克隆远程分支"><a href="#克隆远程分支" class="headerlink" title="克隆远程分支"></a>克隆远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -r <span class="comment"># 显示所有分支，包含远程分支</span></span><br><span class="line">git checkout origin/android</span><br></pre></td></tr></table></figure><h3 id="修复develop上的合并错误"><a href="#修复develop上的合并错误" class="headerlink" title="修复develop上的合并错误"></a>修复develop上的合并错误</h3><ol><li>将merge前的commit创建一个分之，保留merge后代码</li><li>将develop <code>reset --force</code>到merge前，然后<code>push --force</code></li><li>在分支中rebase develop</li><li>将分支push到服务器上重新merge</li></ol><h3 id="强制更新到远程分支最新版本"><a href="#强制更新到远程分支最新版本" class="headerlink" title="强制更新到远程分支最新版本"></a>强制更新到远程分支最新版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master</span><br><span class="line">git submodule update --remote -f</span><br></pre></td></tr></table></figure><h2 id="Submodule使用"><a href="#Submodule使用" class="headerlink" title="Submodule使用"></a>Submodule使用</h2><h3 id="克隆带submodule的库"><a href="#克隆带submodule的库" class="headerlink" title="克隆带submodule的库"></a>克隆带submodule的库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive https://github.com/chaconinc/MainProject</span><br></pre></td></tr></table></figure><h3 id="clone主库后再去clone-submodule"><a href="#clone主库后再去clone-submodule" class="headerlink" title="clone主库后再去clone submodule"></a>clone主库后再去clone submodule</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chaconinc/MainProject</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure><h2 id="Git设置"><a href="#Git设置" class="headerlink" title="Git设置"></a>Git设置</h2><p>Git的全局设置在<code>~/.gitconfig</code>中，单独设置在<code>project/.git/config</code>下。</p><p>忽略设置全局在<code>~/.gitignore_global</code>中，单独设置在<code>project/.gitignore</code>下。</p><h3 id="设置-commit-的用户和邮箱"><a href="#设置-commit-的用户和邮箱" class="headerlink" title="设置 commit 的用户和邮箱"></a>设置 commit 的用户和邮箱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"xx"</span></span><br><span class="line">git config user.email <span class="string">"xx@xx.com"</span></span><br></pre></td></tr></table></figure><p>或者直接修改config文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = xxx</span><br><span class="line">    email = xxx@xxx.com</span><br></pre></td></tr></table></figure><h3 id="查看设置项"><a href="#查看设置项" class="headerlink" title="查看设置项"></a>查看设置项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="设置git终端颜色"><a href="#设置git终端颜色" class="headerlink" title="设置git终端颜色"></a>设置git终端颜色</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.branch auto</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;库管理&quot;&gt;&lt;a href=&quot;#库管理&quot; class=&quot;headerlink&quot; title=&quot;库管理&quot;&gt;&lt;/a&gt;库管理&lt;/h2&gt;&lt;h3 id=&quot;克隆库&quot;&gt;&lt;a href=&quot;#克隆库&quot; class=&quot;headerlink&quot; title=&quot;克隆库&quot;&gt;&lt;/a&gt;克隆库&lt;/h
      
    
    </summary>
    
      <category term="Tips" scheme="http://xichen.pub/categories/Tips/"/>
    
    
      <category term="Tips" scheme="http://xichen.pub/tags/Tips/"/>
    
      <category term="Git" scheme="http://xichen.pub/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>网页排序算法（三）代数方法求PageRank</title>
    <link href="http://xichen.pub/2017/12/08/2017-12-08-%E7%BD%91%E9%A1%B5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%BB%A3%E6%95%B0%E6%96%B9%E6%B3%95%E6%B1%82PageRank/"/>
    <id>http://xichen.pub/2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/</id>
    <published>2017-12-08T12:22:00.000Z</published>
    <updated>2018-01-05T00:45:28.294Z</updated>
    
    <content type="html"><![CDATA[<p>本文结合实例介绍如何用代数方法求PageRank。</p><p>博文<a href="https://linxueyuanstdio.github.io/2017/12/%E7%BD%91%E9%A1%B5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80-PageRank/" target="_blank" rel="noopener">《网页排序算法（一）PageRank》</a>介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即：</p><p>$$PR(p<em>i)=\frac{1−d}{N}+d \sum</em>{p_j\in B(p_i)} \frac{PR(p_j)}{L(p_j)}$$</p><p>下文结合图1介绍如何用代数方法求PageRank。</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-8/0.png" width="700"><br><br><br><div class="image-caption">Fig. 1: PageRanks for a simple network (image from Wikipedia)</div><br></div><p>为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-8/1.png" width="700"><br><br><br><div class="image-caption"><br>Fig. 2: Draw Fig. 1 in NetworkX.<br></div><br></div><h1 id="代数方法"><a href="#代数方法" class="headerlink" title="代数方法"></a>代数方法</h1><p>根据1中的等式，把所有节点都放在一块，可以得到：</p><p>$$\begin{bmatrix}<br>PR(p_1) \<br>PR(p_2) \<br>\vdots \<br>PR(p_3)<br>\end{bmatrix} =<br>\begin{bmatrix}<br>{(1-d)/ N} \<br>{(1-d) / N} \<br>\vdots \<br>{(1-d) / N}<br>\end{bmatrix}</p><ul><li>d<br>\begin{bmatrix}<br>\ell(p_1,p_1) &amp; \ell(p_1,p_2) &amp; \cdots &amp; \ell(p_1,p_N) \<br>\ell(p_2,p_1) &amp; \ddots &amp;  &amp; \vdots \<br>\vdots &amp; &amp; \ell(p_i,p_j) &amp; \<br>\ell(p_N,p_1) &amp; \cdots &amp; &amp; \ell(p_N,p_N)<br>\end{bmatrix}<br>\begin{bmatrix}<br>PR(p_1) \<br>PR(p_2) \<br>\vdots \<br>PR(p_3)<br>\end{bmatrix}$$</li></ul><p>上述等式可以缩写为：</p><p>$$\mathbf{R} = d \mathcal{M}\mathbf{R} + \frac{1-d}{N} \mathbf{1}.       (**)$$</p><p>其中，1为N维的列向量，所有元素皆为1。以图1为例，该列向量为，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">N = len(G.nodes())      <span class="comment"># N = 11</span></span><br><span class="line">column_vector = np.ones((N, <span class="number">1</span>), dtype=np.int)</span><br><span class="line"> </span><br><span class="line">[[<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="Adjacency-function"><a href="#Adjacency-function" class="headerlink" title="Adjacency function"></a>Adjacency function</h2><p>邻接函数（adjacency function）$$\ell(p_1,p_2)$$组成了矩阵M，</p><p>$$\mathcal{M}_{ij} =\ell(pi,pj) =  \begin{cases} 1 /L(p_j) , &amp; \mbox{if }j\mbox{ links to }i\ L(pj)是指从pj链出去的网页数目\ 0, &amp; \mbox{otherwise} \end{cases}$$</p><p>这样矩阵每一行乘以R，就得到了新的PR值，比如第二行（图1的节点B），</p><p>$$\begin{align}<br>M_{2j}    &amp;=\ell(p_2,p_1)⋅PR(p_2)+\ell(p_2,p_2)⋅PR(p_2)+⋯+\ell(p_2,p_N)⋅PR(p_2)\<br>&amp;=0 (‘A’)+0 (‘B’)+1 (‘C’)+12 (‘D’)+13 (‘E’)+12 (‘F’) +12 (‘G’)+12 (`H’)+12 (‘I’)+0 (‘J’)+0 (‘K’)<br> \end{align}$$</p><p>以节点<code>G</code>为例，<code>G</code>给<code>B</code>和<code>E</code>投票，所以<code>B</code>得到<code>1/2</code>。</p><p>矩阵<code>M</code>每一列加起来都是<code>1</code>（值得注意的是，对于没有出链的节点，列加起来等于0，比如图1的节点<code>A</code>），即<br>$$\sum_{i=1}^{N}\ell(p_i,p_j)=1$$。事实上，M是一个转移矩阵transition matrix（也叫概率矩阵probability matrix，马尔可夫矩阵Markov matrix）。因此，PageRank是eigenvector centrality的一个变体。</p><h2 id="矩阵M"><a href="#矩阵M" class="headerlink" title="矩阵M"></a>矩阵M</h2><p>事实上，M可以被看成normalized的图邻接矩阵，即：</p><p>$$M=(K^{−1}A)^T$$<br>其中，A为图的邻接矩阵，以图1为例，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get adjacency matrix</span></span><br><span class="line">nodelist = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>]  <span class="comment"># sorted(G.nodes())</span></span><br><span class="line">A = nx.to_numpy_matrix(G, nodelist)</span><br><span class="line"> </span><br><span class="line">  <span class="string">'A'</span> <span class="string">'B'</span> <span class="string">'C'</span> <span class="string">'D'</span> <span class="string">'E'</span> <span class="string">'F'</span> <span class="string">'G'</span> <span class="string">'H'</span> <span class="string">'I'</span> <span class="string">'J'</span> <span class="string">'K'</span></span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure></p><p>A是对角矩阵，对角线上的元素是对应节点的出度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nodelist = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>]  <span class="comment"># sorted(G.nodes())</span></span><br><span class="line">list_outdegree = map(operator.itemgetter(<span class="number">1</span>), sorted(G.out_degree().items()))</span><br><span class="line">K = np.diag(list_outdegree)</span><br><span class="line"> </span><br><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p><p>K的逆矩阵$$K^{-1}$$为，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">K_inv = np.linalg.pinv(K)</span><br><span class="line"> </span><br><span class="line">[[ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">1.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">1.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.33</span>  <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">1.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">1.</span>  ]]</span><br></pre></td></tr></table></figure></p><p>那么，根据公式$$M=(K^{−1}A)^T$$就可以求得M，如下，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">M = (K_inv * A).transpose()</span><br><span class="line"> </span><br><span class="line">[[ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">1.</span>    <span class="number">0.5</span>   <span class="number">0.33</span>  <span class="number">0.5</span>   <span class="number">0.5</span>   <span class="number">0.5</span>   <span class="number">0.5</span>   <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">1.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.33</span>  <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.5</span>   <span class="number">0.5</span>   <span class="number">0.5</span>   <span class="number">0.5</span>   <span class="number">1.</span>    <span class="number">1.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.33</span>  <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]</span><br><span class="line"> [ <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>    <span class="number">0.</span>  ]]</span><br></pre></td></tr></table></figure></p><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>R是2.1等式的特征向量（eigenvector），求解等式得：</p><p>$$\mathbf{R} =  (\mathbf{I}-d \mathcal{M})^{-1}  \frac{1-d}{N}  \mathbf{1},$$</p><p>其中$$\mathbf{I}$$是单位矩阵。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d = <span class="number">0.85</span></span><br><span class="line">I = np.identity(N)</span><br><span class="line">R = np.linalg.pinv(I - d*M) * (<span class="number">1</span>-d)/N * column_vector </span><br><span class="line"> </span><br><span class="line">[[ <span class="number">0.028</span>]</span><br><span class="line"> [ <span class="number">0.324</span>]</span><br><span class="line"> [ <span class="number">0.289</span>]</span><br><span class="line"> [ <span class="number">0.033</span>]</span><br><span class="line"> [ <span class="number">0.068</span>]</span><br><span class="line"> [ <span class="number">0.033</span>]</span><br><span class="line"> [ <span class="number">0.014</span>]</span><br><span class="line"> [ <span class="number">0.014</span>]</span><br><span class="line"> [ <span class="number">0.014</span>]</span><br><span class="line"> [ <span class="number">0.014</span>]</span><br><span class="line"> [ <span class="number">0.014</span>]]</span><br></pre></td></tr></table></figure></p><p>咦，结果怎么跟图1不一样。得到R需要normalized，如此，所有节点的PR加起来才能等于1。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">R = R/sum(R)    <span class="comment"># normalized R, so that page ranks sum to 1.</span></span><br><span class="line"> </span><br><span class="line">[[ <span class="number">0.033</span>]</span><br><span class="line"> [ <span class="number">0.384</span>]</span><br><span class="line"> [ <span class="number">0.343</span>]</span><br><span class="line"> [ <span class="number">0.039</span>]</span><br><span class="line"> [ <span class="number">0.081</span>]</span><br><span class="line"> [ <span class="number">0.039</span>]</span><br><span class="line"> [ <span class="number">0.016</span>]</span><br><span class="line"> [ <span class="number">0.016</span>]</span><br><span class="line"> [ <span class="number">0.016</span>]</span><br><span class="line"> [ <span class="number">0.016</span>]</span><br><span class="line"> [ <span class="number">0.016</span>]]</span><br></pre></td></tr></table></figure></p><p>用NetworkX作出来的图，是这样的：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-8/2.png" width="700"><br><br><br><div class="image-caption"><br>Fig. 3: PageRanks for a simple network<br></div><br></div><h1 id="Python源代码"><a href="#Python源代码" class="headerlink" title="Python源代码"></a>Python源代码</h1><p>NetworkX实现了PageRank的代数计算方法<code>nx.pagerank_numpy</code>，源代码在这里。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pagerank_numpy</span><span class="params">(G, alpha=<span class="number">0.85</span>, personalization=None, weight=<span class="string">'weight'</span>, dangling=None)</span>:</span></span><br><span class="line">    <span class="string">"""Return the PageRank of the nodes in the graph.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> len(G) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    M = google_matrix(G, alpha, personalization=personalization,</span><br><span class="line">                      weight=weight, dangling=dangling)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># use numpy LAPACK solver</span></span><br><span class="line">    eigenvalues, eigenvectors = np.linalg.eig(M.T)</span><br><span class="line">    ind = eigenvalues.argsort()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># eigenvector of largest eigenvalue at ind[-1], normalized</span></span><br><span class="line">    largest = np.array(eigenvectors[:, ind[<span class="number">-1</span>]]).flatten().real</span><br><span class="line">    norm = float(largest.sum())</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> dict(zip(G, map(float, largest / norm)))</span><br></pre></td></tr></table></figure></p><p>References:</p><ul><li>[1] <a href="http://stackoverflow.com/questions/42224302/incorrect-pagerank-calculation-result" target="_blank" rel="noopener">StackOverflow: Incorrect PageRank calculation result</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文结合实例介绍如何用代数方法求PageRank。&lt;/p&gt;
&lt;p&gt;博文&lt;a href=&quot;https://linxueyuanstdio.github.io/2017/12/%E7%BD%91%E9%A1%B5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3
      
    
    </summary>
    
    
      <category term="PageRank" scheme="http://xichen.pub/tags/PageRank/"/>
    
  </entry>
  
  <entry>
    <title>网页排序算法（二）迭代方法求PageRank</title>
    <link href="http://xichen.pub/2017/12/07/2017-12-07-%E7%BD%91%E9%A1%B5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%E6%B1%82PageRank/"/>
    <id>http://xichen.pub/2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/</id>
    <published>2017-12-07T12:22:00.000Z</published>
    <updated>2018-01-05T00:45:28.292Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何用迭代的方法计算PageRank。</p><h1 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h1><p>博文<a href="https://linxueyuanstdio.github.io/2017/12/%E7%BD%91%E9%A1%B5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80-PageRank/" target="_blank" rel="noopener">《网页排序算法（一）PageRank》</a>介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即：</p><p>$$PR(p<em>i)=\frac{1−d}{N}+d\sum</em>{p_j\in B(p_i)}\frac{PR(pj)}{L(p_j)}$$</p><p>下文结合图1介绍如何用迭代方法求PageRank。</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-7/0.png" width="700"><br><br><br><div class="image-caption">Fig. 1: PageRanks for a simple network (image from Wikipedia).</div><br></div><p>为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-7/1.png" width="700"><br><br><br><div class="image-caption">Fig. 2: Label nodes in Fig. 1.</div><br></div><h1 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h1><h2 id="初始化节点PR值"><a href="#初始化节点PR值" class="headerlink" title="初始化节点PR值"></a>初始化节点PR值</h2><p>如果没有给节点指定PR初始值，那么每个节点的PR初始化为1/N (N为节点数目)，以图1为例，节点的PR初始值为<code>1/11</code>：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-7/2.png" width="700"><br><br><br><div class="image-caption">Fig. 3: The graph with starting value of PageRank iteration for each node.</div><br></div><p>相应源代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Step 1: Initiate PageRank</span></span><br><span class="line">N = G.number_of_nodes()                     <span class="comment"># N = 11</span></span><br><span class="line">node_and_pr = dict.fromkeys(G, <span class="number">1.0</span> / N)</span><br></pre></td></tr></table></figure></p><h2 id="创建随机图（stochastic-graph）"><a href="#创建随机图（stochastic-graph）" class="headerlink" title="创建随机图（stochastic graph）"></a>创建随机图（stochastic graph）</h2><p>随机图（stochastic graph）是一个有向带权图，边的权重被normalized，使得每个节点的outedges的权重加起来为1。事实上，边的权重即为$$1/L(p_j)$$，图1的随机图如下：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-7/3.png" width="700"><br><br><br><div class="image-caption"><br>Fig. 4: The stochastic graph<br></div><br></div><p>比如，节点<code>D</code>有两条出链，<code>D --&gt; A</code>和<code>D --&gt; B</code>，所以他们的边权重都是0.5。源代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stochastic_graph = nx.stochastic_graph(G, weight=weight)    <span class="comment"># M = 1/L(pj)</span></span><br><span class="line"> </span><br><span class="line">print(stochastic_graph[<span class="string">'D'</span>])</span><br><span class="line">&#123;<span class="string">'A'</span>: &#123;<span class="string">'Edge Id'</span>: <span class="string">u'5'</span>, <span class="string">'weight'</span>: <span class="number">0.5</span>&#125;, <span class="string">'B'</span>: &#123;<span class="string">'Edge Id'</span>: <span class="string">u'6'</span>, <span class="string">'weight'</span>: <span class="number">0.5</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="迭代计算"><a href="#迭代计算" class="headerlink" title="迭代计算"></a>迭代计算</h2><p>遍历所有节点，将每个节点的PR值平均分给其出链的节点，即$$\sun_{p_j\in B(p_i)}\frac{PR(p_j)}{L(p_j)}$$，乘以阻尼系数d，再加上(1−d)/N。源代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dangling_value = (<span class="number">1</span>-d)/N</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(max_iter):       <span class="comment"># for each iteration</span></span><br><span class="line">    node_and_prev_pr = node_and_pr</span><br><span class="line">    node_and_pr = dict.fromkeys(node_and_prev_pr.keys(), <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> node_and_pr:    <span class="comment"># for each node</span></span><br><span class="line">        <span class="keyword">for</span> out_node <span class="keyword">in</span> stochastic_graph[node]:     <span class="comment"># node --&gt; out_node</span></span><br><span class="line">            node_and_pr[out_node] += d * node_and_prev_pr[node] * stochastic_graph[node][out_node][weight]  <span class="comment"># PR(p_i) = d * PR(p_j)&#125;/L(p_j)</span></span><br><span class="line"> </span><br><span class="line">        node_and_pr[node] += dangling_value</span><br></pre></td></tr></table></figure></p><p>第一次迭代结果如下图所示（有些箭头没显示出来，NetworkX可视化很弱）：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-7/4.png" width="700"><br><br><br><div class="image-caption"><br>Fig. 5: PageRank after one ieration<br></div><br></div><p>那什么时候程序结束呢。将迭代后的PR值跟前一次比较，如果差别很少（如<code>PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6）</code>，就可以停止迭代了。源代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check convergence, l1 norm</span></span><br><span class="line">err = sum([abs(node_and_pr[node] - node_and_prev_pr[node]) <span class="keyword">for</span> node <span class="keyword">in</span> node_and_pr])</span><br><span class="line"><span class="keyword">if</span> err &lt; N*tol:</span><br><span class="line">    <span class="keyword">return</span> node_and_pr</span><br></pre></td></tr></table></figure></p><p>在本例中，需要66次迭代，最后得到的PageRank，如下图：</p><p>wikipedia_pagerank_example_pr<br>Fig. 6: Stable PageRank values (66 iterations)</p><p>我在想一个问题，上面的方法，每次迭代都是基于上一次的PR值，能不能这样，迭代的时候使用最新的值，这样会不能减少迭代次数，如下所示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始值</span></span><br><span class="line">PA(D) = <span class="number">0.09</span></span><br><span class="line">PA(B) = <span class="number">0.09</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 第一次迭代</span></span><br><span class="line">PA(D)/2 --&gt; P(A), P(B)  # 此时， PB(B)=0.045</span><br><span class="line">PB(B) --&gt; P(C)          # 按上面的算法，PB(B)=0.09，那能不能使用刚更新的PR值0.045，这样会不会快一些？</span><br></pre></td></tr></table></figure></p><h1 id="NetworkX的pagerank"><a href="#NetworkX的pagerank" class="headerlink" title="NetworkX的pagerank"></a>NetworkX的pagerank</h1><p>nx.pagerank跟章节2差不多，区别在于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2中的算法</span></span><br><span class="line">node_and_pr[node] += (<span class="number">1.0</span> - d)/N</span><br><span class="line"> </span><br><span class="line"><span class="comment"># nx.pagerank</span></span><br><span class="line">danglesum = d * sum(node_and_prev_pr[node] <span class="keyword">for</span> node <span class="keyword">in</span> dangling_nodes)</span><br><span class="line">node_and_pr[node] += danglesum/N + (<span class="number">1.0</span> - d)/N  <span class="comment"># danglesum/N  + (1-d)/N</span></span><br></pre></td></tr></table></figure></p><p>nx.pagerank将图中所有悬挂节点（dangling nodes，没有出链的节点，图1只有节点A）的PR累加，并normalized，再加上(1.0–d)/N。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文介绍如何用迭代的方法计算PageRank。&lt;/p&gt;
&lt;h1 id=&quot;PageRank&quot;&gt;&lt;a href=&quot;#PageRank&quot; class=&quot;headerlink&quot; title=&quot;PageRank&quot;&gt;&lt;/a&gt;PageRank&lt;/h1&gt;&lt;p&gt;博文&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="PageRank" scheme="http://xichen.pub/tags/PageRank/"/>
    
  </entry>
  
  <entry>
    <title>区块链开发（二）部署并运行以太坊智能合约</title>
    <link href="http://xichen.pub/2017/12/06/2017-12-06-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E9%83%A8%E7%BD%B2%E5%B9%B6%E8%BF%90%E8%A1%8C%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    <id>http://xichen.pub/2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/</id>
    <published>2017-12-06T12:21:00.000Z</published>
    <updated>2018-01-05T00:45:28.291Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>区块链开发（零）概念入门</title>
    <link href="http://xichen.pub/2017/12/06/2017-11-27-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%EF%BC%88%E9%9B%B6%EF%BC%89%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"/>
    <id>http://xichen.pub/2017/12/06/2017-11-27-区块链开发（零）概念入门/</id>
    <published>2017-12-06T12:21:00.000Z</published>
    <updated>2018-01-05T00:45:28.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。</p><p>可以用 <a href="https://github.com/samr7/vanitygen" target="_blank" rel="noopener">vanitygen</a> 来生成包含一定字母的地址。</p><h2 id="BIP"><a href="#BIP" class="headerlink" title="BIP"></a>BIP</h2><p>比特币改进提议 （Bitcoin Improvement Proposals 的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>“比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。</p><h2 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h2><p>当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。</p><h2 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h2><p>整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。</p><h2 id="难度目标"><a href="#难度目标" class="headerlink" title="难度目标"></a>难度目标</h2><p>使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。</p><h2 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h2><p>整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>二进制数据的一种数字指纹。</p><h2 id="创世区块"><a href="#创世区块" class="headerlink" title="创世区块"></a>创世区块</h2><p>创世区块指区块链上的第一个区块，用来初始化相应的加密货币。</p><h2 id="矿工"><a href="#矿工" class="headerlink" title="矿工"></a>矿工</h2><p>矿工指通过不断重复哈希运算来产生工作量证明的各网络节点。</p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>描述挖矿的一个好方法是将之类比为一个巨大的多人数独谜题游戏。一旦有人发现正解之后，这个数独游戏会自动调整困难度以使游戏每次需要大约10分钟解决。想象一个有几千行几千列的巨大数独游戏。如果给你一个已经完成的数独，你可以很快地验证它。然而，如果这个数独只有几个方格里有数字其余方格都为空的话，就会花费非常长的时间来解决。这个数独游戏的困难度可以通过改变其大小（更多或更少行列）来调整，但即使它非常大时验证它也是相当容易的。而比特币中的 “谜题” 是基于哈希加密算法的，其展现了相似的特性：非对称地，它解起来困难而验证很容易，并且它的困难度可以调整。</p><p>当区块一个个堆上来时，这个交易变得指数级地越来越难被推翻，因此它在网络中得到更多信任。</p><h2 id="矿工费"><a href="#矿工费" class="headerlink" title="矿工费"></a>矿工费</h2><p>交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>比特币网络是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。</p><h2 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h2><p>工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。</p><h2 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h2><p>每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有25比特币的奖励。</p><h2 id="私钥"><a href="#私钥" class="headerlink" title="私钥"></a>私钥</h2><p>用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh。</p><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。</p><p>转出是交易，转入也是交易。</p><ul><li>一般交易。一个地址转到另一个地址，用不完会“找零”。</li><li>集合型交易。多个地址转向一个地址，钱包用来汇合零钱。</li><li>分散型交易。一个转向多个，如发工资。</li></ul><p>交易的输出会被创建成为一个包含这笔数额的脚本的形式，只能被引入这个脚本的一个解答后才能兑换。</p><h2 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h2><p>钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。</p><p>比特币地址以数字1或3开头。类似于电子邮件地址，这些地址可以分享给其他的比特币的用户，这样他们就可以直接通过这些地址发送比特币到你的钱包里。不同于电邮地址的是，你可以任意地创建新的比特币地址，这些地址都能成功地将资金转到你的钱包。</p><p>钱包是多个地址和解锁资金密钥的简单集合。每笔交易你都可以使用不同的地址，这有利于提高隐私的安全性。用户可创建地址的数量几乎不受限制。</p><p>一个地址对应一个秘钥，像支付宝的付款码，其在支付宝后台也有一个对应的秘钥，验证交易。</p><p>直到这个地址接收到在比特币账簿（区块链）中公布过的一笔交易时，才会成为众多可能“有效”的比特币地址之一。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>平均每10分钟就有人能验证过去这10分钟发生的交易，他将会获得新币作为工作回报。本质上，挖矿把央行的货币发行和结算功能进行分布式，用全球化的算力竞争来取代对中央发行机构的需求。</p><p>比特币系统包含调节挖矿难度的协议。挖矿——在比特币网络中成功写入一个区块交易——的难度是动态调整的，保证不管有多少矿工（多少CPU）挖矿，平均每10分钟只有一个矿工成功。</p><p>任何接受数字货币的人都面临的两个基本问题是：</p><p>我能相信这钱是真实可信的，而不是伪造的吗？<br>我能确定没人说这笔钱是他们的，而不是我的吗？（又名“双重支付”问题）</p><p>比特币代表了数十年的密码学和分布式系统的巅峰之作，这是一个独特而强大的组合，汇集了四个关键的创新点。比特币由这些构成：</p><ul><li>一个去中心化的点对点网络（比特币协议）</li><li>一个公共的交易账簿（区块链）</li><li>一个去中心化的数学的和确定性的货币发行（分布式挖矿）</li><li>一个去中心化的交易验证系统（交易脚本）</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a href="http://blockchain.info/" target="_blank" rel="noopener">http://blockchain.info/</a> 可以查看所有交易信息</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://zhibimo.com/read/wang-miao/mastering-bitcoin" target="_blank" rel="noopener">http://zhibimo.com/read/wang-miao/mastering-bitcoin</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h2&gt;&lt;p&gt;比特币
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>网页排序算法（一）PageRank</title>
    <link href="http://xichen.pub/2017/12/05/2017-12-05-%E7%BD%91%E9%A1%B5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89PageRank/"/>
    <id>http://xichen.pub/2017/12/05/2017-12-05-网页排序算法（一）PageRank/</id>
    <published>2017-12-05T12:22:00.000Z</published>
    <updated>2018-01-05T00:45:28.291Z</updated>
    
    <content type="html"><![CDATA[<p>参加数学建模的时候要研究一下PageRank，为了巩固3天从入门到精通的成果，把了解到的整理成文。</p><h1 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>PageRank是以Google创始人Larry Page的姓命名的，于1999被提出来，用于测量网页的相对重要性（对网页进行排序），学术论文如下：</p><blockquote><p>Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF]</p></blockquote><p>PageRank的设计受到学术论文引用启发（两人的父亲都是大学教授）。衡量一篇学术论文质量高与否，最重要的一个指标是引用次数，高引用量的论文通常意味着高质量。同理，如果一张网页被引用（以超链接的形式）多了，那么这张网页就比较重要。总结起来，PageRank的核心思想有两点（结合图1说明）：</p><ul><li>越多的网页链接到一个网页（可以理解成投票，<code>D --&gt; B</code>，<code>D</code>给<code>B</code>投了一票），说明这个网页更加重要，如图1的<code>B</code>。(一篇论文被很多论文引用)</li><li>PageRank高的网页链接到一个网页，说明这张网页也很重要。如图1，尽管C只有一张网页B链接到它，但C的重要性高于E，尽管E有一堆小罗罗给它投票。（论文被大牛引用了，说明这篇论文很有价值）（也可以从话语权角度理解，重要的人说话份量重）</li></ul><div class="image-package"><br><img src="/assets/blog/img/2017-12-5/0.png" width="700"><br><br><br><div class="image-caption">Fig. 1: PageRanks for a simple network (image from Wikipedia)</div><br></div><p>整个万维网（World Wide Web）可以抽象成一张有向图，节点表示网页，连线$$p_i\to p_j$$表示网页$$p_i$$包含了超链接$$p_j$$（$$p_i$$指向了$$p_j$$）。如果能对图中每个节点重要性量化，那么就能对网页进行排序了。PageRank提出之初就是为了对网页进行排序。</p><p>搜索引擎的工作原理可以简化为：输入关键词，返回与该关键词相关的网页（一个集合，相当于得到一张子图），在该子图上计算每个节点的PageRank值，PR值高的网页排在前面，低的就排在后面。</p><h2 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h2><p>接下来的问题是，如何计算每个节点的PageRank。想要知道一个网页$$p_i$$的PR值，需要知道：</p><ul><li>有多少网页链接到了$$p_i$$</li><li>这些网页的PR值是多少<br>其他网页的PR值又很可能是依赖于$$p_i$$，这就陷入了“先有鸡还是先有蛋”的循环，要想知道$$p_i$$的PR值，就得知道链向$$p_i$$所有网页的PR值，而要知道其他网页的PR值，又得先知道$$p_i$$的PR值。</li></ul><p>为了打破这个循环，佩奇和布林采用了一个很巧妙的思路， 即分析一个虚拟用户在互联网上的漫游过程。 他们假定：虚拟用户一旦访问了一个网页，下一步将以相同的概率访问被该网页所链接的任何一个其它网页[3]。比如，网页$$p_i$$包含N个超链接，那么虚拟用户访问这N个页面中的任何一个的概率是1/N。那么，网页的排序就可以看成一个虚拟用户在万维网漫游了很长时间，页面被访问的概率越大，其PR值就越高，网页排名也越靠前。</p><p>先从简化的PageRank说起，以PageRank论文的例子为例，看看PageRank是怎么计算的，如下：</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-5/1.png" width="700"><br><br><br><div class="image-caption">Fig. 2: Simplified PageRank calculation (image from [1])</div><br></div><p>每个节点初始化或者指定一个PageRank值（如<code>PR(A)=0.4</code>），网页<code>A</code>包含两个超链接，分别指向<code>B</code>和<code>C</code>（或者说<code>A</code>投票给<code>B</code>和<code>C</code>），<code>0.4</code>拆分成两份，每份<code>0.2</code>，所以<code>PR(B)=0.2</code>。<code>A</code>和<code>B</code>同时给<code>C</code>投票，所以<code>PR(C)=0.2+0.2=0.4</code>。如此，不断地迭代，最后每个节点的值会趋于稳定（或者说收敛），这样就求得了所有节点的PR值。事实上，在这个例子中，PageRank已收俭。</p><p>每个页面将其当前的PageRank值平均分配到本页面所有出链上，一个页面将所有入链的PR值累加起来就构成了该页面新的PR值。如此迭代下去，最后得到一个稳定值。用数学公式表达，如下：</p><p>$$PR(A)=\frac{PR(B)}{L(B)}+\frac{PR(C)}{L(C)}+\frac{PR(D)}{L(D)}+⋯$$</p><p>更一般化地（$$B(p_i)$$表示所有链向网页$$p_i$$的集合），</p><p>$$PR(pi)=\sum_{p_j\in B(p_i)}\frac{PR(p_j)}{L(p_j)}$$</p><p>但这样算存在两个问题：</p><ul><li>对于没有forward links (outedges)的网页，即只有别人给她投票，她从不给别人投票，那么她的PageRank每次迭代都会增加。</li><li>对于没有blacklinks (inedges)的网页，即没人给她投票，其PageRank永远等于0。</li></ul><p>对于第一个问题，给等式乘以一个小于1的常数d（damping factor，翻译成阻尼因数？）；对于第二个问题，给等式加上一个常数。新的等式如下（N表示网页总数，或者节点数目）：</p><p>$$PR(p<em>i)=\frac{1−d}{N}+d\sum</em>{p_j\in B(p_i)}\frac{PR(p_j)}{L(p_j)}$$</p><p>其中，</p><ul><li>$$B(p_i)$$：链接到网页pipi的集合（a set of pages link to pipi）</li><li>$$L(p_j)$$：从$$p_j$$链出去的网页数目（the number of outbound links）<br>这样，就确保所有节点的PR值加起来等于1。</li></ul><h2 id="一个简单实例"><a href="#一个简单实例" class="headerlink" title="一个简单实例"></a>一个简单实例</h2><p>以一个很简单的例子（<code>A &lt; --&gt; B</code>）来看PageRank是怎么收俭的。</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-5/2.png" width="700"><br><br><br><div class="image-caption">Fig. 2: An illustration of PageRank calculation.</div><br></div><p>假设他们的初始PR值为1，第一次迭代后，PR(A)和PR(B)的值为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PR(A) = <span class="number">0.15</span>/<span class="number">2</span> + <span class="number">0.85</span>*<span class="number">1.0</span>                   = <span class="number">0.9249999999999999</span></span><br><span class="line">PR(B) = <span class="number">0.15</span>/<span class="number">2</span> + <span class="number">0.85</span>*<span class="number">0.9249999999999999</span>    = <span class="number">0.8612499999999998</span></span><br></pre></td></tr></table></figure></p><p>写个简单的Python脚本，得到每次迭代后的值，部分如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: A=<span class="number">0.925000</span>     B=<span class="number">0.861250</span> </span><br><span class="line"> <span class="number">2</span>: A=<span class="number">0.807062</span>     B=<span class="number">0.761003</span> </span><br><span class="line"> <span class="number">3</span>: A=<span class="number">0.721853</span>     B=<span class="number">0.688575</span> </span><br><span class="line"> <span class="number">4</span>: A=<span class="number">0.660289</span>     B=<span class="number">0.636245</span> </span><br><span class="line"> <span class="number">5</span>: A=<span class="number">0.615808</span>     B=<span class="number">0.598437</span> </span><br><span class="line"> <span class="number">6</span>: A=<span class="number">0.583672</span>     B=<span class="number">0.571121</span> </span><br><span class="line"> <span class="number">7</span>: A=<span class="number">0.560453</span>     B=<span class="number">0.551385</span> </span><br><span class="line"> <span class="number">8</span>: A=<span class="number">0.543677</span>     B=<span class="number">0.537126</span> </span><br><span class="line"> <span class="number">9</span>: A=<span class="number">0.531557</span>     B=<span class="number">0.526823</span> </span><br><span class="line"><span class="number">10</span>: A=<span class="number">0.522800</span>     B=<span class="number">0.519380</span> </span><br><span class="line"><span class="number">11</span>: A=<span class="number">0.516473</span>     B=<span class="number">0.514002</span> </span><br><span class="line"><span class="number">12</span>: A=<span class="number">0.511902</span>     B=<span class="number">0.510116</span> </span><br><span class="line"><span class="number">13</span>: A=<span class="number">0.508599</span>     B=<span class="number">0.507309</span></span><br><span class="line"><span class="number">14</span>: A=<span class="number">0.506213</span>     B=<span class="number">0.505281</span> </span><br><span class="line"><span class="number">15</span>: A=<span class="number">0.504489</span>     B=<span class="number">0.503815</span> </span><br><span class="line"><span class="number">16</span>: A=<span class="number">0.503243</span>     B=<span class="number">0.502757</span> </span><br><span class="line"><span class="number">17</span>: A=<span class="number">0.502343</span>     B=<span class="number">0.501992</span> </span><br><span class="line"><span class="number">18</span>: A=<span class="number">0.501693</span>     B=<span class="number">0.501439</span> </span><br><span class="line"><span class="number">19</span>: A=<span class="number">0.501223</span>     B=<span class="number">0.501040</span> </span><br><span class="line"><span class="number">20</span>: A=<span class="number">0.500884</span>     B=<span class="number">0.500751</span></span><br><span class="line">...</span><br><span class="line"><span class="number">42</span>: A=<span class="number">0.500001</span>     B=<span class="number">0.500001</span> </span><br><span class="line"><span class="number">43</span>: A=<span class="number">0.500001</span>     B=<span class="number">0.500000</span> </span><br><span class="line"><span class="number">44</span>: A=<span class="number">0.500000</span>     B=<span class="number">0.500000</span> </span><br><span class="line"><span class="number">45</span>: A=<span class="number">0.500000</span>     B=<span class="number">0.500000</span></span><br></pre></td></tr></table></figure></p><p>可见，随着迭代次数的增加，PageRank越来越接近收俭值0.5。Python源代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pagerank_ab</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Calculate PageRank for A &lt;--&gt; B</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pr = &#123;<span class="string">'A'</span>:<span class="number">1.0</span>, <span class="string">'B'</span>:<span class="number">1.0</span>&#125;</span><br><span class="line">    max_iter = <span class="number">50</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">1</span>, max_iter+<span class="number">1</span>):</span><br><span class="line">        pr[<span class="string">'A'</span>] = <span class="number">0.15</span>/<span class="number">2</span> + <span class="number">0.85</span>*pr[<span class="string">'B'</span>]</span><br><span class="line">        pr[<span class="string">'B'</span>] = <span class="number">0.15</span>/<span class="number">2</span> + <span class="number">0.85</span>*pr[<span class="string">'A'</span>]</span><br><span class="line"> </span><br><span class="line">        s = <span class="string">'&#123;:3d&#125;: A=&#123;:&lt;10f&#125;\tB=&#123;:&lt;10f&#125;'</span>.format(idx, pr[<span class="string">'A'</span>], pr[<span class="string">'B'</span>])</span><br><span class="line">        print(s)</span><br></pre></td></tr></table></figure></p><h2 id="迭代次数"><a href="#迭代次数" class="headerlink" title="迭代次数"></a>迭代次数</h2><p>迭代次数越多，结果越准确，但花费时间也越长。出于效率考虑，在实际应用中，当PR值落在误差允许范围内（PR值跟前一次比较，如<code>PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6</code>，想想浮点数在计算机的存储），就可以返回结果了。<br>Python实现的nx.pagerank相关源代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check convergence, l1 norm</span></span><br><span class="line">err = sum([abs(x[n] - xlast[n]) <span class="keyword">for</span> n <span class="keyword">in</span> x])</span><br><span class="line"><span class="keyword">if</span> err &lt; N*tol: <span class="comment"># tol=1.0e-6</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p><p>当然，对于超大型网络来说，有更复杂的计算方法，比如分布式。</p><h2 id="PR初始值"><a href="#PR初始值" class="headerlink" title="PR初始值"></a>PR初始值</h2><p>不管节点PR初始值怎么设置，最后节点的PR值都一样，但收俭速度不一样。可以修改上面Python代码的PR初始值，运行代码，自行感受下。NetworkX的pagerank实现是将PR值初始化为1/N。</p><h2 id="Damping-factor"><a href="#Damping-factor" class="headerlink" title="Damping factor"></a>Damping factor</h2><p>跟PR初始值类似，d的取值也会影响算法效率。根据Page的论文，d通常设为0.85。</p><h1 id="PageRank计算方法"><a href="#PageRank计算方法" class="headerlink" title="PageRank计算方法"></a>PageRank计算方法</h1><p>(1) 迭代方法</p><p>详情见另一篇博文<a href="https://linxueyuanstdio.github.io/2017/12/网页排序算法-二-迭代方法求PageRank/" target="_blank" rel="noopener">《网页排序算法（二）迭代方法求PageRank》</a>。</p><p>（2）代数方法</p><p>详情见另一篇博文<a href="https://linxueyuanstdio.github.io/2017/12/网页排序算法-三-代数方法求PageRank" target="_blank" rel="noopener">《网页排序算法（三）代数方法求PageRank》</a>。</p><p>（3）Power Method</p><p>待续。</p><h1 id="用NetworkX求PageRank"><a href="#用NetworkX求PageRank" class="headerlink" title="用NetworkX求PageRank"></a>用NetworkX求PageRank</h1><p>NetworkX提供3个求PageRank的API，如下：</p><ul><li>pagerank(…)</li><li>pagerank_numpy(…)</li><li>pagerank_scipy(…)</li></ul><p>详细API如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pagerank(G, alpha=<span class="number">0.85</span>, personalization=<span class="keyword">None</span>, max_iter=<span class="number">100</span>, tol=<span class="number">1e-06</span>, nstart=<span class="keyword">None</span>, weight=<span class="string">'weight'</span>, dangling=<span class="keyword">None</span>)</span><br><span class="line"> </span><br><span class="line">pagerank_numpy(G, alpha=<span class="number">0.85</span>, personalization=<span class="keyword">None</span>, weight=<span class="string">'weight'</span>, dangling=<span class="keyword">None</span>)</span><br><span class="line"> </span><br><span class="line">pagerank_scipy(G, alpha=<span class="number">0.85</span>, personalization=<span class="keyword">None</span>, max_iter=<span class="number">100</span>, tol=<span class="number">1e-06</span>, weight=<span class="string">'weight'</span>, dangling=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>References:</p><ul><li>[1] <a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf" target="_blank" rel="noopener">Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF]</a></li><li>[2] <a href="http://www.sci.unich.it/~francesc/teaching/network/pagerank" target="_blank" rel="noopener">PageRank Centrality by Massimo Franceschet</a></li><li>[3] <a href="http://www.changhai.org/articles/technology/misc/google_math.php" target="_blank" rel="noopener">谷歌背后的数学 by 卢昌海</a></li><li>[4] <a href="https://en.wikipedia.org/wiki/PageRank" target="_blank" rel="noopener">Wikipedia: PageRank</a></li><li>[5] <a href="http://www.cs.princeton.edu/~chazelle/courses/BIB/pagerank.htm" target="_blank" rel="noopener">The Google Pagerank Algorithm and How It Works</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参加数学建模的时候要研究一下PageRank，为了巩固3天从入门到精通的成果，把了解到的整理成文。&lt;/p&gt;
&lt;h1 id=&quot;直观理解&quot;&gt;&lt;a href=&quot;#直观理解&quot; class=&quot;headerlink&quot; title=&quot;直观理解&quot;&gt;&lt;/a&gt;直观理解&lt;/h1&gt;&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="PageRank" scheme="http://xichen.pub/tags/PageRank/"/>
    
  </entry>
  
  <entry>
    <title>迪菲-赫尔曼密钥交换</title>
    <link href="http://xichen.pub/2017/12/01/2017-12-01-%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/"/>
    <id>http://xichen.pub/2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/</id>
    <published>2017-12-01T13:52:00.000Z</published>
    <updated>2018-01-05T00:45:28.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迪菲-赫尔曼密钥交换（英语：Diffie–Hellman-key-exchange，缩写为D-H）"><a href="#迪菲-赫尔曼密钥交换（英语：Diffie–Hellman-key-exchange，缩写为D-H）" class="headerlink" title="迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为D-H）"></a>迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为D-H）</h1><p>最简单，最早提出的这个协议使用一个质数$p$的整数模$n$乘法群以及其原根$g$。</p><div class="image-package"><br><img src="/assets/blog/img/2017-12-1/0.svg" width="700"><br><br><div class="image-caption">迪菲-赫尔曼密钥交换</div><br></div><p>算法如下（绿色表示非秘密信息, 红色粗体表示秘密信息）：</p><ul><li>爱丽丝与鲍伯协定使用 $$p=23$$以及base $$g=5$$.</li><li>爱丽丝选择一个秘密整数$$a=6$$, 计算$$A = g^a mod p$$并发送给鲍伯。</li></ul><p>$$A = 56 mod 23 = 8$$.</p><ul><li>鲍伯选择一个秘密整数$$b=15$$, 计算$$B = g^b mod p$$并发送给爱丽丝。</li></ul><p>$$B = 515 mod 23 = 19$$.</p><ul><li>爱丽丝计算$$s = B^a mod p$$</li></ul><p>$$196 mod 23 = 2$$.</p><ul><li>鲍伯计算$$s = A^b mod p$$</li></ul><p>$$815 mod 23 = 2$$.</p><p>以下是一个更为一般的描述:</p><ul><li>爱丽丝和鲍伯写上一个有限循环群 $$G$$ 和它的一个生成元 $$g$$。 （这通常在协议开始很久以前就已经规定好； $$g$$是公开的，并可以被所有的攻击者看到。）</li><li>爱丽丝选择一个随机自然数 $$a$$ 并且将$${\displaystyle g^{a}{\bmod {p}}} g^{a} \bmod{p}$$发送给鲍伯。</li><li>鲍伯选择一个随机自然数 $$b$$ 并且将$${\displaystyle g^{b}{\bmod {p}}} g^{b} \bmod{p}$$发送给爱丽丝。</li><li>爱丽丝 计算 $${\displaystyle \left(g^{b}\right)^{a}{\bmod {p}}} \left ( g^{b} \right )^{a} \bmod{p} $$。</li><li>鲍伯 计算 $${\displaystyle \left(g^{a}\right)^{b}{\bmod {p}}} \left ( g^{a} \right )^{b} \bmod{p} $$。</li></ul><p>爱丽丝和鲍伯就同时协商出群元素$$ {\displaystyle g^{ab}} g^{ab} $$，它可以被用作共享秘密。<br>$${\displaystyle \left(g^{b}\right)^{a}} \left ( g^{b} \right )^{a} = {\displaystyle \left(g^{a}\right)^{b}} \left ( g^{a} \right )^{b}$$因为群是乘法交换的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迪菲-赫尔曼密钥交换（英语：Diffie–Hellman-key-exchange，缩写为D-H）&quot;&gt;&lt;a href=&quot;#迪菲-赫尔曼密钥交换（英语：Diffie–Hellman-key-exchange，缩写为D-H）&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="密码学" scheme="http://xichen.pub/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>区块链开发（一）搭建环境-基于以太坊私有链</title>
    <link href="http://xichen.pub/2017/11/30/2017-11-30-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83-%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    <id>http://xichen.pub/2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/</id>
    <published>2017-11-30T13:52:00.000Z</published>
    <updated>2018-01-05T00:45:28.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Geth和Mist"><a href="#安装Geth和Mist" class="headerlink" title="安装Geth和Mist"></a>安装Geth和Mist</h1><h2 id="Ubuntu下安装Geth客户端"><a href="#Ubuntu下安装Geth客户端" class="headerlink" title="Ubuntu下安装Geth客户端"></a>Ubuntu下安装Geth客户端</h2><p>之所以采用Ubuntu，是因为以太坊的官方对Ubuntu支持的很好，是在各个linux系统中安装最简单。</p><blockquote><p>Geth官方安装指南：<br><a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum</a></p></blockquote><p>进入ubuntu命令行，执行如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get installsoftware-properties-common</span><br><span class="line">$ sudo add-apt-repository -yppa:ethereum/ethereum</span><br><span class="line">$ sudo add-apt-repository -yppa:ethereum/ethereum-dev</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install ethereum</span><br></pre></td></tr></table></figure></p><p>系统联网执行后，即完成了安装以太坊客户端，其中包括<code>geth</code>,<code>bootnode</code>,<code>evm</code>,<code>disasm</code>,<code>rlpdump</code>,<code>ethtest</code><br>此时如果输入 <code>geth</code> 命令，会出现启动以太坊启动的画面</p><p>也可以源码编译安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ethereum/go-ethereum</span><br><span class="line">$ sudo apt-get install -y build-essential golang</span><br><span class="line">$ <span class="built_in">cd</span> go-ethereum</span><br><span class="line">$ make geth</span><br></pre></td></tr></table></figure></p><h2 id="Windows下安装Geth客户端"><a href="#Windows下安装Geth客户端" class="headerlink" title="Windows下安装Geth客户端"></a>Windows下安装Geth客户端</h2><p>下载并安装 Geth for Windows.<br>Windows必须64位系统，从官方网站下载编译好的win64客户端，解压缩即可运行，下载地址如下（第二个地址备选）：</p><blockquote><p><a href="https://github.com/ethereum/go-ethereum/releases/" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/releases/</a><br><a href="https://geth.ethereum.org/downloads/" target="_blank" rel="noopener">https://geth.ethereum.org/downloads/</a></p></blockquote><p>下载后，只有一个<code>Geth.exe</code>的文件。</p><h2 id="MAC-OSX下安装Geth客户端"><a href="#MAC-OSX下安装Geth客户端" class="headerlink" title="MAC OSX下安装Geth客户端"></a>MAC OSX下安装Geth客户端</h2><p>首先确保已安装<code>homebrew</code>，没有安装过的可以在命令行下执行<br><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>进行安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew tap ethereum/ethereum</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install ethereum</span></span><br></pre></td></tr></table></figure></p><h2 id="安装图像化客户端Mist"><a href="#安装图像化客户端Mist" class="headerlink" title="安装图像化客户端Mist"></a>安装图像化客户端Mist</h2><p>依然是从官方地址下载编译好的客户端即可，下载地址：</p><blockquote><p><a href="https://github.com/ethereum/mist/releases/" target="_blank" rel="noopener">https://github.com/ethereum/mist/releases/</a></p></blockquote><p>下载解压缩后，Ethereum-Wallet 即为以太坊图形化界面。</p><h1 id="准备创世块文件"><a href="#准备创世块文件" class="headerlink" title="准备创世块文件"></a>准备创世块文件</h1><p>配置自己的创世块是为了区分公有链，同一个网络中，创世块必须是一样的，否则无法联通，此方法在windows和Ubuntu下通用。<br>新建文件<code>piccgenesis.json</code>,输入如下内容并保存<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"chainId"</span>: <span class="number">123456</span>,</span><br><span class="line">    <span class="attr">"homesteadBlock"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"eip155Block"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"eip158Block"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"nonce"</span>: <span class="string">"0x0000000000000042"</span>,</span><br><span class="line">  <span class="attr">"difficulty"</span>: <span class="string">"0x020000"</span>,</span><br><span class="line">  <span class="attr">"mixhash"</span>: <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"coinbase"</span>: <span class="string">"0x0000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"timestamp"</span>: <span class="string">"0x00"</span>,</span><br><span class="line">  <span class="attr">"parentHash"</span>: <span class="string">"0x0000000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line">  <span class="attr">"extraData"</span>: <span class="string">"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"</span>,</span><br><span class="line">  <span class="attr">"gasLimit"</span>: <span class="string">"0x4c4b40"</span>,</span><br><span class="line">  <span class="attr">"alloc"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释一下各个参数的作用：</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>mixhash</td><td>与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。.</td></tr><tr><td>nonce</td><td>nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。</td></tr><tr><td>difficulty</td><td>设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度</td></tr><tr><td>alloc</td><td>用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。</td></tr><tr><td>coinbase</td><td>矿工的账号，随便填</td></tr><tr><td>timestamp</td><td>设置创世块的时间戳</td></tr><tr><td>parentHash</td><td>上一个区块的hash值，因为是创世块，所以这个值是0</td></tr><tr><td>extraData</td><td>附加信息，随便填，可以填你的个性信息</td></tr><tr><td>gasLimit</td><td>该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。</td></tr></tbody></table><h1 id="启动私有链节点"><a href="#启动私有链节点" class="headerlink" title="启动私有链节点"></a>启动私有链节点</h1><p>启动Geth即可以启动以太坊的区块链，为了构建私有链 ，需要在Geth启动时加入一些参数，Geth参数含义如下： </p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>identity</td><td>区块链的标示，随便填写，用于标示目前网络的名字</td></tr><tr><td>init</td><td>指定创世块文件的位置，并创建初始块</td></tr><tr><td>datadir</td><td>设置当前区块链网络数据存放的位置</td></tr><tr><td>port</td><td>网络监听端口</td></tr><tr><td>rpc</td><td>启动rpc通信，可以进行智能合约的部署和调试</td></tr><tr><td>rpcapi</td><td>设置允许连接的rpc的客户端，一般为db,eth,net,web3</td></tr><tr><td>networkid</td><td>设置当前区块链的网络ID，用于区分不同的网络，是一个数字</td></tr><tr><td>console</td><td>启动命令行模式，可以在Geth中执行命令</td></tr></tbody></table><h2 id="在Ubuntu启动区块链节点"><a href="#在Ubuntu启动区块链节点" class="headerlink" title="在Ubuntu启动区块链节点"></a>在Ubuntu启动区块链节点</h2><p>在Ubuntu下，首先切换到打算运行的目录，目录下应该有配置好的<code>piccgenesis.json</code>文件，获取当前的目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ basepath=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`; <span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure></p><p>创建数据存放地址并初始化创世块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth  --datadir <span class="string">"<span class="variable">$basepath</span>/chain"</span> init piccgenesis.json</span><br></pre></td></tr></table></figure></p><p>启动节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth --identity <span class="string">"PICCetherum"</span>  --rpc  --rpccorsdomain <span class="string">"*"</span> --datadir <span class="string">"<span class="variable">$basepath</span>/chain"</span> --port <span class="string">"30303"</span>  --rpcapi <span class="string">"db,eth,net,web3"</span> --networkid 95518 console</span><br></pre></td></tr></table></figure></p><p>启动后界面如下，光标停留在最后的命令行上，可以执行以太坊命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">I0707 00:45:43.680087 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindata</span><br><span class="line">I0707 00:45:43.726008ethdb/database.go:169] closed db:/home/lihe/桌面/chain/chaindata</span><br><span class="line">I0707 00:45:43.728913 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindata</span><br><span class="line">I0707 00:45:43.908795 ethdb/database.go:82]Alloted 16MB cache and 16 file handles to /home/lihe/桌面/chain/dapp</span><br><span class="line">I0707 00:45:43.969506 core/genesis.go:92]Genesis block already <span class="keyword">in</span> chain. Writing canonical number</span><br><span class="line">I0707 00:45:43.980337 eth/backend.go:274]Successfully wrote custom genesis block:6e92f8b23bcdfdf34dc813cfaf1d84b71beac80530506b5d63a2df10fe23a660</span><br><span class="line">I0707 00:45:43.980618 eth/backend.go:184]Protocol Versions: [63 62], Network Id: 95518</span><br><span class="line">I0707 00:45:43.981567core/blockchain.go:204] Last header: <span class="comment">#81 [6193c4b0…] TD=10836704</span></span><br><span class="line">I0707 00:45:43.981645core/blockchain.go:205] Last block: <span class="comment">#81 [6193c4b0…] TD=10836704</span></span><br><span class="line">I0707 00:45:43.981677core/blockchain.go:206] Fast block: <span class="comment">#81 [6193c4b0…] TD=10836704</span></span><br><span class="line">I0707 00:45:43.985253 p2p/server.go:313]Starting Server</span><br><span class="line">I0707 00:45:45.834488p2p/discover/udp.go:217] Listening,enode://134881790e54c803955715e3661c27f91caaf499be813e29c9f986e2eac62d47e02b13a8e51776c1caea554655614ed26ce0185d84e626da7ac48a83a60113ff@[::]:30303</span><br><span class="line">I0707 00:45:45.835853 node/node.go:366]HTTP endpoint opened: http://localhost:8545</span><br><span class="line">I0707 00:45:45.848008 p2p/server.go:556]Listening on [::]:30303</span><br><span class="line">I0707 00:45:45.849731 node/node.go:296] IPCendpoint opened: /home/lihe/桌面/chain/geth.ipc</span><br><span class="line">Welcome to the Geth JavaScript console!</span><br><span class="line"> </span><br><span class="line">instance:Geth/v1.5.0-unstable/linux/go1.5.1/PICCetherum</span><br><span class="line">coinbase:0x93509a2f4b2b974b07ef0b52e07c3992601f5de1</span><br><span class="line">at block: 81 (Tue, 05 Jul 2016 21:02:25CST)</span><br><span class="line"> datadir: /home/lihe/桌面/chain</span><br><span class="line"> modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到<code>Listening on [::]:30303</code>和<code>Welcome to the Geth JavaScript console!</code>的提示，说明已经启动成功</p><blockquote><p><strong>注意</strong>：如果想将Ubuntu作为永久区块链节点使用，当使用nohup命令时，Geth启动参数console必须去掉，否则Geth会自动停止。</p></blockquote><h2 id="在windows启动区块链节点"><a href="#在windows启动区块链节点" class="headerlink" title="在windows启动区块链节点"></a>在windows启动区块链节点</h2><p>进入Windows下<code>Geth</code>的目录 ，放置配置好的<code>piccgenesis.json</code>文件，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth  --datadir <span class="string">"%cd%\chain"</span> init piccgenesis.json</span><br></pre></td></tr></table></figure></p><p>创建数据存放地址并初始化创世块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ geth--identity <span class="string">"PICCetherum"</span> --rpc--rpccorsdomain <span class="string">"*"</span> --datadir <span class="string">"%cd%\chain"</span> --port<span class="string">"30303"</span>  --rpcapi<span class="string">"db,eth,net,web3"</span> --networkid 95518 console</span><br></pre></td></tr></table></figure></p><p>当看到<code>Listening on [::]:30303</code>和<code>Welcome to the Geth JavaScript console!</code>的提示，说明已经启动成功</p><h1 id="使用节点创建账号"><a href="#使用节点创建账号" class="headerlink" title="使用节点创建账号"></a>使用节点创建账号</h1><p>启动节点成功后，会进入Geth的命令行模式，输入如下命令<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.<span class="keyword">new</span><span class="type">Account</span>()</span><br></pre></td></tr></table></figure></p><p>系统会提示你输入账号密码，并确认，最后会显示一个新生成的账号。</p><h2 id="Geth-JavaScript控制台环境使用说明"><a href="#Geth-JavaScript控制台环境使用说明" class="headerlink" title="Geth JavaScript控制台环境使用说明"></a>Geth JavaScript控制台环境使用说明</h2><ul><li>创建新账号<br><code>personal.newAccount()</code><br>或者 <code>personal.newAccount(&quot;123456&quot;)</code></li><li>查看节点信息<br><code>admin.nodeInfo</code></li><li>挖矿<ul><li>开始挖矿<code>miner.start(1)</code></li><li>停止挖矿<code>miner.stop()</code></li></ul></li><li>查看当前矿工账号<br><code>eth.coinbase</code> 默认为第一个账户</li><li>修改矿工账号<br><code>miner.setEtherbase(eth.accounts[1])</code></li><li>查看账户信息<br><code>eth.accounts[0]</code></li><li>查看账户余额<br><code>eth.getBalance(eth.accounts[0])</code><br>或者 <code>web3.fromWei(eth.getBalance(eth.accounts[0]), &quot;ether&quot;)</code></li><li>解锁账号<br><code>personal.unlockAccount(eth.accounts[0])</code><br>使用账户资金前都需要先解锁账号</li><li>转账<code>eth.sendTransaction({from:eth.accounts[0],to:&quot;0x587e57a516730381958f86703b1f8e970ff445d9&quot;,value:web3.toWei(3,&quot;ether&quot;)})</code><br>使用 <code>txpool.status</code>可以看到交易状态</li><li>查看区块数据<ul><li><code>eth.blockNumber</code></li><li><code>eth.getTransaction(&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;)</code></li><li><code>eth.getBlock(1)</code> 通过区块号查看区块</li></ul></li></ul><h1 id="私有链图形节点"><a href="#私有链图形节点" class="headerlink" title="私有链图形节点"></a>私有链图形节点</h1><h2 id="启动Ubuntu下私有链图形节点"><a href="#启动Ubuntu下私有链图形节点" class="headerlink" title="启动Ubuntu下私有链图形节点"></a>启动Ubuntu下私有链图形节点</h2><p>首先按上面的步骤启动Geth并创建了账号，在geth运行的时候，再运行下面的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethereumwallet --gethpath /usr/bin/geth</span><br></pre></td></tr></table></figure></p><p><code>--gethpath</code>改成你实际安装的geth的路径</p><h2 id="启动Windows下私有链图形节点"><a href="#启动Windows下私有链图形节点" class="headerlink" title="启动Windows下私有链图形节点"></a>启动Windows下私有链图形节点</h2><p>首先按上面的步骤启动Geth并创建了账号，然后解压缩Ethereum-Wallet，运行<code>Ethereum-Wallet.exe</code>,即启动成功，如果区块链正常的话，会在右上角显示<code>“PRIVATE-NET”</code>，点击<code>“LAUNCH APPLICATION”</code>进入图形界面即可。</p><h1 id="连接其他节点"><a href="#连接其他节点" class="headerlink" title="连接其他节点"></a>连接其他节点</h1><p>首先要知道自己的节点信息，在Geth命令行界面下输入命令,注意大小写<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">admin</span><span class="selector-class">.nodeInfo</span></span><br></pre></td></tr></table></figure></p><p>系统会显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enode:<span class="string">"enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303“</span></span><br></pre></td></tr></table></figure></p><p>其中<code>enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303</code><br>就是自己节点的信息，注意要把<code>0.0.0.0</code>换成你自己的IP。将这个信息发送给其他节点，在其他节点的命令行中输入：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.addPeer(‘enode://<span class="number">1e3</span><span class="keyword">c</span><span class="number">1727</span>cd<span class="number">3</span>bee<span class="number">9</span>f<span class="number">25</span>edeb<span class="number">5</span>dbb<span class="number">3</span>b<span class="number">880e03</span>e<span class="number">41</span>f<span class="number">8</span>eec<span class="number">99566557</span>f<span class="number">3</span>ee<span class="number">0422734</span>a<span class="number">8</span>fcad<span class="number">17</span><span class="keyword">c</span><span class="number">161</span>aa<span class="number">93</span>d<span class="number">61</span>bdbfb<span class="number">28</span>ed<span class="number">152</span><span class="keyword">c</span><span class="number">143</span><span class="keyword">c</span><span class="number">7</span>eb<span class="number">501</span>db<span class="number">58</span>bc<span class="number">63502</span>a<span class="number">104</span>a<span class="number">84</span>b<span class="number">62</span>d<span class="number">742</span><span class="title">@192</span>.<span class="number">168.1</span>.<span class="number">101</span>:<span class="number">30303</span>’)</span><br></pre></td></tr></table></figure></p><p>如果添加成功，输入<code>admin.peers</code>会显示出新添加的节点。</p><h1 id="使用节点进行挖矿"><a href="#使用节点进行挖矿" class="headerlink" title="使用节点进行挖矿"></a>使用节点进行挖矿</h1><p>在Geth命令行界面下，输入<code>miner.start()</code>即启动挖矿，挖矿后，会不停刷屏，输入<code>miner.stop()</code>即停止，不用管刷屏导致的命令不全，命令会正常执行。<br>到这一步，已经组建一个私有链的网络，可以像其他区块链一样不停的扩充这个网络，下一篇文章，我会介绍如何在私有链上编写、调试和部署智能合约。</p><p>参考文章：</p><ol><li><a href="http://blog.csdn.net/sportshark/article/details/51855007" target="_blank" rel="noopener">http://blog.csdn.net/sportshark/article/details/51855007</a></li><li><a href="http://tech.lab.carl.pro/kb/ethereum/testnet_setup" target="_blank" rel="noopener">http://tech.lab.carl.pro/kb/ethereum/testnet_setup</a></li><li><a href="http://www.ethdocs.org/en/latest/network/test-networks.html#setting-up-a-local-private-testnet" target="_blank" rel="noopener">http://www.ethdocs.org/en/latest/network/test-networks.html#setting-up-a-local-private-testnet</a></li><li><a href="https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network</a></li><li><a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console</a></li><li><a href="https://github.com/ethereum/go-ethereum/wiki/Mining" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/Mining</a></li><li><a href="https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts</a></li><li><a href="https://github.com/janx/ethereum-bootstrap" target="_blank" rel="noopener">https://github.com/janx/ethereum-bootstrap</a></li><li><a href="https://forum.qtum.org/topic/127/以太坊私链与智能合约部署入门教程/2" target="_blank" rel="noopener">https://forum.qtum.org/topic/127/以太坊私链与智能合约部署入门教程/2</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装Geth和Mist&quot;&gt;&lt;a href=&quot;#安装Geth和Mist&quot; class=&quot;headerlink&quot; title=&quot;安装Geth和Mist&quot;&gt;&lt;/a&gt;安装Geth和Mist&lt;/h1&gt;&lt;h2 id=&quot;Ubuntu下安装Geth客户端&quot;&gt;&lt;a href=&quot;#U
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://xichen.pub/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu--apt-get update（由于没有公钥，无法验证下列签名）</title>
    <link href="http://xichen.pub/2017/11/29/2017-11-29-apt-get-update-GPG%E9%94%99%E8%AF%AF/"/>
    <id>http://xichen.pub/2017/11/29/2017-11-29-apt-get-update-GPG错误/</id>
    <published>2017-11-29T13:52:00.000Z</published>
    <updated>2018-01-05T00:45:28.288Z</updated>
    
    <content type="html"><![CDATA[<p>当 <code>apt-get update</code> 更新后，出现下面错误时的解决方法：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...bash</span><br><span class="line">正在读取软件包列表… 完成 </span><br><span class="line"><span class="string">W:</span> GPG 错误：<span class="string">http:</span><span class="comment">//ppa.launchpad.net trusty InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 2EA8F35793D8809A</span></span><br></pre></td></tr></table></figure></p><p>解决办法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executing: gpg –ignore-time-conflict –no-options –no-default-keyring –secret-keyring /tmp/tmp.uxUmi4wF1r –trustdb-name /etc/apt/trustdb.gpg –keyring /etc/apt/trusted.gpg –primary-keyring /etc/apt/trusted.gpg –keyserver keyserver.ubuntu.com –recv-keys 2EA8F35793D8809A </span><br><span class="line">gpg: 下载密钥‘93D8809A’，从 hkp 服务器 keyserver.ubuntu.com </span><br><span class="line">gpg: 密钥 93D8809A：公钥“Launchpad PPA <span class="keyword">for</span> Martin Wimpress”已导入 </span><br><span class="line">gpg: 合计被处理的数量：1 </span><br><span class="line">gpg: 已导入：1 (RSA: 1)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当 &lt;code&gt;apt-get update&lt;/code&gt; 更新后，出现下面错误时的解决方法：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://xichen.pub/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Go 爬虫总结</title>
    <link href="http://xichen.pub/2017/11/27/2017-11-27-go%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://xichen.pub/2017/11/27/2017-11-27-go爬虫总结/</id>
    <published>2017-11-27T13:52:00.000Z</published>
    <updated>2018-01-05T00:45:28.287Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫目的：爬导航和爬商品</p><p>爬虫架构：</p><ul><li>electron虚拟浏览器</li><li>proxy代理ip</li><li>dashboard网页端调控</li><li>爬虫APP</li></ul><p>实现的功能：</p><ul><li>url拼接，过滤出商品</li><li>url翻页，点击翻页，无限流，loadmore按钮</li><li>过滤文本中包含某text的url，过滤url中包含某url的url，定点过滤特定的url，只爬文本中包含某text的url，只爬url中包含某url的url</li><li>失败移至末尾重试（次数，本次返回的状态码，延时）</li><li>控制爬取频率，控制递归爬取深度</li><li>用electron防止cookie或ajax动态加载页面，有WaitSelector，直到WaitSelector出现才返回渲染后的页面给spider，否则返回错误码</li><li>分布式，高并发</li><li>多个proxy负载均衡</li><li>proxy权限控制</li><li>dashboard网页端爬虫调度，导航log和简单报表分析，商品log和简单报表分析，服务器上当前所有配置一览</li></ul><p>我负责的模块：</p><ul><li>配置文件template</li><li>测试被反爬虫的条件，计算最大爬取频率</li><li>实现同时爬取多个网站，单线程和并发可选</li><li>默认 http client 不会缓存 DNS 记录，而爬虫会有大量的请求，所以自己专门对 DNS 做缓存</li><li>调查并分析站点请求不成功的url占比超过 20% 的原因并修复</li><li>发现并解决 ssl 证书问题</li><li>网站改版，及时更新配置文件</li><li>给timeout设一个下界</li></ul><p>返回408原因：<br>（1）商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408<br>（2）翻页超过最大页数，没有商品，返回408。这个原因导致的408一般 <code>成堆</code> 出现<br>（3）无限流需要较长时间来翻页，timeout较小会408<br>（4）目标网站有的商品下架，没有商品，返回408<br>（5）目标网站反爬策略，封ip后也不返回500，只有提示性的html，等不到商品，返回408<br>（6）目标网站必须用https</p><p>解决方案：（这几个印象深刻，其他的想不起来了）</p><ul><li><p>商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408</p><ul><li>有2个waitSelector，一个Selector做监督，一个选商品Selector，如果监督Selector出现了而商品Selector没出来，就判定没商品<ul><li>效果好</li><li>时间成本高</li></ul></li><li>只要1个errorSelector，出现提示性的error，判定为没有商品<ul><li>实现简单，时间成本低，逻辑清晰</li><li>不全面，有些站点如果没有商品，也不出现提示性文字</li></ul></li><li>electron不处理，无论是否408都把页面返回，交给spider处理<ul><li>electron端实现简单，效果好，易于扩展</li><li>spider端实现困难，给spider端挖坑，有隐患</li></ul></li></ul></li><li><p>ssl 证书问题</p><ul><li>请求时不检测证书</li></ul></li><li><p>http 请求</p><ul><li>换成https请求</li></ul></li><li><p>getsockopt: no route to host</p><ul><li>和firewall有关，我们对昂贵的proxy做权限控制，而我在本地没有这个proxy的权限，必须到服务器上搞</li></ul></li><li><p>getsockopt: connection time out</p><ul><li>需要特殊的header，不然在命令行是不能成功请求的</li></ul></li><li><p>DNS解析</p><ul><li>原来的每次都要new一个，修复后只要一个持久化</li></ul></li></ul><p>团队共享用到的软件（我们都是远程办公）</p><ul><li>slack:交流讨论</li><li>quip：共享文件</li><li>trello：任务管理</li><li>zoom：远程会议</li><li>google图表：共享文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬虫目的：爬导航和爬商品&lt;/p&gt;
&lt;p&gt;爬虫架构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;electron虚拟浏览器&lt;/li&gt;
&lt;li&gt;proxy代理ip&lt;/li&gt;
&lt;li&gt;dashboard网页端调控&lt;/li&gt;
&lt;li&gt;爬虫APP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现的功能：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Go" scheme="http://xichen.pub/tags/Go/"/>
    
      <category term="Spider" scheme="http://xichen.pub/tags/Spider/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中使用dpkg安装deb文件提示依赖关系问题，仍未被配置</title>
    <link href="http://xichen.pub/2017/10/15/2017-10-11-dpkg-error/"/>
    <id>http://xichen.pub/2017/10/15/2017-10-11-dpkg-error/</id>
    <published>2017-10-14T17:54:00.000Z</published>
    <updated>2018-01-05T00:45:28.283Z</updated>
    
    <content type="html"><![CDATA[<p>使用dpkg时，提示：dpkg：处理软件包XXX时出错：<br>依赖关系问题，仍未被配置</p><div class="image-package"><br><img src="/assets/blog/img/2017-10-15/0.png" width="700"><br><div class="image-caption">问题</div><br></div><p>出现上图时，使用如下命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure></p><div class="image-package"><br><img src="/assets/blog/img/2017-10-15/1.png" width="700"><br><div class="image-caption">解决</div><br></div><p>等分析完之后，重新使用dpkg –i XXX.deb，就可以了</p><div class="image-package"><br><img src="/assets/blog/img/2017-10-15/2.png" width="700"><br><div class="image-caption">解决</div><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用dpkg时，提示：dpkg：处理软件包XXX时出错：&lt;br&gt;依赖关系问题，仍未被配置&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;br&gt;&lt;img src=&quot;/assets/blog/img/2017-10-15/0.png&quot; width=&quot;700&quot;&gt;
      
    
    </summary>
    
      <category term="Ubuntu" scheme="http://xichen.pub/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="http://xichen.pub/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Python Tweepy 翻墙抓取Twitter信息</title>
    <link href="http://xichen.pub/2017/10/13/2017-10-11-python-proxy/"/>
    <id>http://xichen.pub/2017/10/13/2017-10-11-python-proxy/</id>
    <published>2017-10-13T02:13:00.000Z</published>
    <updated>2018-01-05T00:45:28.284Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/LinXueyuanStdio/PythonDataMining" target="_blank" rel="noopener">repo在此</a>，如果觉得做得好，给个star鼓励下吧！</p><p>在看《Python数据挖掘入门与实践》的时候，随书附带的代码已经过时几年了，现在边看书边修，很是辛苦</p><p>在学习第六章”使用朴素贝叶斯进行社交媒体挖掘”时，数据集需要通过twitter的API来获取</p><p>（玛蛋，为毛不随书附带数据集）</p><p>twitter在国内被墙了，只能翻墙</p><p>浏览器翻墙容易，弄个lantern或者shadowsockets就可以了</p><p>但是，由于ubuntu的代理不是全局代理，在命令行中翻墙要设proxy，在代码中翻墙也要设proxy</p><p>所以难处在于代码要就twitter的python接口翻墙</p><p>如果只是一个简单的加proxy网络请求，几行就可以搞定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">proxy_support = urllib.request.ProxyHandler(&#123;<span class="string">'http'</span> : <span class="string">'http://127.0.0.1:80'</span>&#125;)</span><br></pre></td></tr></table></figure><p>可是twitter的python接口是自动发起请求的呀</p><p>懒得去改源码</p><p>只好看看怎么在代码中设置好翻墙</p><h1 id="账号准备"><a href="#账号准备" class="headerlink" title="账号准备"></a>账号准备</h1><p>首先需要在twitter官方注册twitter账号，并新建一个应用，链接：<a href="https://apps.twitter.com/app/new" target="_blank" rel="noopener">新建应用</a><br>如果新建应用不成功，国内大多数情况都是无法验证手机号，可以参考这个教程，亲测有效，链接：<a href="http://jingyan.baidu.com/article/cd4c2979e84b0a756e6e60b8.html" target="_blank" rel="noopener">验证手机号</a><br>注册成功后，可以查看自己的keys and access token，如下图： </p><div class="image-package"><br><img src="/assets/blog/img/2017-10-13/0.png" width="700"><br><div class="image-caption">Consumer Key and Consumer Secret</div><br></div><div class="image-package"><br><img src="/assets/blog/img/2017-10-13/1.png" width="700"><br><div class="image-caption">Access Token and Access Token Secret</div><br></div><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>python3.5+</p><p>安装tweepy： 在命令行中输入：<code>pip install tweepy</code></p><h1 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> tweepy</span><br><span class="line"><span class="keyword">from</span> tweepy <span class="keyword">import</span> OAuthHandler</span><br><span class="line"></span><br><span class="line">consumer_key = <span class="string">'replace your own account consumer_key'</span></span><br><span class="line">consumer_secret = <span class="string">'replace your own account consumer_secret'</span></span><br><span class="line">access_token = <span class="string">'replace your own account access_token'</span></span><br><span class="line">access_secret = <span class="string">'replace your own account access_secret'</span></span><br><span class="line"></span><br><span class="line">auth = OAuthHandler(consumer_key,consumer_secret)</span><br><span class="line">auth.set_access_token(access_token,access_secret)</span><br><span class="line"></span><br><span class="line">api = tweepy.API(auth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> status <span class="keyword">in</span> tweepy.Cursor(api.home_timeline).items(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> (status.text)</span><br></pre></td></tr></table></figure><h1 id="报错一-挂代理翻墙"><a href="#报错一-挂代理翻墙" class="headerlink" title="报错一:挂代理翻墙"></a>报错一:挂代理翻墙</h1><p>报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x0000000002FC6E80&gt;: Failed to establish a new connection: [Errno 10061] ',)))</span><br></pre></td></tr></table></figure><p>主要原因就是twitter被墙了，twitter的api当然也被墙了。 </p><p>这时候就需要挂代理翻墙了，我使用的是自己搭建的shadowsockets。其它翻墙软件或者服务器网上有很多，请自行查找。 </p><p>代理打开了之后，在原代码中，将<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api = tweepy.API(auth)</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api = tweepy.API(auth,proxy=<span class="string">"127.0.0.1:1080"</span>)</span><br></pre></td></tr></table></figure></p><h1 id="报错二-请求的配置没有写对"><a href="#报错二-请求的配置没有写对" class="headerlink" title="报错二:请求的配置没有写对"></a>报错二:请求的配置没有写对</h1><p>报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweepy.error.TweepError: Twitter error response: status code = 401</span><br></pre></td></tr></table></figure><p>原因：</p><ul><li>这几个发起请求的配置没有写对，仔细修改<ul><li>consumer_key</li><li>consumer_secret</li><li>access_token</li><li>access_secret</li></ul></li><li>改过了还是不对，刷新Regenerate Consumer Key and Secret和Regenerate My Access Token and Token Secret，重新填写请求</li></ul><h1 id="报错三"><a href="#报错三" class="headerlink" title="报错三"></a>报错三</h1><p>报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', timeout('timed out',)))</span><br></pre></td></tr></table></figure><p>原因是Shadowsocks使用的是socks5代理，并非是http代理。</p><p>emmm，简单，大手一挥，稍微修改一下即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api = tweepy.API(auth, proxy=<span class="string">"socks5://127.0.0.1:1080"</span>)</span><br></pre></td></tr></table></figure><h1 id="报错四"><a href="#报错四" class="headerlink" title="报错四"></a>报错四</h1><p>报错信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweepy.error.TweepError: Failed to send request: SOCKSHTTPSConnectionPool(host='api.twitter.com', port=443): Read timed out. (read timeout=60)</span><br></pre></td></tr></table></figure><p>原因是tweepy使用的是http代理，不能用socks5代理（我日）。</p><p>所以需要将socks5代理转换为http代理来支持tweepy访问twitter REST API,这里参考以下地址：<br><a href="http://blog.csdn.net/shaobo8910/article/details/53908639" target="_blank" rel="noopener">为终端设置Shadowsocks代理</a></p><p>最后不要忘记在代码里加上代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api = tweepy.API(auth, proxy=<span class="string">"127.0.0.1:8123"</span>)</span><br></pre></td></tr></table></figure><p>还没完</p><p>tweepy 这个库的资料比较少,我自己摸索着试了试,把代码发上来</p><p>一.按照关键字搜索Twitter的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#接上面的代码(q = 关键字 ,count = 返回的数据量 . 推特一次最多返回100条??)</span></span><br><span class="line">search_results = api.search(q=<span class="string">'python'</span>,count=<span class="number">100</span>)</span><br><span class="line"><span class="comment">#对对象进行迭代</span></span><br><span class="line"><span class="keyword">for</span> tweet <span class="keyword">in</span> search_results:</span><br><span class="line">    <span class="comment">#tweet还是一个对象,推特的相关信息在tweer._json里</span></span><br><span class="line">    <span class="comment">#这里是检测消息是否含有'text'键,并不是所有TWitter返回的所有对象都是消息(有些可能是用来删除消息或者其他内容的动作--这个没有确认),区别就是消息对象中是否含有'text'键</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'text'</span> <span class="keyword">in</span> tweet._json:</span><br><span class="line">        print(tweet._json[<span class="string">'text'</span>])</span><br><span class="line">        <span class="comment">#这里是把内容给打印出来了,如果需要保存到文件需要用json库的dumps函数转换为字符串形式后写入到文件中</span></span><br><span class="line">        <span class="comment">#例如 :output_file.write(json.dumps(tweet._json))</span></span><br></pre></td></tr></table></figure><p>二.根据Twitter消息的ID批量获取消息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#其中id_list 是消息ID组成的list 长度也不要超过100</span></span><br><span class="line">search_result = api.statuses_lookup(id_list)</span><br></pre></td></tr></table></figure></p><p>这时，就可以成功访问了</p><div class="image-package"><br><img src="/assets/blog/img/2017-10-13/2.png" width="700"><br><div class="image-caption">成功访问</div><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/LinXueyuanStdio/PythonDataMining&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;repo在此&lt;/a&gt;，如果觉得做得好，给个star鼓励下吧！&lt;/p&gt;
&lt;p&gt;在看《Pyt
      
    
    </summary>
    
      <category term="Python" scheme="http://xichen.pub/categories/Python/"/>
    
      <category term="Proxy" scheme="http://xichen.pub/categories/Python/Proxy/"/>
    
    
      <category term="Python" scheme="http://xichen.pub/tags/Python/"/>
    
      <category term="Proxy" scheme="http://xichen.pub/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>algorithms-Bit-Options</title>
    <link href="http://xichen.pub/2017/10/11/2017-10-11-%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://xichen.pub/2017/10/11/2017-10-11-算法之位运算/</id>
    <published>2017-10-11T06:25:00.000Z</published>
    <updated>2018-01-05T00:45:28.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>常用的一个等式：<code>-n = ~(n - 1) = ~n + 1</code></p><h2 id="获得int型最大值"><a href="#获得int型最大值" class="headerlink" title="获得int型最大值"></a>获得int型最大值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;<span class="comment">//2147483647,由于优先级关系,括号不可省略</span></span><br><span class="line">    <span class="keyword">return</span> ~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);   <span class="comment">//2147483647</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; -<span class="number">1</span>) - <span class="number">1</span>;<span class="comment">//2147483647</span></span><br><span class="line">    <span class="keyword">return</span> ((unsigned <span class="keyword">int</span>) - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">//2147483647</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获得int型最小值"><a href="#获得int型最小值" class="headerlink" title="获得int型最小值"></a>获得int型最小值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;<span class="comment">//-2147483648</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; -<span class="number">1</span>;<span class="comment">//-2147483648</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获得long类型的最大值"><a href="#获得long类型的最大值" class="headerlink" title="获得long类型的最大值"></a>获得long类型的最大值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getMaxLong</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsigned <span class="keyword">long</span>) - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;<span class="comment">//2147483647　c语言版</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">127</span>) - <span class="number">1</span>;<span class="comment">//9223372036854775807  java版</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得long最小值，和其他类型的最大值，最小值同理.</p><h2 id="2运算"><a href="#2运算" class="headerlink" title="2运算"></a>2运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n &lt;&lt; <span class="number">1</span>　<span class="comment">// 乘以2</span></span><br><span class="line">n &gt;&gt; <span class="number">1</span> <span class="comment">// 除以2</span></span><br><span class="line">n &lt;&lt; m <span class="comment">// 乘以2的m次方</span></span><br><span class="line">n &gt;&gt; m <span class="comment">// 除以2的m次方</span></span><br></pre></td></tr></table></figure><h2 id="判断一个数的奇偶性"><a href="#判断一个数的奇偶性" class="headerlink" title="判断一个数的奇偶性"></a>判断一个数的奇偶性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOddNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不用临时变量交换两个数（面试常考）"><a href="#不用临时变量交换两个数（面试常考）" class="headerlink" title="不用临时变量交换两个数（面试常考）"></a>不用临时变量交换两个数（面试常考）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    (*a) ^= (*b) ^= (*a) ^= (*b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通用版（一些语言中得分开写）<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span><span class="regexp"> ^=</span> b;</span><br><span class="line"><span class="attribute">b</span><span class="regexp"> ^=</span> a;</span><br><span class="line"><span class="attribute">a</span><span class="regexp"> ^=</span> b;</span><br></pre></td></tr></table></figure></p><h2 id="取绝对值"><a href="#取绝对值" class="headerlink" title="取绝对值"></a>取绝对值</h2><p>（某些机器上，效率比n&gt;0  ?  n:-n 高）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>);</span><br><span class="line"><span class="comment">/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 </span></span><br><span class="line"><span class="comment">若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， </span></span><br><span class="line"><span class="comment">结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取两个数的最大值"><a href="#取两个数的最大值" class="headerlink" title="取两个数的最大值"></a>取两个数的最大值</h2><p>（某些机器上，效率比a&gt;b ? a:b高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &amp; ((a-b) &gt;&gt; <span class="number">31</span>) | a &amp; (~(a-b) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">/*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言版<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ ((x ^ y) &amp; -(x &lt; y));</span><br><span class="line">    <span class="comment">/*如果x&lt;y x&lt;y返回1，否则返回0，</span></span><br><span class="line"><span class="comment">    与0做与运算结果为0，与-1做与运算结果不变*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="取两个数的最小值"><a href="#取两个数的最小值" class="headerlink" title="取两个数的最小值"></a>取两个数的最小值</h2><p>（某些机器上，效率比a&gt;b ? b:a高）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp; ((a-b) &gt;&gt; <span class="number">31</span>) | b &amp; (~(a-b) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="comment">/*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言版<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ^ ((x ^ y) &amp; -(x &lt; y));</span><br><span class="line">    <span class="comment">/*如果x&lt;y x&lt;y返回1，否则返回0， </span></span><br><span class="line"><span class="comment">      与0做与运算结果为0，与-1做与运算结果不变*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="判断符号是否相同"><a href="#判断符号是否相同" class="headerlink" title="判断符号是否相同"></a>判断符号是否相同</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSameSign</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//有0的情况例外</span></span><br><span class="line">    <span class="keyword">return</span> (x ^ y) &gt;= <span class="number">0</span>; <span class="comment">// true 表示 x和y有相同的符号， false表示x，y有相反的符号。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算2的n次方"><a href="#计算2的n次方" class="headerlink" title="计算2的n次方"></a>计算2的n次方</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFactorialofTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//n &gt; 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; (n-<span class="number">1</span>);<span class="comment">//2的n次方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个数是不是2的幂"><a href="#判断一个数是不是2的幂" class="headerlink" title="判断一个数是不是2的幂"></a>判断一个数是不是2的幂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFactorialofTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> : <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*如果是2的幂，n一定是100... n-1就是1111.... </span></span><br><span class="line"><span class="comment">       所以做与运算结果为0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对2的n次方取余"><a href="#对2的n次方取余" class="headerlink" title="对2的n次方取余"></a>对2的n次方取余</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quyu</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//n为2的次方</span></span><br><span class="line">    <span class="keyword">return</span> m &amp; (n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*如果是2的幂，n一定是100... n-1就是1111.... </span></span><br><span class="line"><span class="comment">     所以做与运算结果保留m在n范围的非0的位*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求两个整数的平均值"><a href="#求两个整数的平均值" class="headerlink" title="求两个整数的平均值"></a>求两个整数的平均值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x ^ y) &gt;&gt; <span class="number">1</span>) + (x &amp; y);</span><br><span class="line">    <span class="comment">/*(x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2， </span></span><br><span class="line"><span class="comment">       x&amp;y得到x，y都为1的部分，加一起就是平均数了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是三个最基本对二进制位的操作</p><h2 id="从低位到高位-取n的第m位"><a href="#从低位到高位-取n的第m位" class="headerlink" title="从低位到高位,取n的第m位"></a>从低位到高位,取n的第m位</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt; (m-<span class="number">1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从低位到高位-将n的第m位置设为1"><a href="#从低位到高位-将n的第m位置设为1" class="headerlink" title="从低位到高位.将n的第m位置设为1"></a>从低位到高位.将n的第m位置设为1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setBitToOne</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n | (<span class="number">1</span> &lt;&lt; (m-<span class="number">1</span>));</span><br><span class="line">    <span class="comment">/*将1左移m-1位找到第m位，得到000...1...000 </span></span><br><span class="line"><span class="comment">      n在和这个数做或运算*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从低位到高位-将n的第m位置设为0"><a href="#从低位到高位-将n的第m位置设为0" class="headerlink" title="从低位到高位,将n的第m位置设为0"></a>从低位到高位,将n的第m位置设为0</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setBitToZero</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; ~(<span class="number">1</span> &lt;&lt; (m-<span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* 将1左移m-1位找到第m位，取反后变成111...0...1111 </span></span><br><span class="line"><span class="comment">       n再和这个数做与运算*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）"><a href="#另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）" class="headerlink" title="另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）"></a>另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n+<span class="number">1</span> = -~n</span><br><span class="line">n-<span class="number">1</span> = ~-n</span><br><span class="line">-n  = ~n+<span class="number">1</span></span><br><span class="line">-n  = (n^-<span class="number">1</span>)+<span class="number">1</span></span><br><span class="line">x = a ^ b ^ x &lt;=&gt; <span class="keyword">if</span>(x == a) x = b; <span class="keyword">if</span>(x == b) x = a;</span><br><span class="line">sign(x) = !!n - (((unsigned)n &gt;&gt; <span class="number">31</span>) &lt;&lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="获取整数二进制表示中最右侧的1"><a href="#获取整数二进制表示中最右侧的1" class="headerlink" title="获取整数二进制表示中最右侧的1"></a>获取整数二进制表示中最右侧的1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &amp; (-n)  &lt;=&gt; n &amp; ~(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>用到了n &amp; (n - 1)<br>由x &amp; (x - 1)消去x最后一位的1可知。不断使用 x &amp; (x - 1) 消去x最后一位的1，计算总共消去了多少次即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">        num = num &amp; (num-<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转</span></span><br><span class="line"><span class="function">unsigned <span class="keyword">int</span> <span class="title">Bit_Reverse</span><span class="params">(unsigned <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    v = ((v &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>) | ((v &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xaaaaaaaa</span>);</span><br><span class="line">    v = ((v &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>) | ((v &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xcccccccc</span>);</span><br><span class="line">    v = ((v &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>) | ((v &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0xf0f0f0f0</span>);</span><br><span class="line">    v = ((v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>) | ((v &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xff00ff00</span>);</span><br><span class="line">    v = ((v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>) | ((v &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0xffff0000</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入两个数A和B，输出将A转换为B所需改变的二进制的位数。"><a href="#输入两个数A和B，输出将A转换为B所需改变的二进制的位数。" class="headerlink" title="输入两个数A和B，输出将A转换为B所需改变的二进制的位数。"></a>输入两个数A和B，输出将A转换为B所需改变的二进制的位数。</h2><p>首先，A异或B得到的是A和B中不相同位数组成的数，然后再求这个数二进制表示中1的个数，即为所求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countOnes(A^B);</span><br></pre></td></tr></table></figure></p><h2 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h2><p>用到了n &amp; (n - 1) 和 a ^ b ^ b = a</p><h3 id="数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数"><a href="#数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数" class="headerlink" title="数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数"></a>数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数</h3><p>因为只有一个数恰好出现一个，剩下的都出现过两次，所以只要将所有的数异或起来，就可以得到唯一的那个数。<br>参考文章：<a href="http://zhedahht.blog.163.com/blog/static/2541117420071128950682/" target="_blank" rel="noopener">http://zhedahht.blog.163.com/blog/static/2541117420071128950682/</a></p><h3 id="数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数"><a href="#数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数" class="headerlink" title="数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数"></a>数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数</h3><p>因为数是出现三次的，也就是说，对于每一个二进制位，如果只出现一次的数在该二进制位为1，那么这个二进制位在全部数字中出现次数无法被3整除。</p><p>膜3运算只有三种状态：00,01,10，因此我们可以使用两个位来表示当前位%3，对于每一位，我们让Two，One表示当前位的状态，B表示输入数字的对应位，Two+和One+表示输出状态。</p><p>参考文章：<a href="http://zhedahht.blog.163.com/blog/static/25411174201283084246412/" target="_blank" rel="noopener">http://zhedahht.blog.163.com/blog/static/25411174201283084246412/</a></p><h2 id="数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数"><a href="#数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数" class="headerlink" title="数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数"></a>数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数</h2><p>有了第一题的基本的思路，我们可以将数组分成两个部分，每个部分里只有一个元素出现一次，其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。<br>不妨假设出现一个的两个元素是x，y，那么最终所有的元素异或的结果就是res = x^y。并且res！=0，那么我们可以找出res二进制表示中的某一位是1。对于原来的数组，我们可以根据这个位置是不是1就可以将数组分成两个部分。x，y在不同的两个子数组中。而且对于其他成对出现的元素，要么在x所在的那个数组，要么在y所在的那个数组。</p><h2 id="位操作实现加减乘除运算"><a href="#位操作实现加减乘除运算" class="headerlink" title="位操作实现加减乘除运算"></a>位操作实现加减乘除运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry, add;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        add = a ^ b; <span class="comment">//该操作得到本位的加法结果  </span></span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>; <span class="comment">//该操作得到该位对高位的进位值  </span></span><br><span class="line">        a = add;  </span><br><span class="line">        b = carry;  </span><br><span class="line">    &#125; <span class="keyword">while</span> (carry != <span class="number">0</span>); <span class="comment">//循环直到某次运算没有进位，运算结束</span></span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BinaryAdd(a, BinaryAdd(~b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*乘法 </span></span><br><span class="line"><span class="comment">该过程中的bit_map是为了快速得到乘法过程中某位相乘的中间结果S[i] </span></span><br><span class="line"><span class="comment">需要位移的位数。bit_map的键值是2^0, 2^1,2^2, ……之类的数，对应的 </span></span><br><span class="line"><span class="comment">值是0，1,2,……(即需要位移的位数)。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryMultiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> neg = (b &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(b &lt; <span class="number">0</span>)</span><br><span class="line">        b = -b;  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bit_map;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        bit_map.insert(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; i, i));  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        b &amp; ~(b - 1)可以得到乘数b的二进制表示中最右侧1的位置 </span></span><br><span class="line"><span class="comment">        last_bit记录被乘数a需要位移的位数 </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">        <span class="keyword">int</span> last_bit = bit_map[b &amp; ~(b - <span class="number">1</span>)];  </span><br><span class="line">        <span class="comment">//将得到的乘法结果全部相加即为最后结果  </span></span><br><span class="line">        sum += (a &lt;&lt; last_bit);  </span><br><span class="line">        b &amp;= b - <span class="number">1</span>; <span class="comment">//每次将b的二进制表示的最右侧1去掉用于下一次乘法  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(neg)</span><br><span class="line">        sum = -sum;  </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryDivide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> neg = (a &gt; <span class="number">0</span>) ^ (b &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span>)</span><br><span class="line">        a = -a;  </span><br><span class="line">    <span class="keyword">if</span>(b &lt; <span class="number">0</span>)</span><br><span class="line">        b = -b;  </span><br><span class="line">    <span class="keyword">if</span>(a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> msb = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//msd记录除数需要左移的位数</span></span><br><span class="line">    <span class="keyword">for</span>(msb = <span class="number">0</span>; msb &lt; <span class="number">32</span>; msb++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((b &lt;&lt; msb) &gt;= a)  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>; <span class="comment">//记录每次除法的商</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = msb; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>((b &lt;&lt; i) &gt; a)  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        q |= (<span class="number">1</span> &lt;&lt; i);  </span><br><span class="line">        a -= (b &lt;&lt; i);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(neg)</span><br><span class="line">        <span class="keyword">return</span> -q;  </span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h1><ul><li><a href="http://blog.csdn.net/zmazon/article/details/8262185" target="_blank" rel="noopener">优秀程序员不得不知道的20个位运算技巧</a><a href="http://blog.csdn.net/zmazon/article/details/8262185" target="_blank" rel="noopener">http://blog.csdn.net/zmazon/article/details/8262185</a></li><li><a href="http://blog.csdn.net/u013074465/article/details/42680239" target="_blank" rel="noopener">位操作实现加减乘除四则运算</a><a href="http://blog.csdn.net/u013074465/article/details/42680239" target="_blank" rel="noopener">http://blog.csdn.net/u013074465/article/details/42680239</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;p&gt;常用的一个等式：&lt;code&gt;-n = ~(n - 1) = ~n + 1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;获得int型最大值&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="algorithms" scheme="http://xichen.pub/categories/algorithms/"/>
    
    
      <category term="算法" scheme="http://xichen.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面向过程，面向对象，函数式</title>
    <link href="http://xichen.pub/2017/09/18/2017-9-18-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    <id>http://xichen.pub/2017/09/18/2017-9-18-面向过程-面向对象-函数式/</id>
    <published>2017-09-17T22:42:14.000Z</published>
    <updated>2018-01-05T00:45:28.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何把大象关进冰箱里？"><a href="#如何把大象关进冰箱里？" class="headerlink" title="如何把大象关进冰箱里？"></a>如何把大象关进冰箱里？</h3><h4 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把冰箱门打开 =&gt; 大象放冰箱里 =&gt; 冰箱门关上</span><br></pre></td></tr></table></figure><h4 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">冰箱.开门（）</span><br><span class="line">冰箱.放入（大象）</span><br><span class="line">冰箱.关门（）</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">冰箱.开门().放入(大象).关门()</span><br></pre></td></tr></table></figure><h4 id="函数式："><a href="#函数式：" class="headerlink" title="函数式："></a>函数式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关进（冰箱，大象）:</span><br><span class="line">    关门（放入（开门（冰箱），大象））</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何把大象关进冰箱里？&quot;&gt;&lt;a href=&quot;#如何把大象关进冰箱里？&quot; class=&quot;headerlink&quot; title=&quot;如何把大象关进冰箱里？&quot;&gt;&lt;/a&gt;如何把大象关进冰箱里？&lt;/h3&gt;&lt;h4 id=&quot;面向过程：&quot;&gt;&lt;a href=&quot;#面向过程：&quot; class
      
    
    </summary>
    
      <category term="杂思" scheme="http://xichen.pub/categories/%E6%9D%82%E6%80%9D/"/>
    
    
      <category term="杂思" scheme="http://xichen.pub/tags/%E6%9D%82%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>terminal tips</title>
    <link href="http://xichen.pub/2017/08/28/2017-08-28-Terminal-tips/"/>
    <id>http://xichen.pub/2017/08/28/2017-08-28-Terminal-tips/</id>
    <published>2017-08-27T20:46:00.000Z</published>
    <updated>2018-01-05T00:45:28.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h1><ul><li>快捷键：<code>Ctrl+Alt-T</code></li><li>空白处右键：有选项<code>在终端打开</code></li><li>处于命令行窗口：<code>Ctrl+T</code>选项卡形式，<code>Ctrl+N</code>窗口形式</li></ul><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><h2 id="颜色代码"><a href="#颜色代码" class="headerlink" title="颜色代码"></a>颜色代码</h2><hr><table><thead><tr><th>前景</th><th>背景</th><th>颜色</th></tr></thead><tbody><tr><td>30</td><td>40</td><td>黑色</td></tr><tr><td>31</td><td>41</td><td>紅色</td></tr><tr><td>32</td><td>42</td><td>綠色</td></tr><tr><td>33</td><td>43</td><td>黃色</td></tr><tr><td>34</td><td>44</td><td>藍色</td></tr><tr><td>35</td><td>45</td><td>紫紅色</td></tr><tr><td>36</td><td>46</td><td>青藍色</td></tr><tr><td>37</td><td>47</td><td>白色</td></tr><tr><td>——-</td><td>———–</td><td>———</td></tr><tr><td>1</td><td>透明色</td></tr></tbody></table><h2 id="——"><a href="#——" class="headerlink" title="——- "></a>——- </h2><table><thead><tr><th>代码</th><th>意义</th></tr></thead><tbody><tr><td>0</td><td>OFF</td></tr><tr><td>1</td><td>高亮显示</td></tr><tr><td>4</td><td>underline</td></tr><tr><td>5</td><td>闪烁</td></tr><tr><td>7</td><td>反白显示</td></tr><tr><td>8</td><td>不可见</td></tr></tbody></table><hr><h2 id="序列说明"><a href="#序列说明" class="headerlink" title="序列说明"></a>序列说明</h2><p> | \a |  ASCII响铃字符（也可以键入 \007） |<br> | \d |  “Wed Sep 06”格式的日期 |<br> | \e |  ASCII转义字符（也可以键入 \033） |<br> | \h |  主机名的第一部分（如 “mybox”） |<br> | \H |  主机的全称（如 “mybox.mydomain.com”） |<br> | \j |  在此 shell中通过按 ^Z挂起的进程数 |<br> | \l | 此 shell的终端设备名（如 “ttyp4”） |<br> | \n |  换行符 |<br> | \r |  回车符 |<br> | \s |  shell的名称（如 “bash”） |<br> | \t |  24小时制时间（如 “23:01:01”） |<br> | \T |  12小时制时间（如 “11:01:01”） |<br> | \@ | 带有 am/pm的 12小时制时间 |<br> | \u | 用户名 |<br> | \v | bash的版本（如 2.04） |<br> | \V |  Bash版本（包括补丁级别） ?/td&gt;; |<br> | \w |  当前工作目录（如 “/home/drobbins”） |<br> | \W |  当前工作目录的“基名 (basename)”（如 “drobbins”） |<br> | ! |  当前命令在历史缓冲区中的位置 |<br> | # | 命令编号（只要您键入内容，它就会在每次提示时累加） |<br> | \$ |  如果您不是超级用户 (root)，则插入一个 “$”；如果您是超级用户，则显示一个 “#” |<br> | \xxx |  插入一个用三位数 xxx（用零代替未使用的数字，如 “/007”）表示的 ASCII 字符 |<br> | \  | 反斜杠 |<br> | [ | 这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使 bash能够正确计算自动换行。 |<br> | ]  | 这个序列应该出现在非打印字符序列之后。 | </p><h2 id="颜色的设置公式"><a href="#颜色的设置公式" class="headerlink" title="颜色的设置公式"></a>颜色的设置公式</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">颜色=\<span class="number">033</span>[代码<span class="comment">;前景;背景m</span></span><br></pre></td></tr></table></figure><p>如：<code>\033[1;32;40m</code>表示高亮显示字体为绿色，背景色为黑色（颜色定义见本文前面的表格）</p><blockquote><p>注意：<br>  要将全部非打印字符用专用的 bash 转义序列 “[“和 “]“括起来。这两个序列通知 bash，被括起来的字符不占用行上的任何空间，这样就使自动换行能够继续正常工作。<br>  这点很关键要不然等你设好了颜色，你的终端换行会乱七八糟</p></blockquote><hr><h2 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h2><p>默认的就很好看，打开<code>~/.bashrc</code>，其中有几行声明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ "$color_prompt" = yes ]; then</span><br><span class="line">    PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '</span><br><span class="line">else</span><br><span class="line">    PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\u@\h:\w\$ '</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>下面这个就是默认的配色方案<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1='<span class="formula">$&#123;debian_chroot:+($</span>debian_chroot)&#125;<span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[01;32m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">u</span></span>@<span class="tag">\<span class="name">h</span></span><span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[00m<span class="tag">\<span class="name">]</span></span>:<span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[01;34m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">w</span></span><span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[00m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">$</span></span> '</span><br></pre></td></tr></table></figure></p><p>要修改配色方案，在文件末尾加上<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=`balabala`</span><br></pre></td></tr></table></figure></p><h2 id="ROOT身份下的终端颜色"><a href="#ROOT身份下的终端颜色" class="headerlink" title="ROOT身份下的终端颜色"></a>ROOT身份下的终端颜色</h2><p>打开<code>/root/.bash.rc</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /root/<span class="selector-class">.bash</span><span class="selector-class">.rc</span></span><br></pre></td></tr></table></figure></p><p>按<code>i</code>进入插入字符模式，在文件末尾加上一行(把默认的贴过去)<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1='<span class="formula">$&#123;debian_chroot:+($</span>debian_chroot)&#125;<span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[01;32m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">u</span></span>@<span class="tag">\<span class="name">h</span></span><span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[00m<span class="tag">\<span class="name">]</span></span>:<span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[01;34m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">w</span></span><span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[00m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">$</span></span> '</span><br></pre></td></tr></table></figure></p><p>按下<code>Esc</code>然后输入<code>:wq</code>保存修改</p><p>再输入<code>source ~/.bashrc</code>刷新</p><h2 id="SSH会话下的终端颜色"><a href="#SSH会话下的终端颜色" class="headerlink" title="SSH会话下的终端颜色"></a>SSH会话下的终端颜色</h2><p>通过在.bashrc文件中更改与ssh连接的每个主机名上的PS1值</p><p>在托管的机器上(lxy @ ubuntu)同样打开文件<code>~/.bashrc</code><br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure></p><p>在文件末尾加上一行(把默认的贴过去)<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1='<span class="formula">$&#123;debian_chroot:+($</span>debian_chroot)&#125;<span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[01;32m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">u</span></span>@<span class="tag">\<span class="name">h</span></span><span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[00m<span class="tag">\<span class="name">]</span></span>:<span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[01;34m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">w</span></span><span class="tag">\<span class="name">[</span></span><span class="tag">\</span>033[00m<span class="tag">\<span class="name">]</span></span><span class="tag">\<span class="name">$</span></span> '</span><br></pre></td></tr></table></figure></p><p>按下<code>Esc</code>然后输入<code>:wq</code>保存修改</p><p>再输入<code>source ~/.bashrc</code>刷新</p><h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><p>安装zsh<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure></p><p>安装oh-my-zsh<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/tmplates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>Powerline 主题<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme ~/.ohmyzsh-powerline</span><br><span class="line">cd ~/.ohmyzsh-powerline</span><br><span class="line">cp powerline.zsh-theme ~/.oh-my-zsh/themes/powerline.zsh-theme</span><br><span class="line">rm -rf ~/.ohmyzsh-powerline</span><br></pre></td></tr></table></figure></p><p>把zsh设为默认<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p><p>卸载zsh<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove zsh</span><br></pre></td></tr></table></figure></p><p>今天手残装了zsh和oh-my-zsh后又卸载掉，导致<code>su</code>进不去<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无法执行 <span class="regexp">/usr/</span>bin/<span class="string">zsh:</span> 没有那个文件或目录</span><br></pre></td></tr></table></figure></p><p>只要把 <code>/usr/bin/zsh</code> 改成 <code>/bin/bash</code> 就可以了<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure></p><p>第一句改成<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br></pre></td></tr></table></figure></p><p>或者直接运行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chsh -s /bin/bashrc</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;打开&quot;&gt;&lt;a href=&quot;#打开&quot; class=&quot;headerlink&quot; title=&quot;打开&quot;&gt;&lt;/a&gt;打开&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;快捷键：&lt;code&gt;Ctrl+Alt-T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空白处右键：有选项&lt;code&gt;在终端打开&lt;/code&gt;
      
    
    </summary>
    
      <category term="Tips" scheme="http://xichen.pub/categories/Tips/"/>
    
    
      <category term="Linux" scheme="http://xichen.pub/tags/Linux/"/>
    
      <category term="Tips" scheme="http://xichen.pub/tags/Tips/"/>
    
      <category term="Ubuntu" scheme="http://xichen.pub/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Golang程序配置方案小结</title>
    <link href="http://xichen.pub/2017/08/28/2017-08-28-Golang-setting/"/>
    <id>http://xichen.pub/2017/08/28/2017-08-28-Golang-setting/</id>
    <published>2017-08-27T20:19:00.000Z</published>
    <updated>2018-01-05T00:45:28.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>无论使用任何编程语言开发应用，都离不开配置数据。配置数据提供的形式有多样，不外乎命令行选项(options)、参数（parameters)，环境 变量（env vars)以及配置文件等。Golang也不例外。Golang内置flag标准库，可以用来支持部分命令行选项和参数的解析；Golang通过os包提 供的方法可以获取当前环境变量；但Golang没有规定标准配置文件格式(虽说内置支持xml、json)，多通过第三方 包来解决配置文件读取的问题。Golang配置相关的第三方包邮很多，作者在本文中给出的配置方案中就包含了主流的第三方配置数据操作包。</p><p>一个良好的应用配置层次应该是这样的：</p><ol><li>程序内内置配置项的初始默认值</li><li>配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。</li><li>命令行选项和参数值具有最高优先级，可以override前两层的配置项值。</li></ol><p>下面循序渐进探讨golang程序配置方案。</p><h1 id="解析命令行选项和参数"><a href="#解析命令行选项和参数" class="headerlink" title="解析命令行选项和参数"></a>解析命令行选项和参数</h1><p>这一节关注golang程序如何访问命令行选项和参数。</p><p>golang对访问到命令行参数提供了内建的支持：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cmdlineargs.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//      "fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"I am "</span>, os.Args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    baseName := filepath.Base(os.Args[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"The base name is "</span>, baseName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The length of array a can be discovered using the built-in function len</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Argument # is "</span>, <span class="built_in">len</span>(os.Args))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the first command line arguments</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The first command line argument: "</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build cmdlineargs.<span class="keyword">go</span></span><br><span class="line">$cmdlineargs test one</span><br><span class="line">I <span class="keyword">am</span>  cmdlineargs</span><br><span class="line">The base name <span class="keyword">is</span>  cmdlineargs</span><br><span class="line">Argument # <span class="keyword">is</span>  <span class="number">3</span></span><br><span class="line">The <span class="keyword">first</span> <span class="keyword">command</span> <span class="built_in">line</span> argumen<span class="variable">t:</span>  test</span><br></pre></td></tr></table></figure></p><p>对于命令行结构复杂一些的程序，我们最起码要用到golang标准库内置的flag包：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cmdlineflag.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// main operation modes</span></span><br><span class="line">    write = flag.Bool(<span class="string">"w"</span>, <span class="literal">false</span>, <span class="string">"write result back instead of stdout\n\t\tDefault: No write back"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// layout control</span></span><br><span class="line">    tabWidth = flag.Int(<span class="string">"tabwidth"</span>, <span class="number">8</span>, <span class="string">"tab width\n\t\tDefault: Standard"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// debugging</span></span><br><span class="line">    cpuprofile = flag.String(<span class="string">"cpuprofile"</span>, <span class="string">""</span>, <span class="string">"write cpu profile to this file\n\t\tDefault: no default"</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usage</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Fprintf allows us to print to a specifed file handle or stream</span></span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">"\nUsage: %s [flags] file [path ...]\n\n"</span>,</span><br><span class="line">        <span class="string">"CommandLineFlag"</span>) <span class="comment">// os.Args[0]</span></span><br><span class="line">    flag.PrintDefaults()</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Before parsing the flags\n"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"T: %d\nW: %s\nC: '%s'\n"</span>,</span><br><span class="line">        *tabWidth, strconv.FormatBool(*write), *cpuprofile)</span><br><span class="line"></span><br><span class="line">    flag.Usage = usage</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is also a mandatory non-flag arguments</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(flag.Args()) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        usage()</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    fmt.Printf(<span class="string">"Testing the flag package\n"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"T: %d\nW: %s\nC: '%s'\n"</span>,</span><br><span class="line">        *tabWidth, strconv.FormatBool(*write), *cpuprofile)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> flag.Args() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"I: %d C: '%s'\n"</span>, index, element)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子中：</p><ul><li>说明了三种类型标志的用法：Int、String和Bool。</li><li>说明了每个标志的定义都由类型、命令行选项文本、默认值以及含义解释组成。</li><li>最后说明了如何处理标志选项(flag option)以及非option参数。</li></ul><p>不带参数运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cmdlineflag</span></span><br><span class="line">Before parsing the flags</span><br><span class="line">T: 8</span><br><span class="line">W: false</span><br><span class="line">C: ''</span><br><span class="line"></span><br><span class="line">Usage: CommandLineFlag [flags] file [path ...]</span><br><span class="line"></span><br><span class="line">  -cpuprofile="": write cpu profile to this file</span><br><span class="line">        Default: no default</span><br><span class="line">  -tabwidth=8: tab width</span><br><span class="line">        Default: Standard</span><br><span class="line">  -w=false: write result back instead of stdout</span><br><span class="line">        Default: No write back</span><br></pre></td></tr></table></figure></p><p>带命令行标志以及参数运行(一个没有flag，一个有两个flag)：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cmdlineflag aa bb</span></span><br><span class="line">Before parsing the flags</span><br><span class="line">T: 8</span><br><span class="line">W: false</span><br><span class="line">C: ''</span><br><span class="line">Testing the flag package</span><br><span class="line">T: 8</span><br><span class="line">W: false</span><br><span class="line">C: ''</span><br><span class="line">I: 0 C: 'aa'</span><br><span class="line">I: 1 C: 'bb'</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">cmdlineflag -tabwidth=2 -w aa</span></span><br><span class="line">Before parsing the flags</span><br><span class="line">T: 8</span><br><span class="line">W: false</span><br><span class="line">C: ''</span><br><span class="line">Testing the flag package</span><br><span class="line">T: 2</span><br><span class="line">W: true</span><br><span class="line">C: ''</span><br><span class="line">I: 0 C: 'aa'</span><br></pre></td></tr></table></figure></p><p>从例子可以看出，简单情形下，你无需编写自己的命令行parser或使用第三方包，使用go内建的flag包即可以很好的完成工作。但是golang的 flag包与命令行Parser的事实标准：Posix getopt（C/C++/Perl/Shell脚本都可用）相比，还有较大差距，主要体现在：</p><ol><li>无法支持区分long option和short option，比如：-h和–help。</li><li>不支持short options合并，比如：ls -l -h &lt;=&gt; ls -hl</li><li>命令行标志的位置不能任意放置，比如无法放在non-flag parameter的后面。</li></ol><p>不过毕竟flag是golang内置标准库包，你无须付出任何cost，就能使用它的功能。另外支持bool型的flag也是其一大亮点。</p><h1 id="TOML，Go配置文件的事实标准（这个可能不能得到认同）"><a href="#TOML，Go配置文件的事实标准（这个可能不能得到认同）" class="headerlink" title="TOML，Go配置文件的事实标准（这个可能不能得到认同）"></a>TOML，Go配置文件的事实标准（这个可能不能得到认同）</h1><p>命令行虽然是一种可选的配置方案，但更多的时候，我们使用配置文件来存储静态的配置数据。就像Java配xml，ruby配yaml，windows配 ini，Go也有自己的搭配组合，那就是TOML（Tom’s Obvious, Minimal Language）。</p><p>初看toml语法有些类似windows ini，但细致研究你会发现它远比ini强大的多，下面是一个toml配置文件例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a TOML document. Boom.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">title</span> = <span class="string">"TOML Example"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[owner]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"Lance Uppercut"</span></span><br><span class="line"><span class="attr">dob</span> = <span class="number">1979</span>-<span class="number">05</span>-<span class="number">27</span>T07:<span class="number">32</span>:<span class="number">00</span>-<span class="number">08</span>:<span class="number">00</span> # First class dates? Why not?</span><br><span class="line"></span><br><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="attr">server</span> = <span class="string">"192.168.1.1"</span></span><br><span class="line"><span class="attr">ports</span> = [ <span class="number">8001</span>, <span class="number">8001</span>, <span class="number">8002</span> ]</span><br><span class="line"><span class="attr">connection_max</span> = <span class="number">5000</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[servers]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># You can indent as you please. Tabs or spaces. TOML don't care.</span></span><br><span class="line"><span class="section">  [servers.alpha]</span></span><br><span class="line">  ip = "10.0.0.1"</span><br><span class="line">  dc = "eqdc10"</span><br><span class="line"></span><br><span class="line"><span class="section">  [servers.beta]</span></span><br><span class="line">  ip = "10.0.0.2"</span><br><span class="line">  dc = "eqdc10"</span><br><span class="line"></span><br><span class="line"><span class="section">[clients]</span></span><br><span class="line"><span class="attr">data</span> = [ [<span class="string">"gamma"</span>, <span class="string">"delta"</span>], [<span class="number">1</span>, <span class="number">2</span>] ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Line breaks are OK when inside arrays</span></span><br><span class="line"><span class="attr">hosts</span> = [</span><br><span class="line">  "alpha",</span><br><span class="line">  "omega"</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>看起来很强大，也很复杂，但解析起来却很简单。以下面这个toml 文件为例：<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Age</span> = <span class="number">25</span></span><br><span class="line"><span class="attr">Cats</span> = [ <span class="string">"Cauchy"</span>, <span class="string">"Plato"</span> ]</span><br><span class="line"><span class="attr">Pi</span> = <span class="number">3.14</span></span><br><span class="line"><span class="attr">Perfection</span> = [ <span class="number">6</span>, <span class="number">28</span>, <span class="number">496</span>, <span class="number">8128</span> ]</span><br><span class="line"><span class="attr">DOB</span> = <span class="number">1987</span>-<span class="number">07</span>-<span class="number">05</span>T05:<span class="number">45</span>:<span class="number">00</span>Z</span><br></pre></td></tr></table></figure></p><p>和所有其他配置文件parser类似，这个配置文件中的数据可以被直接解析成一个golang struct：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">  Cats []<span class="keyword">string</span></span><br><span class="line">  Pi <span class="keyword">float64</span></span><br><span class="line">  Perfection []<span class="keyword">int</span></span><br><span class="line">  DOB time.Time <span class="comment">// requires `import time`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其解析的步骤也很简单：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> conf Config</span><br><span class="line"><span class="keyword">if</span> _, err := toml.Decode(tomlData, &amp;conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是简单的不能简单了！</p><p>不过toml也有其不足之处。想想如果你需要使用命令行选项的参数值来覆盖这些配置文件中的选项，你应该怎么做？事实上，我们常常会碰到类似下面这种三层配置结构的情况：</p><ol><li>程序内内置配置项的初始默认值</li><li>配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。</li><li>命令行选项和参数值具有最高优先级，可以override前两层的配置项值。</li></ol><p>在go中，toml映射的结果体字段没有初始值。而且go内建flag包也没有将命令行参数值解析为一个go结构体，而是零散的变量。这些可以通过第三方工具来解决，但如果你不想用第三方工具，你也可以像下面这样自己解决，虽然难看一些。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func ConfigGet() *Config &#123;</span><br><span class="line">    <span class="built_in">var</span> err <span class="built_in">error</span></span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">cf</span> *Config = NewConfig()</span><br><span class="line"></span><br><span class="line">    // set default <span class="built_in">values</span> defined <span class="keyword">in</span> the <span class="built_in">program</span></span><br><span class="line">    <span class="built_in">cf</span>.ConfigFromFlag()</span><br><span class="line">    //<span class="built_in">log</span>.Printf(<span class="string">"P: %d, B: '%s', F: '%s'\n"</span>, <span class="built_in">cf</span>.MaxProcs, <span class="built_in">cf</span>.Webapp.Path)</span><br><span class="line"></span><br><span class="line">    // Load config file, from flag <span class="keyword">or</span> env (<span class="keyword">if</span> specified)</span><br><span class="line">    <span class="symbol">_</span>, err = <span class="built_in">cf</span>.ConfigFromFile(*configFile, os.Getenv(<span class="string">"APPCONFIG"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        <span class="built_in">log</span>.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    //<span class="built_in">log</span>.Printf(<span class="string">"P: %d, B: '%s', F: '%s'\n"</span>, <span class="built_in">cf</span>.MaxProcs, <span class="built_in">cf</span>.Webapp.Path)</span><br><span class="line"></span><br><span class="line">    // Override <span class="built_in">values</span> from command line flags</span><br><span class="line">    <span class="built_in">cf</span>.ConfigToFlag()</span><br><span class="line">    flag.Usage = usage</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="built_in">cf</span>.ConfigFromFlag()</span><br><span class="line">    //<span class="built_in">log</span>.Printf(<span class="string">"P: %d, B: '%s', F: '%s'\n"</span>, <span class="built_in">cf</span>.MaxProcs, <span class="built_in">cf</span>.Webapp.Path)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf</span>.ConfigApply()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">cf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就像上面代码中那样，你需要：</p><ol><li>用命令行标志默认值设置配置(cf)默认值。</li><li>接下来加载配置文件</li><li>用配置值(cf)覆盖命令行标志变量值</li><li>解析命令行参数</li><li>用命令行标志变量值覆盖配置(cf)值。</li></ol><p>少一步你都无法实现三层配置能力。</p><h1 id="超越TOML"><a href="#超越TOML" class="headerlink" title="超越TOML"></a>超越TOML</h1><p>本节将关注如何克服TOML的各种局限。</p><p>为了达成这个目标，很多人会说：使用viper，不过在介绍viper这一重量级选手 之前，我要为大家介绍另外一位不那么知名的选手：multiconfig。</p><p>有些人总是认为大的就是好的，但我相信适合的还是更好的。因为：</p><ol><li>viper太重量级，使用viper时你需要pull另外20个viper依赖的第三方包</li><li>事实上，viper单独使用还不足以满足需求，要想得到viper全部功能，你还需要另外一个包配合，而后者又依赖13个外部包</li><li>与viper相比，multiconfig使用起来更简单。</li></ol><p>好了，我们再来回顾一下我们现在面临的问题：</p><ol><li>在程序里定义默认配置，这样我们就无需再在toml中定义它们了。</li><li>用toml配置文件中的数据override默认配置</li><li>用命令行或环境变量的值override从toml中读取的配置。</li></ol><p>下面是一个说明如何使用multiconfig的例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := multiconfig.NewWithPath(<span class="string">"config.toml"</span>) <span class="comment">// supports TOML and JSON</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get an empty struct for your configuration</span></span><br><span class="line">    serverConf := <span class="built_in">new</span>(Server)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Populated the serverConf struct</span></span><br><span class="line">    m.MustLoad(serverConf) <span class="comment">// Check for error</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"After Loading: "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, serverConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> serverConf.Enabled &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Enabled field is set to true"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Enabled field is set to false"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子中的toml文件如下：<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name</span>              = <span class="string">"koding"</span></span><br><span class="line"><span class="attr">Enabled</span>           = <span class="literal">false</span></span><br><span class="line"><span class="attr">Port</span>              = <span class="number">6066</span></span><br><span class="line"><span class="attr">Users</span>             = [<span class="string">"ankara"</span>, <span class="string">"istanbul"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[Postgres]</span></span><br><span class="line"><span class="attr">Enabled</span>           = <span class="literal">true</span></span><br><span class="line"><span class="attr">Port</span>              = <span class="number">5432</span></span><br><span class="line"><span class="attr">Hosts</span>             = [<span class="string">"192.168.2.1"</span>, <span class="string">"192.168.2.2"</span>, <span class="string">"192.168.2.3"</span>]</span><br><span class="line"><span class="attr">AvailabilityRatio</span> = <span class="number">8.23</span></span><br></pre></td></tr></table></figure></p><p>toml映射后的go结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    <span class="comment">// Server holds supported types by the multiconfig package</span></span><br><span class="line">    Server <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name     <span class="keyword">string</span></span><br><span class="line">        Port     <span class="keyword">int</span> <span class="string">`default:"6060"`</span></span><br><span class="line">        Enabled  <span class="keyword">bool</span></span><br><span class="line">        Users    []<span class="keyword">string</span></span><br><span class="line">        Postgres Postgres</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postgres is here for embedded struct feature</span></span><br><span class="line">    Postgres <span class="keyword">struct</span> &#123;</span><br><span class="line">        Enabled           <span class="keyword">bool</span></span><br><span class="line">        Port              <span class="keyword">int</span></span><br><span class="line">        Hosts             []<span class="keyword">string</span></span><br><span class="line">        DBName            <span class="keyword">string</span></span><br><span class="line">        AvailabilityRatio <span class="keyword">float64</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>multiconfig的使用是不是很简单，后续与viper对比后，你会同意我的观点的。</p><p>multiconfig支持默认值，也支持显式的字段赋值需求。<br>支持toml、json、结构体标签（struct tags)以及环境变量。<br>你可以自定义配置源（例如一个远程服务器），如果你想这么做的话。<br>可高度扩展（通过loader接口），你可以创建你自己的loader。</p><p>下面是例子的运行结果，首先是usage help：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$cmdlinemulticonfig -help</span><br><span class="line">Usage of cmdlinemulticonfig:</span><br><span class="line">  -enabled=<span class="literal">false</span>: Change value of Enabled.</span><br><span class="line">  -name=koding: Change value of Name.</span><br><span class="line">  -port=<span class="number">6066</span>: Change value of Port.</span><br><span class="line">  -postgres-availabilityratio=<span class="number">8.23</span>: Change value of Postgres-AvailabilityRatio.</span><br><span class="line">  -postgres-dbname=: Change value of Postgres-DBName.</span><br><span class="line">  -postgres-enabled=<span class="literal">true</span>: Change value of Postgres-Enabled.</span><br><span class="line">  -postgres-hosts=[<span class="number">192.168</span><span class="number">.2</span><span class="number">.1</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.2</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.3</span>]: Change value of Postgres-Hosts.</span><br><span class="line">  -postgres-port=<span class="number">5432</span>: Change value of Postgres-Port.</span><br><span class="line">  -users=[ankara istanbul]: Change value of Users.</span><br><span class="line"></span><br><span class="line">Generated environment variables:</span><br><span class="line">   SERVER_NAME</span><br><span class="line">   SERVER_PORT</span><br><span class="line">   SERVER_ENABLED</span><br><span class="line">   SERVER_USERS</span><br><span class="line">   SERVER_POSTGRES_ENABLED</span><br><span class="line">   SERVER_POSTGRES_PORT</span><br><span class="line">   SERVER_POSTGRES_HOSTS</span><br><span class="line">   SERVER_POSTGRES_DBNAME</span><br><span class="line">   SERVER_POSTGRES_AVAILABILITYRATIO</span><br><span class="line"></span><br><span class="line">$cmdlinemulticonfig</span><br><span class="line">After Loading:</span><br><span class="line">&amp;&#123;Name:koding Port:<span class="number">6066</span> Enabled:<span class="literal">false</span> Users:[ankara istanbul] Postgres:&#123;Enabled:<span class="literal">true</span> Port:<span class="number">5432</span> Hosts:[<span class="number">192.168</span><span class="number">.2</span><span class="number">.1</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.2</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.3</span>] DBName: AvailabilityRatio:<span class="number">8.23</span>&#125;&#125;</span><br><span class="line">Enabled field is set to <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>检查一下输出结果吧，是不是每项都符合我们之前的预期呢！</p><h1 id="Viper"><a href="#Viper" class="headerlink" title="Viper"></a>Viper</h1><p>我们的重量级选手<a href="https://github.com/spf13/viper" target="_blank" rel="noopener">viper</a>该出场了！</p><p>毫无疑问，viper非常强大。但如果你想用命令行参数覆盖预定义的配置项值，viper自己还不足以。要想让viper爆发，你需要另外一个包配合，它就是<a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a>。</p><p>不同于注重简化配置处理的multiconfig，viper让你拥有全面控制力。不幸的是，在得到这种控制力之前，你需要做一些体力活。</p><p>我们再来回顾一下使用multiconfig处理配置的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := multiconfig.NewWithPath(<span class="string">"config.toml"</span>) <span class="comment">// supports TOML and JSON</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get an empty struct for your configuration</span></span><br><span class="line">    serverConf := <span class="built_in">new</span>(Server)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Populated the serverConf struct</span></span><br><span class="line">    m.MustLoad(serverConf) <span class="comment">// Check for error</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"After Loading: "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, serverConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> serverConf.Enabled &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Enabled field is set to true"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Enabled field is set to false"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是使用multiconfig时你要做的所有事情。现在我们来看看使用viper和cobra如何来完成同样的事情：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainCmd.AddCommand(versionCmd)</span><br><span class="line"></span><br><span class="line">    viper.SetEnvPrefix(<span class="string">"DISPATCH"</span>)</span><br><span class="line">    viper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      When AutomaticEnv called, Viper will check for an environment variable any</span></span><br><span class="line"><span class="comment">      time a viper.Get request is made. It will apply the following rules. It</span></span><br><span class="line"><span class="comment">      will check for a environment variable with a name matching the key</span></span><br><span class="line"><span class="comment">      uppercased and prefixed with the EnvPrefix if set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    flags := mainCmd.Flags()</span><br><span class="line"></span><br><span class="line">    flags.Bool(<span class="string">"debug"</span>, <span class="literal">false</span>, <span class="string">"Turn on debugging."</span>)</span><br><span class="line">    flags.String(<span class="string">"addr"</span>, <span class="string">"localhost:5002"</span>, <span class="string">"Address of the service"</span>)</span><br><span class="line">    flags.String(<span class="string">"smtp-addr"</span>, <span class="string">"localhost:25"</span>, <span class="string">"Address of the SMTP server"</span>)</span><br><span class="line">    flags.String(<span class="string">"smtp-user"</span>, <span class="string">""</span>, <span class="string">"User to authenticate with the SMTP server"</span>)</span><br><span class="line">    flags.String(<span class="string">"smtp-password"</span>, <span class="string">""</span>, <span class="string">"Password to authenticate with the SMTP server"</span>)</span><br><span class="line">    flags.String(<span class="string">"email-from"</span>, <span class="string">"noreply@example.com"</span>, <span class="string">"The from email address."</span>)</span><br><span class="line"></span><br><span class="line">    viper.BindPFlag(<span class="string">"debug"</span>, flags.Lookup(<span class="string">"debug"</span>))</span><br><span class="line">    viper.BindPFlag(<span class="string">"addr"</span>, flags.Lookup(<span class="string">"addr"</span>))</span><br><span class="line">    viper.BindPFlag(<span class="string">"smtp_addr"</span>, flags.Lookup(<span class="string">"smtp-addr"</span>))</span><br><span class="line">    viper.BindPFlag(<span class="string">"smtp_user"</span>, flags.Lookup(<span class="string">"smtp-user"</span>))</span><br><span class="line">    viper.BindPFlag(<span class="string">"smtp_password"</span>, flags.Lookup(<span class="string">"smtp-password"</span>))</span><br><span class="line">    viper.BindPFlag(<span class="string">"email_from"</span>, flags.Lookup(<span class="string">"email-from"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Viper supports reading from yaml, toml and/or json files. Viper can</span></span><br><span class="line">  <span class="comment">// search multiple paths. Paths will be searched in the order they are</span></span><br><span class="line">  <span class="comment">// provided. Searches stopped once Config File found.</span></span><br><span class="line"></span><br><span class="line">    viper.SetConfigName(<span class="string">"CommandLineCV"</span>) <span class="comment">// name of config file (without extension)</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">"/tmp"</span>)          <span class="comment">// path to look for the config file in</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">"."</span>)             <span class="comment">// more path to look for the config files</span></span><br><span class="line"></span><br><span class="line">    err := viper.ReadInConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"No config file found. Using built-in defaults."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，你需要使用BindPFlag来让viper和cobra结合一起工作。但这还不算太糟。</p><p>cobra的真正威力在于提供了subcommand能力。同时cobra还提供了与posix 全面兼容的命令行标志解析能力，包括长短标志、内嵌命令、为command定义你自己的help或usage等。</p><p>下面是定义子命令的例子代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The main command describes the service and defaults to printing the</span></span><br><span class="line"><span class="comment">// help message.</span></span><br><span class="line"><span class="keyword">var</span> mainCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">"dispatch"</span>,</span><br><span class="line">    Short: <span class="string">"Event dispatch service."</span>,</span><br><span class="line">    Long:  <span class="string">`HTTP service that consumes events and dispatches them to subscribers.`</span>,</span><br><span class="line">    Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        serve()</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The version command prints this service.</span></span><br><span class="line"><span class="keyword">var</span> versionCmd = &amp;cobra.Command&#123;</span><br><span class="line">    Use:   <span class="string">"version"</span>,</span><br><span class="line">    Short: <span class="string">"Print the version."</span>,</span><br><span class="line">    Long:  <span class="string">"The version of the dispatch service."</span>,</span><br><span class="line">    Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(version)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了上面subcommand的定义，我们就可以得到如下的help信息了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  dispatch [flags]</span><br><span class="line">  dispatch [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  version     Print the version.</span><br><span class="line">  help        Help about any command</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">      –addr="localhost:5002": Address of the service</span><br><span class="line">      –debug=false: Turn on debugging.</span><br><span class="line">      –email-from="noreply@example.com": The from email address.</span><br><span class="line">  -h, –help=false: help for dispatch</span><br><span class="line">      –smtp-addr="localhost:25": Address of the SMTP server</span><br><span class="line">      –smtp-password="": Password to authenticate with the SMTP server</span><br><span class="line">      –smtp-user="": User to authenticate with the SMTP server</span><br><span class="line"></span><br><span class="line">Use "dispatch help [command]" for more information about a command.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;无论使用任何编程语言开发应用，都离不开配置数据。配置数据提供的形式有多样，不外乎命令行选项(options)、参数（parameters)，
      
    
    </summary>
    
      <category term="GO" scheme="http://xichen.pub/categories/GO/"/>
    
    
      <category term="GO" scheme="http://xichen.pub/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>Golang并发</title>
    <link href="http://xichen.pub/2017/08/28/2017-08-28-Golang-concurency/"/>
    <id>http://xichen.pub/2017/08/28/2017-08-28-Golang-concurency/</id>
    <published>2017-08-27T20:19:00.000Z</published>
    <updated>2018-01-05T00:45:28.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行期线程"><a href="#运行期线程" class="headerlink" title="运行期线程"></a>运行期线程</h1><p>Go允许使用go语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。</p><p>Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。</p><p>下面所示程序会输出<code>“Hello from main goroutine”</code>。也可能会输出<code>“Hello from another goroutine”</code>，具体依赖于两个goroutine哪个先结束。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello from another goroutine"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Hello from main goroutine"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 至此，程序运行结束，</span></span><br><span class="line">    <span class="comment">// 所有活跃的goroutine被杀死</span></span><br><span class="line">&#125;</span><br><span class="line">goroutine1.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></p><p>接下来的这个程序，多数情况下，会输出<code>“Hello from main goroutine”</code>和<code>“Hello from another goroutine”</code>，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> fmt.Println(<span class="string">"Hello from another goroutine"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Hello from main goroutine"</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)        <span class="comment">// 等待1秒，等另一个goroutine结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//goroutine2.go</span></span><br></pre></td></tr></table></figure><p>下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数Publish在给定时间过期后打印text字符串到标准输出</span></span><br><span class="line">   <span class="comment">// 该函数并不会阻塞而是立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(<span class="string">"BREAKING NEWS:"</span>, text)</span><br><span class="line">    &#125;()    <span class="comment">// 注意这里的括号。必须调用匿名函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish1.go</span></span><br></pre></td></tr></table></figure></p><p>你可能会这样使用Publish函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Publish(<span class="string">"A goroutine starts a new thread of execution."</span>, <span class="number">5</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Let’s hope the news will published before I leave."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发布新闻</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Ten seconds later: I’m leaving now."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish1.go</span></span><br></pre></td></tr></table></figure></p><p>这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run publish1.go</span><br><span class="line">Let’s hope the news will published before I leave.</span><br><span class="line">BREAKING NEWS: A goroutine starts a new thread of execution.</span><br><span class="line">Ten seconds later: I’m leaving now.</span><br></pre></td></tr></table></figure></p><p>一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。</p><h1 id="管道（channel）"><a href="#管道（channel）" class="headerlink" title="管道（channel）"></a>管道（channel）</h1><p>管道是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> Sushi        <span class="comment">// 可用来发送和接收Sushi类型的值</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>    <span class="comment">// 仅可用来发送float64类型的值</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// 仅可用来接收int类型的值</span></span><br></pre></td></tr></table></figure></p><p>管道是引用类型，基于make函数来分配。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// 不带缓冲的int类型管道</span></span><br><span class="line">wc := <span class="built_in">make</span>(<span class="keyword">chan</span> *Work, <span class="number">10</span>)    <span class="comment">// 带缓冲的Work类型指针管道</span></span><br></pre></td></tr></table></figure></p><p>如果通过管道发送一个值，则将&lt;-作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic &lt;- <span class="number">3</span>        <span class="comment">// 往管道发送3</span></span><br><span class="line">work := &lt;-wc    <span class="comment">// 从管道接收一个指向Work类型值的指针</span></span><br></pre></td></tr></table></figure></p><p>如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><p>关闭管道（Close）</p><p>close 函数标志着不会再往某个管道发送值。在调用close之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Hello!"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-ch)    <span class="comment">// 输出字符串"Hello!"</span></span><br><span class="line">fmt.Println(&lt;-ch)    <span class="comment">// 输出零值 - 空字符串""，不会阻塞</span></span><br><span class="line">fmt.Println(&lt;-ch)    <span class="comment">// 再次打印输出空字符串""</span></span><br><span class="line">v, ok := &lt;-ch        <span class="comment">// 变量v的值为空字符串""，变量ok的值为false</span></span><br></pre></td></tr></table></figure></p><p>一个带有range子句的for语句会依次读取发往管道的值，直到该管道关闭：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string</span></span><br><span class="line">    <span class="keyword">var</span> ch &lt;-<span class="keyword">chan</span> Sushi = Producer()</span><br><span class="line">    <span class="keyword">for</span> s := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Consumed"</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Sushi</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Sushi)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ch &lt;- Sushi(<span class="string">"海老握り"</span>)    <span class="comment">// Ebi nigiri</span></span><br><span class="line">        ch &lt;- Sushi(<span class="string">"鮪とろ握り"</span>) <span class="comment">// Toro nigiri</span></span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sushi.go</span></span><br></pre></td></tr></table></figure></p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>下一个示例中，我们让Publish函数返回一个管道 - 用于在发布text变量值时广播一条消息：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定时间过期时，Publish函数会打印text变量值到标准输出</span></span><br><span class="line"><span class="comment">// 在text变量值发布后，该函数会关闭管道wait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span> <span class="params">(wait &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(<span class="string">"BREAKING NEWS:"</span>, text)</span><br><span class="line">        <span class="built_in">close</span>(ch)    <span class="comment">// 广播 - 一个关闭的管道都会发送一个零值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish2.go</span></span><br></pre></td></tr></table></figure></p><p>注意：我们使用了一个空结构体的管道：struct{}。这明确地指明该管道仅用于发信号，而不是传递数据。</p><p>我们可能会这样使用这个函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := Publish(<span class="string">"Channels let goroutines communicate."</span>, <span class="number">5</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Waiting for the news..."</span>)</span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(<span class="string">"The news is out, time to leave."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//publish2.go</span></span><br></pre></td></tr></table></figure></p><p>这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run publish2.go</span></span><br><span class="line">Waiting for the news...</span><br><span class="line">BREAKING NEWS: Channels let goroutines communicate.</span><br><span class="line">The news is out, time to leave.</span><br></pre></td></tr></table></figure></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>现在我们在Publish函数中引入一个bug：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Publish</span><span class="params">(text <span class="keyword">string</span>, delay time.Duration)</span> <span class="params">(wait &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(delay)</span><br><span class="line">        fmt.Println(<span class="string">"BREAKING NEWS:"</span>, text)</span><br><span class="line">        <span class="comment">// 译注：注意这里将close函数调用注释掉了</span></span><br><span class="line">        <span class="comment">//close(ch)</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时Publish函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := Publish(<span class="string">"Channels let goroutines communicate."</span>, <span class="number">5</span>*time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Waiting for the news..."</span>)</span><br><span class="line">    <span class="comment">// 译注：注意下面这一句</span></span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(<span class="string">"The news is out, time to leave."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。</p><blockquote><p>死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。</p></blockquote><p>Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Waiting for the news...</span><br><span class="line">BREAKING NEWS: Channels let goroutines communicate.</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan receive]:</span><br><span class="line">main.main()</span><br><span class="line">    .../goroutineStop.go:11 +0xf6</span><br><span class="line"></span><br><span class="line">goroutine 2 [syscall]:</span><br><span class="line">created by runtime.main</span><br><span class="line">    .../go/src/pkg/runtime/proc.c:225</span><br><span class="line"></span><br><span class="line">goroutine 4 [timer goroutine (idle)]:</span><br><span class="line">created by addtimer</span><br><span class="line">    .../go/src/pkg/runtime/ztime_linux_amd64.c:73</span><br></pre></td></tr></table></figure></p><p>大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。</p><h1 id="数据竞争（data-race）"><a href="#数据竞争（data-race）" class="headerlink" title="数据竞争（data race）"></a>数据竞争（data race）</h1><p>死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。</p><blockquote><p>当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。</p></blockquote><p>下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 译注：注意下面这一行</span></span><br><span class="line">        n++ <span class="comment">// 一次访问: 读, 递增, 写</span></span><br><span class="line">        <span class="built_in">close</span>(wait)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 译注：注意下面这一行</span></span><br><span class="line">    n++ <span class="comment">// 另一次冲突的访问</span></span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(n) <span class="comment">// 输出：未指定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//datarace.go</span></span><br></pre></td></tr></table></figure></p><p>代码中的两个goroutine（假设命名为g1和g2）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g1 从 n 中获取值<span class="number">0</span></span><br><span class="line">g2 从 n 中获取值<span class="number">0</span></span><br><span class="line">g1 将值从<span class="number">0</span>增大到<span class="number">1</span></span><br><span class="line">g1 将<span class="number">1</span>写到 n</span><br><span class="line">g2 将值从<span class="number">0</span>增大到<span class="number">1</span></span><br><span class="line">g2 将<span class="number">1</span>写到 n</span><br><span class="line">程序输出 n 的值，当前为<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>“数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样：</p><p>避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（sync和sync/atomic包中还有更低层次的机制可供使用，但本文中不做讨论）。</p><p>Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sharingIsCaring</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        n := <span class="number">0</span> <span class="comment">// 仅为一个goroutine可见的局部变量.</span></span><br><span class="line">        n++</span><br><span class="line">        ch &lt;- n <span class="comment">// 数据从一个goroutine离开...</span></span><br><span class="line">    &#125;()</span><br><span class="line">    n := &lt;-ch   <span class="comment">// ...然后安全到达另一个goroutine.</span></span><br><span class="line">    n++</span><br><span class="line">    fmt.Println(n) <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//datarace.go</span></span><br></pre></td></tr></table></figure></p><p>以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。</p><blockquote><p>Go语言内存模型 - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。</p></blockquote><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - sync.Mutex。</p><p>要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。</p><p>因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，AtomicInt，用于存储一个整型值。任意数量的goroutine都能通过Add和Value方法安全地访问这个数值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInt是一个并发数据结构，持有一个整数值</span></span><br><span class="line"><span class="comment">// 该数据结构的零值为0</span></span><br><span class="line"><span class="keyword">type</span> AtomicInt <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex <span class="comment">// 锁，一次仅能被一个goroutine持有。</span></span><br><span class="line">    n  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add方法作为一个原子操作将n加到AtomicInt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicInt)</span> <span class="title">Add</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a.mu.Lock() <span class="comment">// 等待锁释放，然后持有它</span></span><br><span class="line">    a.n += n</span><br><span class="line">    a.mu.Unlock() <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value方法返回a的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicInt)</span> <span class="title">Value</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a.mu.Lock()</span><br><span class="line">    n := a.n</span><br><span class="line">    a.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lockItUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wait := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> n AtomicInt</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        n.Add(<span class="number">1</span>) <span class="comment">// 一个访问</span></span><br><span class="line">        <span class="built_in">close</span>(wait)</span><br><span class="line">    &#125;()</span><br><span class="line">    n.Add(<span class="number">1</span>) <span class="comment">// 另一个并发访问</span></span><br><span class="line">    &lt;-wait</span><br><span class="line">    fmt.Println(n.Value()) <span class="comment">// 输出: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//datarace.go</span></span><br></pre></td></tr></table></figure></p><h1 id="检测数据竞争"><a href="#检测数据竞争" class="headerlink" title="检测数据竞争"></a>检测数据竞争</h1><p>竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出55555。尝试一下，也许你会得到一个不同的结果。（sync.WaitGroup是Go语言标准库的一部分；用于等待一组goroutine结束运行。）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">race</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 译注：注意下面这行代码中的i++</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 注意下一行代码会输出什么？为什么？</span></span><br><span class="line">            fmt.Print(i) <span class="comment">// 6个goroutine共享变量i</span></span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有（5个）goroutine运行结束</span></span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raceClosure.go</span></span><br></pre></td></tr></table></figure></p><p>对于输出55555，一个貌似合理的解释是：执行i++的goroutine在其他goroutine执行打印语句之前就完成了5次i++操作。实际上变量i更新后的值为其他goroutine所见纯属巧合。</p><p>一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">correct</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123; <span class="comment">// 使用局部变量</span></span><br><span class="line">            fmt.Print(n)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raceClosure.go</span></span><br></pre></td></tr></table></figure></p><p>这次代码就对了，程序会输出期望的结果，如：24031。注意：goroutine之间的运行顺序是不确定的。</p><p>仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alsoCorrect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        n := i <span class="comment">// 为每个闭包创建一个独有的变量</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(n)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//raceClosure.go</span></span><br></pre></td></tr></table></figure></p><h2 id="数据竞争自动检测"><a href="#数据竞争自动检测" class="headerlink" title="数据竞争自动检测"></a>数据竞争自动检测</h2><p>一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的数据竞争检测器。</p><p>这个工具用起来也很简单：只要在使用go命令时加上-race标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run -race raceClosure.go</span></span><br><span class="line">Race:</span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Read by goroutine 2:</span><br><span class="line">    main.func·001()</span><br><span class="line">      ../raceClosure.go:22 +0x65</span><br><span class="line"></span><br><span class="line">Previous write by goroutine 0:</span><br><span class="line">    main.race()</span><br><span class="line">        ../raceClosure.go:20 +0x19b</span><br><span class="line">    main.main()</span><br><span class="line">        ../raceClosure.go:10 +0x29</span><br><span class="line">    runtime.main()</span><br><span class="line">        ../go/src/pkg/runtime/proc.c:248 +0x91</span><br><span class="line"></span><br><span class="line">Goroutine 2 (running) created at:</span><br><span class="line">    main.race()</span><br><span class="line">      ../raceClosure.go:24 +0x18b</span><br><span class="line">    main.main()</span><br><span class="line">      ../raceClosure.go:10 +0x29</span><br><span class="line">     runtime.main()</span><br><span class="line">      ../go/src/pkg/runtime/proc.c:248 +0x91</span><br><span class="line"></span><br><span class="line">==================</span><br><span class="line">55555</span><br><span class="line">Correct:</span><br><span class="line">01234</span><br><span class="line">Also correct:</span><br><span class="line">01324</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure></p><p>该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。</p><p>注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导）</p><h1 id="Select语句"><a href="#Select语句" class="headerlink" title="Select语句"></a>Select语句</h1><p>select语句是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。</p><p>以下是一个玩具示例，演示select语句如何用于实现一个随机数生成器：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RandomBits函数 返回一个管道，用于产生一个比特随机序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandomBits</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- <span class="number">0</span>: <span class="comment">// 注意：分支没有对应的处理语句</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//randBits.go</span></span><br></pre></td></tr></table></figure></p><p>下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> news := &lt;-NewsAgency:</span><br><span class="line">    fmt.Println(news)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Minute):</span><br><span class="line">    fmt.Println(<span class="string">"Time out: no news in one minute."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数 time.After 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。</p><h1 id="综合所有示例"><a href="#综合所有示例" class="headerlink" title="综合所有示例"></a>综合所有示例</h1><p>花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。</p><p>这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []<span class="keyword">string</span>&#123;<span class="string">"Anna"</span>, <span class="string">"Bob"</span>, <span class="string">"Cody"</span>, <span class="string">"Dave"</span>, <span class="string">"Eva"</span>&#125;</span><br><span class="line">    match := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>) <span class="comment">// 为一个未匹配的发送操作提供空间</span></span><br><span class="line">    wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(people))</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> people &#123;</span><br><span class="line">        <span class="keyword">go</span> Seek(name, match, wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> name := &lt;-match:</span><br><span class="line">        fmt.Printf(<span class="string">"No one received %s’s message.\n"</span>, name)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 没有待处理的发送操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Seek</span><span class="params">(name <span class="keyword">string</span>, match <span class="keyword">chan</span> <span class="keyword">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> peer := &lt;-match:</span><br><span class="line">        fmt.Printf(<span class="string">"%s sent a message to %s.\n"</span>, peer, name)</span><br><span class="line">    <span class="keyword">case</span> match &lt;- name:</span><br><span class="line">        <span class="comment">// 等待某个goroutine接收我的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//matching.go</span></span><br></pre></td></tr></table></figure></p><p>示例输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run matching.go</span></span><br><span class="line">Cody sent a message to Bob.</span><br><span class="line">Anna sent a message to Eva.</span><br><span class="line">No one received Dave’s message.</span><br></pre></td></tr></table></figure></p><h1 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h1><p>并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。</p><p>将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则：</p><ul><li>每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的）</li><li>尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。</li><li>数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。</li><li>下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector []<span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k</span></span><br><span class="line"><span class="comment">// 先决条件：len(u) &gt; 0, len(v) &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convolve</span><span class="params">(u, v Vector)</span> <span class="params">(w Vector)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(u) + <span class="built_in">len</span>(v) - <span class="number">1</span></span><br><span class="line">    w = <span class="built_in">make</span>(Vector, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; n; k++ &#123;</span><br><span class="line">        w[k] = mul(u, v, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数mul 返回 Σ u[i]*v[j], i + j = k.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(u, v Vector, k <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    n := min(k+<span class="number">1</span>, <span class="built_in">len</span>(u))</span><br><span class="line">    j := min(k, <span class="built_in">len</span>(v)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := k - j; i &lt; n; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        res += u[i] * v[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 Convolve：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convolve</span><span class="params">(u, v Vector)</span> <span class="params">(w Vector)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(u) + <span class="built_in">len</span>(v) - <span class="number">1</span></span><br><span class="line">    w = <span class="built_in">make</span>(Vector, n)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元</span></span><br><span class="line">    size := max(<span class="number">1</span>, <span class="number">1</span>&lt;&lt;<span class="number">20</span>/n)</span><br><span class="line"></span><br><span class="line">    wg := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line">    wg.Add(<span class="number">1</span> + (n<span class="number">-1</span>)/size)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n &amp;&amp; i &gt;= <span class="number">0</span>; i += size &#123; <span class="comment">// 整型溢出后 i &lt; 0</span></span><br><span class="line">        j := i + size</span><br><span class="line">        <span class="keyword">if</span> j &gt; n || j &lt; <span class="number">0</span> &#123; <span class="comment">// 整型溢出后 j &lt; 0</span></span><br><span class="line">            j = n</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这些goroutine共享内存，但是只读</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">                w[k] = mul(u, v, k)</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i, j)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convolution.go</span></span><br></pre></td></tr></table></figure></p><p>工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numcpu := runtime.NumCPU()</span><br><span class="line">    runtime.GOMAXPROCS(numcpu) <span class="comment">// 尝试使用所有可用的CPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运行期线程&quot;&gt;&lt;a href=&quot;#运行期线程&quot; class=&quot;headerlink&quot; title=&quot;运行期线程&quot;&gt;&lt;/a&gt;运行期线程&lt;/h1&gt;&lt;p&gt;Go允许使用go语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的goroutine来执行一
      
    
    </summary>
    
      <category term="GO" scheme="http://xichen.pub/categories/GO/"/>
    
    
      <category term="GO" scheme="http://xichen.pub/tags/GO/"/>
    
  </entry>
  
</feed>
