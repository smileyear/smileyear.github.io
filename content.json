{"meta":{"title":"XiChen","subtitle":"He who thinks wins","description":"嗨，我是兮尘，全栈数据学徒。这里没有花俏艳丽的魔法，没有苍蛮霸道的斗气，有的，仅仅是繁衍到巅峰的代码！","author":"Lin Xueyuan","url":"http://xichen.pub"},"pages":[{"title":"关于","date":"2018-01-19T18:21:04.071Z","updated":"2018-01-19T18:21:04.071Z","comments":true,"path":"about/index.html","permalink":"http://xichen.pub/about/index.html","excerpt":"","text":"大家好，我是XXX。欢迎来到我的个人技术博客。 这里用markdown写下你的简介，就跟平时写md一样就可以了。"},{"title":"读书","date":"2018-01-19T18:21:04.073Z","updated":"2018-01-19T18:21:04.073Z","comments":true,"path":"reading/index.html","permalink":"http://xichen.pub/reading/index.html","excerpt":"","text":""},{"title":"Apps","date":"2018-01-20T04:28:46.039Z","updated":"2018-01-20T04:28:46.039Z","comments":true,"path":"apps/index.html","permalink":"http://xichen.pub/apps/index.html","excerpt":"","text":"FlappyBird在web端实现了Flappy Bird，并用神经网络作为后端，使小鸟自进化 generate-girls用GAN(对抗生成网络)生成动漫头像 preview可直接加载渲染Github上的html文件，而不需要搞出网站 robot-dance机器人跳舞，甩飞会变成巨人"}],"posts":[{"title":"latex（二）完全卸载","slug":"2017-12-28-latex（二）完全卸载","date":"2017-12-28T14:16:00.000Z","updated":"2018-01-20T08:45:52.682Z","comments":true,"path":"2017/12/28/2017-12-28-latex（二）完全卸载/","link":"","permalink":"http://xichen.pub/2017/12/28/2017-12-28-latex（二）完全卸载/","excerpt":"","text":"sudo apt-get purge texlive* rm -rf /usr/local/texlive/* and rm -rf ~/.texlive* rm -rf /usr/local/share/texmf rm -rf /var/lib/texmf rm -rf /etc/texmf sudo apt-get remove tex-common --purge rm -rf ~/.texlive find -L /usr/local/bin/ -lname /usr/local/texlive/*/bin/* | xargs rm This finds all the files in /usr/local/bin which point to a location within /usr/local/texlive/*/bin/* and removes them; because we’ve already deleted all of /usr/local/texlive, these are dead links. To see which files are being deleted, replace xargs rm with xargs -t rm (or tee off to a log file, or whatever).","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"http://xichen.pub/tags/latex/"}]},{"title":"latex（一）安装与配置","slug":"2017-12-12-latex（一）安装与配置","date":"2017-12-12T14:16:00.000Z","updated":"2018-01-05T00:45:28.296Z","comments":true,"path":"2017/12/12/2017-12-12-latex（一）安装与配置/","link":"","permalink":"http://xichen.pub/2017/12/12/2017-12-12-latex（一）安装与配置/","excerpt":"","text":"2017年不到20天就到2018年了，才开始把latex用在写论文上。原来只是学了用latex写公式，嫌latex的配置太麻烦，总想拿mardown结合latex搞事情，结果啥也没做到。只好亲自入用latex编译论文的坑了。 latex就是为写论文带来便利。一定不能在安装和配置上花太多时间，不然就舍本逐末了。 Linux 发行版下原版 TeX Live 2017 的安装 在安装前，TeX Live 2017 的手册可以在 TUG 的 TeX Live 目录下找到：https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf。可以先阅读其中的安装部分。在 Linux 上安装原版 TeX Live 2017，与在 Windows 等其他系统下安装并无区别。可以从 CTAN 镜象下载 ISO 文件，然后挂载到一个目录下，运行里面的 install-tl 脚本进行安装；也可以在 CTAN 的网站上只下载 install-tl 脚本运行，在线安装。install-tl 是一个 Perl 脚本，在绝大多数发行版下都可以直接运行。 安装通过系统仓库首先，对于 Arch 等滚动更新发行版的用户来说，推荐使用官方仓库来安装。 1sudo pacman -S texlive-most texlive-lang 但是 Debian/Ubuntu 等的软件源往往会比较旧，为了体验最新的 TeX Live （虽然并没有什么卵差别），因此还是要用 ISO 映像安装。 通过iso文件下载 官方镜像: texlive2017.iso XJTU 镜像: texlive2017.iso（校内用户请选择该源） USTC 镜像: texlive2017.iso（校内用户请选择该源） 镜像站目录里的 texlive.iso 就是最新的 texlive2017.iso。 下载完成后可以选择进行校验避免出错，具体来说镜像站目录里会有 md5 和 sha512 两个 hash 文件以及一个 GPG 签名文件。TeX Live 2016 以后调整了基础架构，安装时会校验包的完整性，如果有 GPG 还会校验⽹络更新的签名。 12345678# GnuPG 校验签名，不懂请跳过，根据我的校验应当无误gpg --verify texlive2017.iso.sha512.asc# MD5 校验md5sum texlive2017.iso# SHA-512 校验sha512sum texlive2017.iso# 与官方提供的 Hash 对比cat texlive2017.iso.md5 texlive2017.iso.sha512 准备如果之前系统里已经装过 TeX Live，建议先删除。 对于 Linux 来说比较简单，只需要把安装目录（默认为 /usr/local/texlive 里的文件夹丢进 trash 即可），此外用户目录里修改过的一些配置也不要忘记。 如果想把有关依赖也卸载了，参考下一篇blog 如果是包管理安装的方式，例如 Ubuntu 用户，可以按照这样卸载： 1sudo apt-get purge texlive* 因为 TeX Live 里的安装脚本是 Perl 写的，如果稍后要用图形界面安装，需要更新下依赖。 12345678# Debian/Ubuntusudo apt-get install perl-tk# CentOS/Fedora/RHELsudo yum install perl-Tk# Fedora 22+sudo dnf install perl-Tk# OpenSUSEsudo zypper install perl-tk 安装如果能借助软件或文管等方式解决映像挂载问题就直接跳过，否则就在下载好的镜像目录执行以下命令安装： 123456sudo mount -o loop texlive2017.iso /mntcd /mnt# 在 shell 里直接安装sudo ./install-tl# 以 GUI 方式安装sudo ./install-tl -gui=perltk 图形界面大概长这样： 图形界面 默认是安装在 /usr/local/texlive 目录下，可以更改为 /home 等，否则无脑下一步即可。 根据硬件性能不同，安装过程一般不会短于 3 分钟。 安装过程 安装结束后可以卸载映像。 12cd ~sudo umount /mnt 通过命令行边下载边安装去这里https://www.tug.org/texlive/找对应的安装包，我下载的是install-tl-unx.tar.gz。 下载完后，随便找个临时目录解压。 默认是安装在 /usr/local/texlive/ 路径下，需要以超级用户权限安装，在解压下的目录运行1sudo ./install-tl 然后在文本界面下按提示进行交互式安装。当然，也可以安装在本地的用户路径下（如 ~/texlive/），这样就不再需要特殊权限。 如果是进行网络安装，默认会自动选择一个 CTAN 镜象。 这种方法在国内安装很慢，1h才下300多个文件。 国内往往需要用 -repository 选项手工指定镜象服务器地址，URL 地址需要指定到 texlive/tlnet/ 路径下。 推荐用清华的镜象：1sudo ./install-tl -repository http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/ 这种方法安装快，1h轻松安装完毕。 更方便的方式则是在图形界面下进行安装，此时需要确保系统安装了 perl-tk 等相关 Perl 图形界面库。运行命令 1sudo ./install-tl -gui 即可按界面中的提示安装。或者运行 1sudo ./install-tl -gui=wizard 使用图形界面的安装向导，向导方式比前面的方式配置项少一些，但更容易使用。 不过没啥用。还是建议用清华镜像那个命令快一点，不需要这么花俏。 修改环境变量，使编辑器等能找到texlive对于 bash 等 Bourne 兼容的 shell，在用户目录的 ~/.bashrc 文件中添加一些环境变量，具体路径由安装的位置确定。 12345# TeX Live 2017export PATH=$&#123;PATH&#125;:/usr/local/texlive/2017/bin/x86_64-linux# 如果是32位最后改为'i386-linux'export MANPATH=$&#123;MANPATH&#125;:/usr/local/texlive/2017/texmf-dist/doc/manexport INFOPATH=$&#123;INFOPATH&#125;:/usr/local/texlive/2017/texmf-dist/doc/info 如果是 csh 或 tcsh，则在 ~/.cshrc 中添加内容。 1234# TeX Live 2017setenv PATH /usr/local/texlive/2017/bin/x86_64-linux:$PATHsetenv MANPATH /usr/local/texlive/2017/texmf-dist/doc/man:$MANPATHsetenv INFOPATH /usr/local/texlive/2017/texmf-dist/doc/info:$INFOPATH 对于 Debian/Ubuntu 用户，可以安装下我根据 官方说明 制作的 texlive-local_2017-1_all.deb 来申明下包管理里的依赖关系，避免版本冲突。 123sudo dpkg -i texlive-local_2017-1_all.deb# 显示安装的 TeX Live 版本信息dpkg -l | grep texlive-local 至于其他发行版的 texlive-dummy 可去 CTAN 搜索。 测试安装完成后，如果一切都设置好，那么运行以下一些简单测试命令，在当前目录应该会得到正确的输出，如果有命令报错，请自行解决。 12345678910# 显示 TeX 版本应为 3.14159265tex --version# 处理一个基本文件，显示无法找到说明环境变量设置有误latex sample2e.tex# 预览上一步得到的 dvi 文件xdvi sample2e.dvi# pdfTeX 编译直接输出一份 PDFpdftex sample2e.tex# 测试 XeTeX 能否访问系统字体xetex opentype-info.tex 安装之后就可以使用 texdoc 命令阅读安装在本地手册了，对 TeX Live 不甚熟悉的用户最好运行 1texdoc texlive-zh 命令再次阅读 TeX Live 2017 的手册。 更新TeX Live 的更新工具 tlmgr（TeX Live Manager）图形性能比较差，特别是在 Windows 上，故推荐终端里直接更新。 12345678# tlmgr 只能在 root 权限下运行su# 更新 tlmgr 宏包管理器tlmgr update -self# 更新所有宏包tlmgr update -all# 官方的 CTAN 镜像源速度可能比较慢，校内用户推荐换成 XJTU，支持 http 或 httpstlmgr update -all -repository https://mirrors.xjtu.edu.cn/CTAN/systems/texlive/tlnet/ 如果钟爱图形界面，带上 -gui 参数即可。校内用户记得把默认软件包仓库改为 XJTU 的镜像源地址。 123su# 指定图形界面语言为中文tlmgr -gui -gui-lang zh_CN 其它 关于 Linux 上的编辑器，理论上只要是文本编辑器均可。由于可选择的方案太多，取决于个人的使用习惯，这里只推荐两个适合入门的自由软件 Texmaker 和 TeXstudio（fork 自前者）。 关于 Linux 上的字体，因为版权问题，所以 Times New Roman 和宋体就成了很多 LaTeX 初学者的困扰。 推荐的办法是 ctex 宏集处理中文，使用 Fandol 开源字体，默认效果好于 Windows 的中易宋体，另外也可使用思源宋体；而西文和数学字符则用 mathptmx 或 newtx 宏包处理，使用开源的 Nimbus Roman No9 L 字体代替 Times New Roman，差别不大。 对字体有严格要求，可以复制 Windows 下的字体到 ~/.fonts 目录下，记得用 fc-cache -fsv 命令更新下字体缓存。 关于 LaTeX 教程或者说手册，推荐两本 包太雷的 lnotes2 和 lshort 中文版。 配置按照 TeX Live 手册的说明，安装之后，还有一些工作需要做： 如果在安装时没有选择在系统目录为可执行文件创建符号链接，就需要手工修改 ~/.profile 文件设置 PATH 环境变量。 export MANPATH=”/usr/local/texlive/2017/texmf-dist/doc/man” export INFOPATH=”/usr/local/texlive/2017/texmf-dist/doc/info” export PATH=”/usr/local/texlive/2017/bin/x86_64-linux:$PATH” XeTeX 会使用 fontconfig 库来通过字体名搜索字体。TeX Live 的字体目录默认并不在 fongconfig 的搜索目录之列，因此需要按文档要求，将 TeX Live 安装目录下的 texmf-var/fonts/conf/texlive-fontconfig.conf 文件，复制到 /etc/fonts/conf.d/09-texlive.conf，然后运行 fc-cache，以确保 XeTeX 能搜索到字体。否则，TeX Live 自带的 OpenType 字体就只能以字体文件名的方式调用，非常不便。此外这样也能让系统的其他软件使用 TeX Live 安装的字体。 建议先复制到临时文件夹，改名后，再sudo mv 如果需要以字体文件名调用 Linux 系统安装的字体，例如使用 CJK 宏包调用来自 Windows 的字体，那么还需要修改 TeX Live 安装目录的 texmf.cnf 文件，在其中设置 OSFONTDIR 变量，例如： 1OSFONTDIR = ~/.fonts//;/usr/share/fonts//;/usr/share/fonts-droid// 可能需要用sudo gedit texmf.cnf才修改得了。当然，这一步骤对多数用户的用处并不大。 在/usr/bin/目录下创建符号链接才能用pdflatex进行编译1sudo ln -s /usr/local/texlive/2017/bin/x86_64-linux/pdflatex pdflatex 安装LaTeX编辑器：TeXstudio去官网下deb包然后安装：1sudo dpkg -i XXX.deb 打开TeXstudio，在倒数第二个选项(o)配置一下。首先配置语言为中文，然后编译器选pdflatex，其他的千万不要动。 配置语言为中文 编译器选pdflatex 其他宏包XeLatexXeLatex 是 texlive-xetex 包的一部分，用来支持中文。安装的话需要运行1sudo apt-get install texlive-xetex 加上依赖有1G大小。","categories":[],"tags":[{"name":"latex","slug":"latex","permalink":"http://xichen.pub/tags/latex/"}]},{"title":"Web App 相关技术","slug":"2017-12-10-web-app","date":"2017-12-10T06:06:05.000Z","updated":"2018-01-05T05:03:59.281Z","comments":true,"path":"2017/12/10/2017-12-10-web-app/","link":"","permalink":"http://xichen.pub/2017/12/10/2017-12-10-web-app/","excerpt":"","text":"把技能点点在移动前端… 概念 参考： 移动 Web 开发入门 上面这个 slide 资料讲的非常好，算是一个入门的介绍吧。带我们建立基本的移动 web 开发知识体系和常见问题的实践。包含以下几个方面： 基本概念 Native 本地应用 使用 Java \\ Objective-C \\ Swift 开发 WebApp 网页应用 html5 开发 Hybrid 混合应用 ooxx(native, web) 对比 视觉 设备的像素 文字单位使用 rem viewport 属性 横屏竖屏 Flex 伸缩布局 响应式设计 软键盘 隐藏地址栏 苹果设备添加到主屏图标 交互 Touch click 延迟 Scroll Gestures(hammer –A javascript library for multi-touch gestures) 手指友好设计 HTML5 APIS（图像，摇动，声音等） 实践 屏蔽点击元素时的阴影 图像（像素、矢量图标、base64 减少请求、lazyload） CSS3（合理使用渐变/圆角/阴影、代替 js 动画、translate3d、解决动画闪烁） localStorage 避免（iframe、fixed + input） SPA 或 Multi page can I use 压缩合并 @G/3G 下建立连接时间 调试 浏览器自己的调试工具，模拟手机设备 weinre 关于 weinre 我写了一篇博客介绍它。Weinre –WebApp 调试工具 head 标签参考： 移动前端不得不了解的html5 head 头标签 上面的链接详细的讲解了： DOCTYPE charset lang属性 优先使用 IE 最新版本和 Chrome 360 使用Google Chrome Frame SEO 优化部分：页面标题&lt;title&gt;标签(head 头部必须)，页面关键词 keywords，页面描述内容 description，定义网页作者 author，网页搜索引擎索引方式 为移动设备添加 viewport viewport 可以让布局在移动浏览器上显示的更好。 通常会写 12&lt;meta name =\"viewport\" content =\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; content 参数： width viewport 宽度(数值/device-width) height viewport 高度(数值/device-height) initial-scale 初始缩放比例 maximum-scale 最大缩放比例 minimum-scale 最小缩放比例 user-scalable 是否允许用户缩放(yes/no) ios 设备，iOS 图标，Android，Windows 8 总结： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;&lt;html lang=\"zh-cmn-Hans\"&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;&lt;head&gt; &lt;!-- 声明文档使用的字符编码 --&gt; &lt;meta charset='utf-8'&gt; &lt;!-- 优先使用 IE 最新版本和 Chrome --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; &lt;!-- 页面描述 --&gt; &lt;meta name=\"description\" content=\"不超过150个字符\"/&gt; &lt;!-- 页面关键词 --&gt; &lt;meta name=\"keywords\" content=\"\"/&gt; &lt;!-- 网页作者 --&gt; &lt;meta name=\"author\" content=\"name, email@gmail.com\"/&gt; &lt;!-- 搜索引擎抓取 --&gt; &lt;meta name=\"robots\" content=\"index,follow\"/&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no\"&gt; &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 http://bigc.at/ios-webapp-viewport-meta.orz --&gt; &lt;!-- iOS 设备 begin --&gt; &lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt; &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/&gt; &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt; &lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; &lt;!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） --&gt; &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/&gt; &lt;!-- 设置苹果工具栏颜色 --&gt; &lt;meta name=\"format-detection\" content=\"telphone=no, email=no\"/&gt; &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt; &lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt; &lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; &lt;!-- 微软的老式浏览器 --&gt; &lt;meta name=\"MobileOptimized\" content=\"320\"&gt; &lt;!-- uc强制竖屏 --&gt; &lt;meta name=\"screen-orientation\" content=\"portrait\"&gt; &lt;!-- QQ强制竖屏 --&gt; &lt;meta name=\"x5-orientation\" content=\"portrait\"&gt; &lt;!-- UC强制全屏 --&gt; &lt;meta name=\"full-screen\" content=\"yes\"&gt; &lt;!-- QQ强制全屏 --&gt; &lt;meta name=\"x5-fullscreen\" content=\"true\"&gt; &lt;!-- UC应用模式 --&gt; &lt;meta name=\"browsermode\" content=\"application\"&gt; &lt;!-- QQ应用模式 --&gt; &lt;meta name=\"x5-page-mode\" content=\"app\"&gt; &lt;!-- windows phone 点击无高光 --&gt; &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; &lt;!-- iOS 图标 begin --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/&gt; &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/&gt; &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/&gt; &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt; &lt;!-- iOS 图标 end --&gt; &lt;!-- iOS 启动画面 begin --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/&gt; &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/&gt; &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/&gt; &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/&gt; &lt;!-- iPad 横屏 2048x1496（Retina） --&gt; &lt;link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/&gt; &lt;!-- iPhone/iPod Touch 竖屏 640x960 (Retina) --&gt; &lt;link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/&gt; &lt;!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) --&gt; &lt;!-- iOS 启动画面 end --&gt; &lt;!-- iOS 设备 end --&gt; &lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt; &lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/&gt; &lt;!-- 添加 RSS 订阅 --&gt; &lt;link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/&gt; &lt;!-- 添加 favicon icon --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面切换动画 移动端重构系列13——页面切换 CSS3 3D Transform 关于 HammerJS 的一个中文文档 Hammer.js CSS Processing CSS语言由于其自身语言设计的问题，加上一些浏览器兼容性问题，往往会使得我们在写它的时候，要写很多冗余代码，或者为了兼容性对同一个样式设定写好几遍。针对这些问题，诞生了CSS预处理和后处理的概念及相关方法、工具。 这些工具和方法帮助我们能够更加高效地书写可维护性更强的CSS代码。 这里我尝试使用了 Sass，果然很好用。下面记录几个 sass 教程。 Sass入门-w3cplus SASS用法指南-阮一峰 安装首先要有 ruby 环境。 由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的 https://rubygems.org 源，然后添加淘宝的源 https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了。 $ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org $ gem install sass 编译sass --watch style.scss:style.css --style expanded 补充rem 字体单位使用 rem，用户在手机上设置了字体大小时，不会打破布局，造成混乱。 CSS3的REM设置字体大小-w3cplus 响应式十日谈第一日：使用 rem 设置文字大小-一丝 安全 安全是大家经常容易忽视，但其实一旦出现影响会非常大的问题，尤其对于没有经历过企业开发，或者没有踩过坑的同学，如果等到公司工作，做实际项目后非常容易发生安全问题。 分类WEB基本攻击大致可以分为三大类：“资源枚举”、“参数操纵” 和 “其它攻击” 资源枚举 参数操纵 SQL注入 XPath注入 cgi命令执行 XXS（cross-site scripting跨域脚本攻击）其重点是“跨域”和“客户端执行” Reflected XSS ——基于反射的XSS攻击。主要依靠站点服务端返回脚本，在客户端触发执行从而发起WEB攻击。 DOM-based or local XSS——基于DOM或本地的XSS攻击 Stored XSS——基于存储的XSS攻击 会话劫持 其它攻击 CSRF（cross-site request forgery）跨站请求伪造 钓鱼攻击指的是网站的伪造，比如ta0bao.com，然后在其中应用XSS等方式发起攻击。 拒绝服务（DoS）指的是向网站发起洪水一样的请求（Traffic Floor），导致服务器超负荷并关闭，处理方法常规是采用QoS（Quality of Service）的软硬件解决方案。 关于 XSS 跨网站脚本（Cross-site scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 ——维基百科 XSS 防护 浏览器解析顺序： HTML Parser &gt;&gt; CSS Parser &gt;&gt; JavaScript Parser 浏览器解码顺序： HTML Decoding &gt;&gt; URL Decoding &gt;&gt; JavaScript Decoding 具体的防护方式： 验证输入并且基于语境和按照正确的顺序转义不可信数据 HTML 中的字符串 HTML 属性中的字符串 事件句柄属性和 JavaScript 中的字符串 HTML 属性中的 URL 路径 HTML 风格属性和 CSS 中的字符串 JavaScript 中的 HTML 始终遵循白名单优于黑名单的做法 使用 UTF-8 为默认的字符编码以及设置 content 为 text/html 不要将用户可以控制的文本放在标签前。通过使用不同的字符集注射可以导致 XSS。 使用 &lt;!DOCTYPE html&gt; 使用推荐的 HTTP 响应头进行 XSS 防护 防止 CRLF 注入/HTTP 响应拆分 禁止 TRACE 和其他非必要方法 对于 innerHTML 的方式输出的，我们可以采用如下的方式转码 1234567891011121314/** * 转码 XSS 防护 * @param &#123;String&#125; str 用户输入的字符串 * @return &#123;String&#125; 转码后的字符串 */function changeCode(str) &#123; str = str.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\") .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;#x27;\") .replace(/\\//g, \"&amp;#x2f;\"); return str;&#125; 参考： 浅谈WEB安全性（前端向） XSS的原理分析与解剖 原创翻译：给开发者的终极XSS防护备忘录 性能优化 在自己做一些小项目时，可能是学校的一些网站项目，流量可能日均都不超过500，而且大多是校园局域网内访问；或者是开发一些实验室的MIS系统，这辈子你都不会去使用你开发的这个系统。在这样一些项目中，性能优化往往会被你忽略。 但是如果你是做一个日均PV数万、数十万、甚至更大的量级，开发的页面会被全国各地，不同网络条件的用户来进行访问。这个时候，性能问题就无法忽视了。在当今的网络条件下，如果你的页面3秒都无法完成首屏渲染，一定会让你的网站流失很多用户。 整个网站的性能优化有很多的环节和工作，大多数时候，不是前端工程师单独就能完成的，尤其在职能划分明确的公司中，往往需要前后端、运维、DBA等多个职位协同完成。所以，在我们的课程中，主要让你了解整个性能优化都涉及哪些方面的工作，同时，我们会专注介绍一些在前端领域可以重点关注的技术点。 这里就是网页的打开速度，如果你的网页打开速度很慢，那么一定会有用户的流失。所以性能优化很重要。 网页内容 减少http请求次数 减少DNS查询次数 避免页面跳转 缓存Ajax 延迟加载 提前加载 减少DOM元素数量 根据域名划分内容 减少iframe数量 避免404 服务器 使用CDN 添加Expires 或Cache-Control报文头 Gzip压缩传输文件 配置ETags 尽早flush输出 使用GET Ajax请求 避免空的图片src Cookie 减少Cookie大小 页面内容使用无cookie域名 CSS 将样式表置顶 避免CSS表达式 用\\代替@import 避免使用Filters Javascript 将脚本置底 使用外部Javascirpt和CSS文件 精简Javascript和CSS 去除重复脚本 减少DOM访问 使用智能事件处理 图片 优化图像 优化CSS Sprite 不要在HTML中缩放图片 使用小且可缓存的favicon.ico 移动客户端 保持单个内容小于25KB 打包组建成符合文档 具体细节参考文章： 毫秒必争，前端网页性能最佳实践 我在 ToDo 这个任务中主要使用了 CDN 来加载静态资源。比如我使用了 百度静态资源公共库。引用了里面的 fontawesome，速度果然比在 GitHub 仓库里快很多。下一步是压缩我自己写的静态资源。 其他参考资料： 给网页设计师和前端开发者看的前端性能优化 梳理：提高前端性能方面的处理以及不足 css sprite原理优缺点及使用 CSS Sprites：鱼翅还是三鹿？ 大型网站的灵魂——性能 编写高效的 CSS 选择器 模块化 对于一个复杂项目，特别是多人协作的复杂项目，如何合理划分模块，如何更加方便地进行模块加载，如何管理模块之间的依赖，是一个项目团队都会面临的问题，目前业界已经有了一些较为普遍的解决方案，如AMD。这个部分希望你能够通过学习JavaScript的模块化，学习如何合理地规划项目模块，合理使用模块化工具来优化你的项目代码结构。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 根据AMD规范，我们可以使用 define 定义模块，使用 require 调用模块。 目前，通行的 js 模块规范主要有两种：CommonJS 和 AMD。 AMD规范AMD 即 Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是 CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 详细 API 如下： AMD（中文版）) CommonJS规范CommonJS 是服务器端模块的规范，Node.js 采用了这个规范。Node.JS 首先采用了 js 模块化的概念。 根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为 global 对象的属性。 输出模块变量的最好方法是使用 module.exports 对象。 为什么要用 requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 requireJS requireJS 官网 requireJS 中文网 AMD和CMDCMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CMD 模块定义规范 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） 参考 Javascript模块化编程（一）：模块的写法–阮一峰 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 详解 JavaScript 模块开发 浅谈模块化的JavaScript 再谈 SeaJS 与 RequireJS 的差异 玩转AMD系列 by erik@EFE 玩转AMD - 写在前面 玩转AMD - 设计思路 玩转AMD - 应用实践 玩转AMD - Loader 前端工程化 业界目前有非常多的前端开发工具，完成一些开发过程中可以自动化完成的工作，提高研发效率，并且可以提高多人协作时的开发过程一致性，提高整个项目的运维效率。 在EFE日常工作中，我们是基于EDP，完成项目开发过程中的项目构建、包管理、调试、单测、静态检测、打包、压缩、优化、项目部署等一系列所有工作。 注： 如果网络不好，可以使用 淘宝 NPM 镜像。 参考 前端工程与模块化框架 手机百度前端工程化之路 对话百度前端工程师张云龙：F.I.S与前端工业化 EDP Grunt教程——初涉Grunt gulp入门指南 Gulp开发教程（翻译） Gulp 中文网 npm的package.json中文文档 最终作品在任务三中，做了一个 PC 端的 ToDo 应用。任务四是将它优化，以适应移动端设备。 ToDo WebApp Version 任务四要求 源代码 在线 demo 手机查看 ↓ 二维码 ↓ 我的博客 HyG Details 数据存储 以 JSON 模拟数据表的形式存储于 LocalStorage 中 使用数据库的思想，构建3张表。 cateJson 分类 childCateJson 子分类 taskJson 任务 分类表 cate ---------------------- id* | name | child(FK) ---------------------- 子分类表 childCate -------------------------------- id* | pid(FK) | name | child(FK) -------------------------------- 任务表 task ---------------------------------------------- id* | pid(FK) | finish | name | date | content ---------------------------------------------- 使用 Sass 重构了 CSS 代码 使用分块、继承等方式，使得代码更加清晰明了。 响应式布局 针对手机端细节做了很多调整，更符合手机上的视觉交互习惯。 加入页面切换效果 使用 translate3d()，纯 CSS3 切换动画效果。 处理了 XSS 防护 对可能造成破坏的字符进行转码。 性能优化 使用 CDN 处理静态资源 fontAwesome，压缩静态资源等 模块化 使用 requireJS 模块化 JavaScript 代码。重构 JavaScript 代码。优化之前写的耦合性高的绑定事件，重新绑定事件，降低耦合性。期间根据具体需求重写了事件代理的代码。 前端工程化 使用 gulp，自动编译 Sass，压缩 CSS 和 JavaScript 代码。并且配置了自动流程。 其他-webkit-tap-highlight-color 属性感谢 fiona 指出。 safari移动端点击的时候会闪一下加上 -webkit-tap-highlight-color: transparent; 就不会闪了。 参考： -webkit-tap-highlight-color css88 -webkit-tap-highlight-color 属性 textarea 标签 disabled 颜色 为什么用 disabled 属性？ 因为我发现仅仅使用 readonly 属性，在 IE 下是显示光标的。于是使用 disabled。 出现的问题 各家浏览器对于 disabled 属性有自己的样式设定，比如 IE 下是灰色的。苹果设备下也是。改变这些样式的方法也不是统一的。如果要兼容 Safari 必须加上 123background: #fff;-webkit-text-fill-color: rgba(0, 0, 0, 1);-webkit-opacity: 1; 于是最终代码如下： 123456textarea:disabled &#123; color:#000; background: #fff; -webkit-text-fill-color: rgba(0, 0, 0, 1); -webkit-opacity: 1;&#125; 参考：Disabled input text color 中的评论","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xichen.pub/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xichen.pub/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://xichen.pub/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://xichen.pub/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"http://xichen.pub/tags/Sass/"},{"name":"移动端","slug":"移动端","permalink":"http://xichen.pub/tags/移动端/"},{"name":"XSS","slug":"XSS","permalink":"http://xichen.pub/tags/XSS/"},{"name":"AMD","slug":"AMD","permalink":"http://xichen.pub/tags/AMD/"},{"name":"requireJS","slug":"requireJS","permalink":"http://xichen.pub/tags/requireJS/"},{"name":"CommonJS","slug":"CommonJS","permalink":"http://xichen.pub/tags/CommonJS/"},{"name":"性能优化","slug":"性能优化","permalink":"http://xichen.pub/tags/性能优化/"},{"name":"WebApp","slug":"WebApp","permalink":"http://xichen.pub/tags/WebApp/"}]},{"title":"Git Tips","slug":"2017-12-9-git-tips","date":"2017-12-09T13:36:00.000Z","updated":"2018-01-05T00:45:28.298Z","comments":true,"path":"2017/12/09/2017-12-9-git-tips/","link":"","permalink":"http://xichen.pub/2017/12/09/2017-12-9-git-tips/","excerpt":"","text":"库管理克隆库12git clone https://github.com/php/php-src.gitgit clone --depth=1 https://github.com/php/php-src.git # 只抓取最近的一次 commit 历史管理查看历史12git log --pretty=oneline filename # 一行显示git show xxxx # 查看某次修改 标签功能12345678git tag # 显示所有标签git tag -l 'v1.4.2.*' # 显示 1.4.2 开头标签git tag v1.3 # 简单打标签 git tag -a v1.2 9fceb02 # 后期加注标签git tag -a v1.4 -m 'my version 1.4' # 增加标签并注释， -a 为 annotated 缩写git show v1.4 # 看某一标签详情git push origin v1.5 # 分享某个标签git push origin --tags # 分享所有标签 回滚操作12git reset 9fceb02 # 保留修改git reset 9fceb02 --hard # 删除之后的修改 取消文件的修改12git checkout -- a.php # 取消单个文件git checkout -- # 取消所有文件的修改 删除文件12git rm a.php # 直接删除文件git rm --cached a.php # 删除文件暂存状态 移动文件1git mv a.php ./test/a.php 查看文件修改12git diff # 查看未暂存的文件更新 git diff --cached # 查看已暂存文件的更新 暂存和恢复当前staging12345git stash # 暂存当前分支的修改git stash apply # 恢复最近一次暂存git stash list # 查看暂存内容git stash apply stash@&#123;2&#125; # 指定恢复某次暂存内容git stash drop stash@&#123;0&#125; # 删除某次暂存内容 修改 commit 历史纪录1git rebase -i 0580eab8 分支管理创建分支12git branch develop # 只创建分支git checkout -b master develop # 创建并切换到 develop 分支 合并分支1234git checkout master # 切换到 master 分支git merge --no-ff develop # 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录git rebase develop # rebase 当前分支到 developgit branch -d develop # 删除 develop 分支 克隆远程分支12git branch -r # 显示所有分支，包含远程分支git checkout origin/android 修复develop上的合并错误 将merge前的commit创建一个分之，保留merge后代码 将develop reset --force到merge前，然后push --force 在分支中rebase develop 将分支push到服务器上重新merge 强制更新到远程分支最新版本12git reset --hard origin/mastergit submodule update --remote -f Submodule使用克隆带submodule的库1git clone --recursive https://github.com/chaconinc/MainProject clone主库后再去clone submodule123git clone https://github.com/chaconinc/MainProjectgit submodule initgit submodule update Git设置Git的全局设置在~/.gitconfig中，单独设置在project/.git/config下。 忽略设置全局在~/.gitignore_global中，单独设置在project/.gitignore下。 设置 commit 的用户和邮箱12git config user.name \"xx\"git config user.email \"xx@xx.com\" 或者直接修改config文件 123[user] name = xxx email = xxx@xxx.com 查看设置项1git config --list 设置git终端颜色123git config --global color.diff autogit config --global color.status autogit config --global color.branch auto","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Git","slug":"Git","permalink":"http://xichen.pub/tags/Git/"}]},{"title":"网页排序算法（三）代数方法求PageRank","slug":"2017-12-08-网页排序算法（三）代数方法求PageRank","date":"2017-12-08T12:22:00.000Z","updated":"2018-01-05T00:45:28.294Z","comments":true,"path":"2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/","link":"","permalink":"http://xichen.pub/2017/12/08/2017-12-08-网页排序算法（三）代数方法求PageRank/","excerpt":"","text":"本文结合实例介绍如何用代数方法求PageRank。 博文《网页排序算法（一）PageRank》介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即： $$PR(pi)=\\frac{1−d}{N}+d \\sum{p_j\\in B(p_i)} \\frac{PR(p_j)}{L(p_j)}$$ 下文结合图1介绍如何用代数方法求PageRank。 Fig. 1: PageRanks for a simple network (image from Wikipedia) 为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示： Fig. 2: Draw Fig. 1 in NetworkX. 代数方法根据1中的等式，把所有节点都放在一块，可以得到： $$\\begin{bmatrix}PR(p_1) \\PR(p_2) \\\\vdots \\PR(p_3)\\end{bmatrix} =\\begin{bmatrix}{(1-d)/ N} \\{(1-d) / N} \\\\vdots \\{(1-d) / N}\\end{bmatrix} d\\begin{bmatrix}\\ell(p_1,p_1) &amp; \\ell(p_1,p_2) &amp; \\cdots &amp; \\ell(p_1,p_N) \\\\ell(p_2,p_1) &amp; \\ddots &amp; &amp; \\vdots \\\\vdots &amp; &amp; \\ell(p_i,p_j) &amp; \\\\ell(p_N,p_1) &amp; \\cdots &amp; &amp; \\ell(p_N,p_N)\\end{bmatrix}\\begin{bmatrix}PR(p_1) \\PR(p_2) \\\\vdots \\PR(p_3)\\end{bmatrix}$$ 上述等式可以缩写为： $$\\mathbf{R} = d \\mathcal{M}\\mathbf{R} + \\frac{1-d}{N} \\mathbf{1}. (**)$$ 其中，1为N维的列向量，所有元素皆为1。以图1为例，该列向量为，1234567891011121314N = len(G.nodes()) # N = 11column_vector = np.ones((N, 1), dtype=np.int) [[1] [1] [1] [1] [1] [1] [1] [1] [1] [1] [1]] Adjacency function邻接函数（adjacency function）$$\\ell(p_1,p_2)$$组成了矩阵M， $$\\mathcal{M}_{ij} =\\ell(pi,pj) = \\begin{cases} 1 /L(p_j) , &amp; \\mbox{if }j\\mbox{ links to }i\\ L(pj)是指从pj链出去的网页数目\\ 0, &amp; \\mbox{otherwise} \\end{cases}$$ 这样矩阵每一行乘以R，就得到了新的PR值，比如第二行（图1的节点B）， $$\\begin{align}M_{2j} &amp;=\\ell(p_2,p_1)⋅PR(p_2)+\\ell(p_2,p_2)⋅PR(p_2)+⋯+\\ell(p_2,p_N)⋅PR(p_2)\\&amp;=0 (‘A’)+0 (‘B’)+1 (‘C’)+12 (‘D’)+13 (‘E’)+12 (‘F’) +12 (‘G’)+12 (`H’)+12 (‘I’)+0 (‘J’)+0 (‘K’) \\end{align}$$ 以节点G为例，G给B和E投票，所以B得到1/2。 矩阵M每一列加起来都是1（值得注意的是，对于没有出链的节点，列加起来等于0，比如图1的节点A），即$$\\sum_{i=1}^{N}\\ell(p_i,p_j)=1$$。事实上，M是一个转移矩阵transition matrix（也叫概率矩阵probability matrix，马尔可夫矩阵Markov matrix）。因此，PageRank是eigenvector centrality的一个变体。 矩阵M事实上，M可以被看成normalized的图邻接矩阵，即： $$M=(K^{−1}A)^T$$其中，A为图的邻接矩阵，以图1为例，12345678910111213141516# Get adjacency matrixnodelist = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] # sorted(G.nodes())A = nx.to_numpy_matrix(G, nodelist) 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K'[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 1. 0. 1. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]] A是对角矩阵，对角线上的元素是对应节点的出度。123456789101112131415nodelist = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] # sorted(G.nodes())list_outdegree = map(operator.itemgetter(1), sorted(G.out_degree().items()))K = np.diag(list_outdegree) [[0 0 0 0 0 0 0 0 0 0 0] [0 1 0 0 0 0 0 0 0 0 0] [0 0 1 0 0 0 0 0 0 0 0] [0 0 0 2 0 0 0 0 0 0 0] [0 0 0 0 3 0 0 0 0 0 0] [0 0 0 0 0 2 0 0 0 0 0] [0 0 0 0 0 0 2 0 0 0 0] [0 0 0 0 0 0 0 2 0 0 0] [0 0 0 0 0 0 0 0 2 0 0] [0 0 0 0 0 0 0 0 0 1 0] [0 0 0 0 0 0 0 0 0 0 1]] K的逆矩阵$$K^{-1}$$为，12345678910111213K_inv = np.linalg.pinv(K) [[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0.5 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0.5 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0.5 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0.5 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0.5 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ]] 那么，根据公式$$M=(K^{−1}A)^T$$就可以求得M，如下，12345678910111213M = (K_inv * A).transpose() [[ 0. 0. 0. 0.5 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 1. 0.5 0.33 0.5 0.5 0.5 0.5 0. 0. ] [ 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0.5 0.5 0.5 0.5 1. 1. ] [ 0. 0. 0. 0. 0.33 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ]] 求解R是2.1等式的特征向量（eigenvector），求解等式得： $$\\mathbf{R} = (\\mathbf{I}-d \\mathcal{M})^{-1} \\frac{1-d}{N} \\mathbf{1},$$ 其中$$\\mathbf{I}$$是单位矩阵。123456789101112131415d = 0.85I = np.identity(N)R = np.linalg.pinv(I - d*M) * (1-d)/N * column_vector [[ 0.028] [ 0.324] [ 0.289] [ 0.033] [ 0.068] [ 0.033] [ 0.014] [ 0.014] [ 0.014] [ 0.014] [ 0.014]] 咦，结果怎么跟图1不一样。得到R需要normalized，如此，所有节点的PR加起来才能等于1。12345678910111213R = R/sum(R) # normalized R, so that page ranks sum to 1. [[ 0.033] [ 0.384] [ 0.343] [ 0.039] [ 0.081] [ 0.039] [ 0.016] [ 0.016] [ 0.016] [ 0.016] [ 0.016]] 用NetworkX作出来的图，是这样的： Fig. 3: PageRanks for a simple network Python源代码NetworkX实现了PageRank的代数计算方法nx.pagerank_numpy，源代码在这里。12345678910111213141516171819def pagerank_numpy(G, alpha=0.85, personalization=None, weight='weight', dangling=None): \"\"\"Return the PageRank of the nodes in the graph. \"\"\" if len(G) == 0: return &#123;&#125; M = google_matrix(G, alpha, personalization=personalization, weight=weight, dangling=dangling) # use numpy LAPACK solver eigenvalues, eigenvectors = np.linalg.eig(M.T) ind = eigenvalues.argsort() # eigenvector of largest eigenvalue at ind[-1], normalized largest = np.array(eigenvectors[:, ind[-1]]).flatten().real norm = float(largest.sum()) return dict(zip(G, map(float, largest / norm))) References: [1] StackOverflow: Incorrect PageRank calculation result","categories":[],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"网页排序算法（二）迭代方法求PageRank","slug":"2017-12-07-网页排序算法（二）迭代方法求PageRank","date":"2017-12-07T12:22:00.000Z","updated":"2018-01-05T00:45:28.292Z","comments":true,"path":"2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/","link":"","permalink":"http://xichen.pub/2017/12/07/2017-12-07-网页排序算法（二）迭代方法求PageRank/","excerpt":"","text":"本文介绍如何用迭代的方法计算PageRank。 PageRank博文《网页排序算法（一）PageRank》介绍了PageRank，计算PageRank可以用迭代的方法也可以用代数的方法，其背后的数学基本运算是一样的，即： $$PR(pi)=\\frac{1−d}{N}+d\\sum{p_j\\in B(p_i)}\\frac{PR(pj)}{L(p_j)}$$ 下文结合图1介绍如何用迭代方法求PageRank。 Fig. 1: PageRanks for a simple network (image from Wikipedia). 为了便于讨论，将图1下方的节点分别标上G, H, I, J, K，如下图所示： Fig. 2: Label nodes in Fig. 1. 迭代方法初始化节点PR值如果没有给节点指定PR初始值，那么每个节点的PR初始化为1/N (N为节点数目)，以图1为例，节点的PR初始值为1/11： Fig. 3: The graph with starting value of PageRank iteration for each node. 相应源代码如下：123# Step 1: Initiate PageRankN = G.number_of_nodes() # N = 11node_and_pr = dict.fromkeys(G, 1.0 / N) 创建随机图（stochastic graph）随机图（stochastic graph）是一个有向带权图，边的权重被normalized，使得每个节点的outedges的权重加起来为1。事实上，边的权重即为$$1/L(p_j)$$，图1的随机图如下： Fig. 4: The stochastic graph 比如，节点D有两条出链，D --&gt; A和D --&gt; B，所以他们的边权重都是0.5。源代码如下：1234stochastic_graph = nx.stochastic_graph(G, weight=weight) # M = 1/L(pj) print(stochastic_graph['D'])&#123;'A': &#123;'Edge Id': u'5', 'weight': 0.5&#125;, 'B': &#123;'Edge Id': u'6', 'weight': 0.5&#125;&#125; 迭代计算遍历所有节点，将每个节点的PR值平均分给其出链的节点，即$$\\sun_{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$，乘以阻尼系数d，再加上(1−d)/N。源代码如下：1234567891011dangling_value = (1-d)/N for _ in range(max_iter): # for each iteration node_and_prev_pr = node_and_pr node_and_pr = dict.fromkeys(node_and_prev_pr.keys(), 0) for node in node_and_pr: # for each node for out_node in stochastic_graph[node]: # node --&gt; out_node node_and_pr[out_node] += d * node_and_prev_pr[node] * stochastic_graph[node][out_node][weight] # PR(p_i) = d * PR(p_j)&#125;/L(p_j) node_and_pr[node] += dangling_value 第一次迭代结果如下图所示（有些箭头没显示出来，NetworkX可视化很弱）： Fig. 5: PageRank after one ieration 那什么时候程序结束呢。将迭代后的PR值跟前一次比较，如果差别很少（如PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6），就可以停止迭代了。源代码如下：1234# check convergence, l1 normerr = sum([abs(node_and_pr[node] - node_and_prev_pr[node]) for node in node_and_pr])if err &lt; N*tol: return node_and_pr 在本例中，需要66次迭代，最后得到的PageRank，如下图： wikipedia_pagerank_example_prFig. 6: Stable PageRank values (66 iterations) 我在想一个问题，上面的方法，每次迭代都是基于上一次的PR值，能不能这样，迭代的时候使用最新的值，这样会不能减少迭代次数，如下所示：1234567# 初始值PA(D) = 0.09PA(B) = 0.09 # 第一次迭代PA(D)/2 --&gt; P(A), P(B) # 此时， PB(B)=0.045PB(B) --&gt; P(C) # 按上面的算法，PB(B)=0.09，那能不能使用刚更新的PR值0.045，这样会不会快一些？ NetworkX的pageranknx.pagerank跟章节2差不多，区别在于：123456# 2中的算法node_and_pr[node] += (1.0 - d)/N # nx.pagerankdanglesum = d * sum(node_and_prev_pr[node] for node in dangling_nodes)node_and_pr[node] += danglesum/N + (1.0 - d)/N # danglesum/N + (1-d)/N nx.pagerank将图中所有悬挂节点（dangling nodes，没有出链的节点，图1只有节点A）的PR累加，并normalized，再加上(1.0–d)/N。","categories":[],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"区块链开发（二）部署并运行以太坊智能合约","slug":"2017-12-06-区块链开发（二）部署并运行以太坊智能合约","date":"2017-12-06T12:21:00.000Z","updated":"2018-01-05T00:45:28.291Z","comments":true,"path":"2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/","link":"","permalink":"http://xichen.pub/2017/12/06/2017-12-06-区块链开发（二）部署并运行以太坊智能合约/","excerpt":"","text":"","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"区块链开发（零）概念入门","slug":"2017-11-27-区块链开发（零）概念入门","date":"2017-12-06T12:21:00.000Z","updated":"2018-01-05T00:45:28.288Z","comments":true,"path":"2017/12/06/2017-11-27-区块链开发（零）概念入门/","link":"","permalink":"http://xichen.pub/2017/12/06/2017-11-27-区块链开发（零）概念入门/","excerpt":"","text":"概念地址比特币地址（例如：1DSrfJdB2AnWaFNgSbv3MZC2m74996JafV）由一串字符和数字组成，以阿拉伯数字“1”开头。就像别人向你的email地址发送电子邮件一样，他可以通过你的比特币地址向你发送比特币。 可以用 vanitygen 来生成包含一定字母的地址。 BIP比特币改进提议 （Bitcoin Improvement Proposals 的缩写），指比特币社区成员所提交的一系列改进比特币的提议。例如，BIP0021是一项改进比特币统一资源标识符（URI）计划的提议。 比特币“比特币”既可以指这种虚拟货币单位，也指比特币网络或者网络节点使用的比特币软件。 区块一个区块就是若干交易数据的集合，它会被标记上时间戳和之前一个区块的独特标记。区块头经过哈希运算后会生成一份工作量证明，从而验证区块中的交易。有效的区块经过全网络的共识后会被追加到主区块链中。 区块链区块链是一串通过验证的区块，当中的每一个区块都与上一个相连，一直连到创世区块。 确认当一项交易被区块收录时，我们可以说它有一次确认。矿工们在此区块之后每再产生一个区块，此项交易的确认数就再加一。当确认数达到六及以上时，通常认为这笔交易比较安全并难以逆转。 难度整个网络会通过调整“难度”这个变量来控制生成工作量证明所需要的计算力。 难度目标使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标。 难度调整整个网络每产生2,106个区块后会根据之前2,106个区块的算力进行难度调整。 哈希二进制数据的一种数字指纹。 创世区块创世区块指区块链上的第一个区块，用来初始化相应的加密货币。 矿工矿工指通过不断重复哈希运算来产生工作量证明的各网络节点。 挖矿描述挖矿的一个好方法是将之类比为一个巨大的多人数独谜题游戏。一旦有人发现正解之后，这个数独游戏会自动调整困难度以使游戏每次需要大约10分钟解决。想象一个有几千行几千列的巨大数独游戏。如果给你一个已经完成的数独，你可以很快地验证它。然而，如果这个数独只有几个方格里有数字其余方格都为空的话，就会花费非常长的时间来解决。这个数独游戏的困难度可以通过改变其大小（更多或更少行列）来调整，但即使它非常大时验证它也是相当容易的。而比特币中的 “谜题” 是基于哈希加密算法的，其展现了相似的特性：非对称地，它解起来困难而验证很容易，并且它的困难度可以调整。 当区块一个个堆上来时，这个交易变得指数级地越来越难被推翻，因此它在网络中得到更多信任。 矿工费交易的发起者通常会向网络缴纳一笔矿工费，用以处理这笔交易。大多数的交易需要0.5毫比特币的矿工费。 网络比特币网络是一个由若干节点组成的用以广播交易信息和数据区块的P2P网络。 工作量证明工作量证明指通过有效计算得到的一小块数据。具体到比特币，矿工必须要在满足全网目标难度的情况下求解SHA256算法。 奖励每一个新区块中都有一定量新创造的比特币用来奖励算出工作量证明的矿工。现阶段每一区块有25比特币的奖励。 私钥用来解锁对应（钱包）地址的一串字符，例如5J76sF8L5jTtzE96r66Sf8cka9y44wdpJjMwCxR3tzLh3ibVPxh。 交易简单地说，交易指把比特币从一个地址转到另一个地址。更准确地说，一笔“交易”指一个经过签名运算的，表达价值转移的数据结构。每一笔“交易”都经过比特币网络传输，由矿工节点收集并封包至区块中，永久保存在区块链某处。 转出是交易，转入也是交易。 一般交易。一个地址转到另一个地址，用不完会“找零”。 集合型交易。多个地址转向一个地址，钱包用来汇合零钱。 分散型交易。一个转向多个，如发工资。 交易的输出会被创建成为一个包含这笔数额的脚本的形式，只能被引入这个脚本的一个解答后才能兑换。 钱包钱包指保存比特币地址和私钥的软件，可以用它来接受、发送、储存你的比特币。 比特币地址以数字1或3开头。类似于电子邮件地址，这些地址可以分享给其他的比特币的用户，这样他们就可以直接通过这些地址发送比特币到你的钱包里。不同于电邮地址的是，你可以任意地创建新的比特币地址，这些地址都能成功地将资金转到你的钱包。 钱包是多个地址和解锁资金密钥的简单集合。每笔交易你都可以使用不同的地址，这有利于提高隐私的安全性。用户可创建地址的数量几乎不受限制。 一个地址对应一个秘钥，像支付宝的付款码，其在支付宝后台也有一个对应的秘钥，验证交易。 直到这个地址接收到在比特币账簿（区块链）中公布过的一笔交易时，才会成为众多可能“有效”的比特币地址之一。 介绍平均每10分钟就有人能验证过去这10分钟发生的交易，他将会获得新币作为工作回报。本质上，挖矿把央行的货币发行和结算功能进行分布式，用全球化的算力竞争来取代对中央发行机构的需求。 比特币系统包含调节挖矿难度的协议。挖矿——在比特币网络中成功写入一个区块交易——的难度是动态调整的，保证不管有多少矿工（多少CPU）挖矿，平均每10分钟只有一个矿工成功。 任何接受数字货币的人都面临的两个基本问题是： 我能相信这钱是真实可信的，而不是伪造的吗？我能确定没人说这笔钱是他们的，而不是我的吗？（又名“双重支付”问题） 比特币代表了数十年的密码学和分布式系统的巅峰之作，这是一个独特而强大的组合，汇集了四个关键的创新点。比特币由这些构成： 一个去中心化的点对点网络（比特币协议） 一个公共的交易账簿（区块链） 一个去中心化的数学的和确定性的货币发行（分布式挖矿） 一个去中心化的交易验证系统（交易脚本） 使用http://blockchain.info/ 可以查看所有交易信息 参考 http://zhibimo.com/read/wang-miao/mastering-bitcoin","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"网页排序算法（一）PageRank","slug":"2017-12-05-网页排序算法（一）PageRank","date":"2017-12-05T12:22:00.000Z","updated":"2018-01-05T00:45:28.291Z","comments":true,"path":"2017/12/05/2017-12-05-网页排序算法（一）PageRank/","link":"","permalink":"http://xichen.pub/2017/12/05/2017-12-05-网页排序算法（一）PageRank/","excerpt":"","text":"参加数学建模的时候要研究一下PageRank，为了巩固3天从入门到精通的成果，把了解到的整理成文。 直观理解基本思想PageRank是以Google创始人Larry Page的姓命名的，于1999被提出来，用于测量网页的相对重要性（对网页进行排序），学术论文如下： Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF] PageRank的设计受到学术论文引用启发（两人的父亲都是大学教授）。衡量一篇学术论文质量高与否，最重要的一个指标是引用次数，高引用量的论文通常意味着高质量。同理，如果一张网页被引用（以超链接的形式）多了，那么这张网页就比较重要。总结起来，PageRank的核心思想有两点（结合图1说明）： 越多的网页链接到一个网页（可以理解成投票，D --&gt; B，D给B投了一票），说明这个网页更加重要，如图1的B。(一篇论文被很多论文引用) PageRank高的网页链接到一个网页，说明这张网页也很重要。如图1，尽管C只有一张网页B链接到它，但C的重要性高于E，尽管E有一堆小罗罗给它投票。（论文被大牛引用了，说明这篇论文很有价值）（也可以从话语权角度理解，重要的人说话份量重） Fig. 1: PageRanks for a simple network (image from Wikipedia) 整个万维网（World Wide Web）可以抽象成一张有向图，节点表示网页，连线$$p_i\\to p_j$$表示网页$$p_i$$包含了超链接$$p_j$$（$$p_i$$指向了$$p_j$$）。如果能对图中每个节点重要性量化，那么就能对网页进行排序了。PageRank提出之初就是为了对网页进行排序。 搜索引擎的工作原理可以简化为：输入关键词，返回与该关键词相关的网页（一个集合，相当于得到一张子图），在该子图上计算每个节点的PageRank值，PR值高的网页排在前面，低的就排在后面。 如何计算接下来的问题是，如何计算每个节点的PageRank。想要知道一个网页$$p_i$$的PR值，需要知道： 有多少网页链接到了$$p_i$$ 这些网页的PR值是多少其他网页的PR值又很可能是依赖于$$p_i$$，这就陷入了“先有鸡还是先有蛋”的循环，要想知道$$p_i$$的PR值，就得知道链向$$p_i$$所有网页的PR值，而要知道其他网页的PR值，又得先知道$$p_i$$的PR值。 为了打破这个循环，佩奇和布林采用了一个很巧妙的思路， 即分析一个虚拟用户在互联网上的漫游过程。 他们假定：虚拟用户一旦访问了一个网页，下一步将以相同的概率访问被该网页所链接的任何一个其它网页[3]。比如，网页$$p_i$$包含N个超链接，那么虚拟用户访问这N个页面中的任何一个的概率是1/N。那么，网页的排序就可以看成一个虚拟用户在万维网漫游了很长时间，页面被访问的概率越大，其PR值就越高，网页排名也越靠前。 先从简化的PageRank说起，以PageRank论文的例子为例，看看PageRank是怎么计算的，如下： Fig. 2: Simplified PageRank calculation (image from [1]) 每个节点初始化或者指定一个PageRank值（如PR(A)=0.4），网页A包含两个超链接，分别指向B和C（或者说A投票给B和C），0.4拆分成两份，每份0.2，所以PR(B)=0.2。A和B同时给C投票，所以PR(C)=0.2+0.2=0.4。如此，不断地迭代，最后每个节点的值会趋于稳定（或者说收敛），这样就求得了所有节点的PR值。事实上，在这个例子中，PageRank已收俭。 每个页面将其当前的PageRank值平均分配到本页面所有出链上，一个页面将所有入链的PR值累加起来就构成了该页面新的PR值。如此迭代下去，最后得到一个稳定值。用数学公式表达，如下： $$PR(A)=\\frac{PR(B)}{L(B)}+\\frac{PR(C)}{L(C)}+\\frac{PR(D)}{L(D)}+⋯$$ 更一般化地（$$B(p_i)$$表示所有链向网页$$p_i$$的集合）， $$PR(pi)=\\sum_{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$ 但这样算存在两个问题： 对于没有forward links (outedges)的网页，即只有别人给她投票，她从不给别人投票，那么她的PageRank每次迭代都会增加。 对于没有blacklinks (inedges)的网页，即没人给她投票，其PageRank永远等于0。 对于第一个问题，给等式乘以一个小于1的常数d（damping factor，翻译成阻尼因数？）；对于第二个问题，给等式加上一个常数。新的等式如下（N表示网页总数，或者节点数目）： $$PR(pi)=\\frac{1−d}{N}+d\\sum{p_j\\in B(p_i)}\\frac{PR(p_j)}{L(p_j)}$$ 其中， $$B(p_i)$$：链接到网页pipi的集合（a set of pages link to pipi） $$L(p_j)$$：从$$p_j$$链出去的网页数目（the number of outbound links）这样，就确保所有节点的PR值加起来等于1。 一个简单实例以一个很简单的例子（A &lt; --&gt; B）来看PageRank是怎么收俭的。 Fig. 2: An illustration of PageRank calculation. 假设他们的初始PR值为1，第一次迭代后，PR(A)和PR(B)的值为：12PR(A) = 0.15/2 + 0.85*1.0 = 0.9249999999999999PR(B) = 0.15/2 + 0.85*0.9249999999999999 = 0.8612499999999998 写个简单的Python脚本，得到每次迭代后的值，部分如下：12345678910111213141516171819202122232425 1: A=0.925000 B=0.861250 2: A=0.807062 B=0.761003 3: A=0.721853 B=0.688575 4: A=0.660289 B=0.636245 5: A=0.615808 B=0.598437 6: A=0.583672 B=0.571121 7: A=0.560453 B=0.551385 8: A=0.543677 B=0.537126 9: A=0.531557 B=0.526823 10: A=0.522800 B=0.519380 11: A=0.516473 B=0.514002 12: A=0.511902 B=0.510116 13: A=0.508599 B=0.50730914: A=0.506213 B=0.505281 15: A=0.504489 B=0.503815 16: A=0.503243 B=0.502757 17: A=0.502343 B=0.501992 18: A=0.501693 B=0.501439 19: A=0.501223 B=0.501040 20: A=0.500884 B=0.500751...42: A=0.500001 B=0.500001 43: A=0.500001 B=0.500000 44: A=0.500000 B=0.500000 45: A=0.500000 B=0.500000 可见，随着迭代次数的增加，PageRank越来越接近收俭值0.5。Python源代码如下：12345678910111213def pagerank_ab(): \"\"\" Calculate PageRank for A &lt;--&gt; B \"\"\" pr = &#123;'A':1.0, 'B':1.0&#125; max_iter = 50 for idx in range(1, max_iter+1): pr['A'] = 0.15/2 + 0.85*pr['B'] pr['B'] = 0.15/2 + 0.85*pr['A'] s = '&#123;:3d&#125;: A=&#123;:&lt;10f&#125;\\tB=&#123;:&lt;10f&#125;'.format(idx, pr['A'], pr['B']) print(s) 迭代次数迭代次数越多，结果越准确，但花费时间也越长。出于效率考虑，在实际应用中，当PR值落在误差允许范围内（PR值跟前一次比较，如PR′(A)−PR(A)&lt;1.0e−6PR′(A)−PR(A)&lt;1.0e−6，想想浮点数在计算机的存储），就可以返回结果了。Python实现的nx.pagerank相关源代码如下：1234# check convergence, l1 normerr = sum([abs(x[n] - xlast[n]) for n in x])if err &lt; N*tol: # tol=1.0e-6 return x 当然，对于超大型网络来说，有更复杂的计算方法，比如分布式。 PR初始值不管节点PR初始值怎么设置，最后节点的PR值都一样，但收俭速度不一样。可以修改上面Python代码的PR初始值，运行代码，自行感受下。NetworkX的pagerank实现是将PR值初始化为1/N。 Damping factor跟PR初始值类似，d的取值也会影响算法效率。根据Page的论文，d通常设为0.85。 PageRank计算方法(1) 迭代方法 详情见另一篇博文《网页排序算法（二）迭代方法求PageRank》。 （2）代数方法 详情见另一篇博文《网页排序算法（三）代数方法求PageRank》。 （3）Power Method 待续。 用NetworkX求PageRankNetworkX提供3个求PageRank的API，如下： pagerank(…) pagerank_numpy(…) pagerank_scipy(…) 详细API如下： 12345pagerank(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06, nstart=None, weight='weight', dangling=None) pagerank_numpy(G, alpha=0.85, personalization=None, weight='weight', dangling=None) pagerank_scipy(G, alpha=0.85, personalization=None, max_iter=100, tol=1e-06, weight='weight', dangling=None) References: [1] Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. [PDF] [2] PageRank Centrality by Massimo Franceschet [3] 谷歌背后的数学 by 卢昌海 [4] Wikipedia: PageRank [5] The Google Pagerank Algorithm and How It Works","categories":[],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"http://xichen.pub/tags/PageRank/"}]},{"title":"迪菲-赫尔曼密钥交换","slug":"2017-12-01-迪菲-赫尔曼密钥交换","date":"2017-12-01T13:52:00.000Z","updated":"2018-01-05T00:45:28.290Z","comments":true,"path":"2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/","link":"","permalink":"http://xichen.pub/2017/12/01/2017-12-01-迪菲-赫尔曼密钥交换/","excerpt":"","text":"迪菲-赫尔曼密钥交换（英语：Diffie–Hellman key exchange，缩写为D-H）最简单，最早提出的这个协议使用一个质数$p$的整数模$n$乘法群以及其原根$g$。 迪菲-赫尔曼密钥交换 算法如下（绿色表示非秘密信息, 红色粗体表示秘密信息）： 爱丽丝与鲍伯协定使用 $$p=23$$以及base $$g=5$$. 爱丽丝选择一个秘密整数$$a=6$$, 计算$$A = g^a mod p$$并发送给鲍伯。 $$A = 56 mod 23 = 8$$. 鲍伯选择一个秘密整数$$b=15$$, 计算$$B = g^b mod p$$并发送给爱丽丝。 $$B = 515 mod 23 = 19$$. 爱丽丝计算$$s = B^a mod p$$ $$196 mod 23 = 2$$. 鲍伯计算$$s = A^b mod p$$ $$815 mod 23 = 2$$. 以下是一个更为一般的描述: 爱丽丝和鲍伯写上一个有限循环群 $$G$$ 和它的一个生成元 $$g$$。 （这通常在协议开始很久以前就已经规定好； $$g$$是公开的，并可以被所有的攻击者看到。） 爱丽丝选择一个随机自然数 $$a$$ 并且将$${\\displaystyle g^{a}{\\bmod {p}}} g^{a} \\bmod{p}$$发送给鲍伯。 鲍伯选择一个随机自然数 $$b$$ 并且将$${\\displaystyle g^{b}{\\bmod {p}}} g^{b} \\bmod{p}$$发送给爱丽丝。 爱丽丝 计算 $${\\displaystyle \\left(g^{b}\\right)^{a}{\\bmod {p}}} \\left ( g^{b} \\right )^{a} \\bmod{p} $$。 鲍伯 计算 $${\\displaystyle \\left(g^{a}\\right)^{b}{\\bmod {p}}} \\left ( g^{a} \\right )^{b} \\bmod{p} $$。 爱丽丝和鲍伯就同时协商出群元素$$ {\\displaystyle g^{ab}} g^{ab} $$，它可以被用作共享秘密。$${\\displaystyle \\left(g^{b}\\right)^{a}} \\left ( g^{b} \\right )^{a} = {\\displaystyle \\left(g^{a}\\right)^{b}} \\left ( g^{a} \\right )^{b}$$因为群是乘法交换的。","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"http://xichen.pub/tags/密码学/"}]},{"title":"区块链开发（一）搭建环境-基于以太坊私有链","slug":"2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链","date":"2017-11-30T13:52:00.000Z","updated":"2018-01-05T00:45:28.290Z","comments":true,"path":"2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/","link":"","permalink":"http://xichen.pub/2017/11/30/2017-11-30-区块链开发（一）搭建环境-基于以太坊私有链/","excerpt":"","text":"安装Geth和MistUbuntu下安装Geth客户端之所以采用Ubuntu，是因为以太坊的官方对Ubuntu支持的很好，是在各个linux系统中安装最简单。 Geth官方安装指南：https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum 进入ubuntu命令行，执行如下命令123456$ sudo apt-get update$ sudo apt-get installsoftware-properties-common$ sudo add-apt-repository -yppa:ethereum/ethereum$ sudo add-apt-repository -yppa:ethereum/ethereum-dev$ sudo apt-get update$ sudo apt-get install ethereum 系统联网执行后，即完成了安装以太坊客户端，其中包括geth,bootnode,evm,disasm,rlpdump,ethtest此时如果输入 geth 命令，会出现启动以太坊启动的画面 也可以源码编译安装1234$ git clone https://github.com/ethereum/go-ethereum$ sudo apt-get install -y build-essential golang$ cd go-ethereum$ make geth Windows下安装Geth客户端下载并安装 Geth for Windows.Windows必须64位系统，从官方网站下载编译好的win64客户端，解压缩即可运行，下载地址如下（第二个地址备选）： https://github.com/ethereum/go-ethereum/releases/https://geth.ethereum.org/downloads/ 下载后，只有一个Geth.exe的文件。 MAC OSX下安装Geth客户端首先确保已安装homebrew，没有安装过的可以在命令行下执行/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;进行安装12$ brew tap ethereum/ethereum$ brew install ethereum 安装图像化客户端Mist依然是从官方地址下载编译好的客户端即可，下载地址： https://github.com/ethereum/mist/releases/ 下载解压缩后，Ethereum-Wallet 即为以太坊图形化界面。 准备创世块文件配置自己的创世块是为了区分公有链，同一个网络中，创世块必须是一样的，否则无法联通，此方法在windows和Ubuntu下通用。新建文件piccgenesis.json,输入如下内容并保存1234567891011121314151617&#123; \"config\": &#123; \"chainId\": 123456, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"nonce\": \"0x0000000000000042\", \"difficulty\": \"0x020000\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\", \"gasLimit\": \"0x4c4b40\", \"alloc\": &#123;&#125;&#125; 解释一下各个参数的作用： 参数 作用 mixhash 与nonce配合用于挖矿，由上一个区块的一部分生成的hash。注意他和nonce的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。. nonce nonce就是一个64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊的Yellow paper, 4.3.4. Block Header Validity, (44)章节所描述的条件。 difficulty 设置当前区块的难度，如果难度过大，cpu挖矿就很难，这里设置较小难度 alloc 用来预置账号以及账号的以太币数量，因为私有链挖矿比较容易，所以我们不需要预置有币的账号，需要的时候自己创建即可以。 coinbase 矿工的账号，随便填 timestamp 设置创世块的时间戳 parentHash 上一个区块的hash值，因为是创世块，所以这个值是0 extraData 附加信息，随便填，可以填你的个性信息 gasLimit 该值设置对GAS的消耗总量限制，用来限制区块能包含的交易信息总和，因为我们是私有链，所以填最大。 启动私有链节点启动Geth即可以启动以太坊的区块链，为了构建私有链 ，需要在Geth启动时加入一些参数，Geth参数含义如下： 参数 作用 identity 区块链的标示，随便填写，用于标示目前网络的名字 init 指定创世块文件的位置，并创建初始块 datadir 设置当前区块链网络数据存放的位置 port 网络监听端口 rpc 启动rpc通信，可以进行智能合约的部署和调试 rpcapi 设置允许连接的rpc的客户端，一般为db,eth,net,web3 networkid 设置当前区块链的网络ID，用于区分不同的网络，是一个数字 console 启动命令行模式，可以在Geth中执行命令 在Ubuntu启动区块链节点在Ubuntu下，首先切换到打算运行的目录，目录下应该有配置好的piccgenesis.json文件，获取当前的目录：1$ basepath=$(cd `dirname $0`; pwd) 创建数据存放地址并初始化创世块：1$ geth --datadir \"$basepath/chain\" init piccgenesis.json 启动节点：1$ geth --identity \"PICCetherum\" --rpc --rpccorsdomain \"*\" --datadir \"$basepath/chain\" --port \"30303\" --rpcapi \"db,eth,net,web3\" --networkid 95518 console 启动后界面如下，光标停留在最后的命令行上，可以执行以太坊命令。1234567891011121314151617181920212223I0707 00:45:43.680087 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindataI0707 00:45:43.726008ethdb/database.go:169] closed db:/home/lihe/桌面/chain/chaindataI0707 00:45:43.728913 ethdb/database.go:82]Alloted 128MB cache and 1024 file handles to /home/lihe/桌面/chain/chaindataI0707 00:45:43.908795 ethdb/database.go:82]Alloted 16MB cache and 16 file handles to /home/lihe/桌面/chain/dappI0707 00:45:43.969506 core/genesis.go:92]Genesis block already in chain. Writing canonical numberI0707 00:45:43.980337 eth/backend.go:274]Successfully wrote custom genesis block:6e92f8b23bcdfdf34dc813cfaf1d84b71beac80530506b5d63a2df10fe23a660I0707 00:45:43.980618 eth/backend.go:184]Protocol Versions: [63 62], Network Id: 95518I0707 00:45:43.981567core/blockchain.go:204] Last header: #81 [6193c4b0…] TD=10836704I0707 00:45:43.981645core/blockchain.go:205] Last block: #81 [6193c4b0…] TD=10836704I0707 00:45:43.981677core/blockchain.go:206] Fast block: #81 [6193c4b0…] TD=10836704I0707 00:45:43.985253 p2p/server.go:313]Starting ServerI0707 00:45:45.834488p2p/discover/udp.go:217] Listening,enode://134881790e54c803955715e3661c27f91caaf499be813e29c9f986e2eac62d47e02b13a8e51776c1caea554655614ed26ce0185d84e626da7ac48a83a60113ff@[::]:30303I0707 00:45:45.835853 node/node.go:366]HTTP endpoint opened: http://localhost:8545I0707 00:45:45.848008 p2p/server.go:556]Listening on [::]:30303I0707 00:45:45.849731 node/node.go:296] IPCendpoint opened: /home/lihe/桌面/chain/geth.ipcWelcome to the Geth JavaScript console! instance:Geth/v1.5.0-unstable/linux/go1.5.1/PICCetherumcoinbase:0x93509a2f4b2b974b07ef0b52e07c3992601f5de1at block: 81 (Tue, 05 Jul 2016 21:02:25CST) datadir: /home/lihe/桌面/chain modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0&gt; 可以看到Listening on [::]:30303和Welcome to the Geth JavaScript console!的提示，说明已经启动成功 注意：如果想将Ubuntu作为永久区块链节点使用，当使用nohup命令时，Geth启动参数console必须去掉，否则Geth会自动停止。 在windows启动区块链节点进入Windows下Geth的目录 ，放置配置好的piccgenesis.json文件，执行如下命令：1$ geth --datadir \"%cd%\\chain\" init piccgenesis.json 创建数据存放地址并初始化创世块1$ geth--identity \"PICCetherum\" --rpc--rpccorsdomain \"*\" --datadir \"%cd%\\chain\" --port\"30303\" --rpcapi\"db,eth,net,web3\" --networkid 95518 console 当看到Listening on [::]:30303和Welcome to the Geth JavaScript console!的提示，说明已经启动成功 使用节点创建账号启动节点成功后，会进入Geth的命令行模式，输入如下命令1personal.newAccount() 系统会提示你输入账号密码，并确认，最后会显示一个新生成的账号。 Geth JavaScript控制台环境使用说明 创建新账号personal.newAccount()或者 personal.newAccount(&quot;123456&quot;) 查看节点信息admin.nodeInfo 挖矿 开始挖矿miner.start(1) 停止挖矿miner.stop() 查看当前矿工账号eth.coinbase 默认为第一个账户 修改矿工账号miner.setEtherbase(eth.accounts[1]) 查看账户信息eth.accounts[0] 查看账户余额eth.getBalance(eth.accounts[0])或者 web3.fromWei(eth.getBalance(eth.accounts[0]), &quot;ether&quot;) 解锁账号personal.unlockAccount(eth.accounts[0])使用账户资金前都需要先解锁账号 转账eth.sendTransaction({from:eth.accounts[0],to:&quot;0x587e57a516730381958f86703b1f8e970ff445d9&quot;,value:web3.toWei(3,&quot;ether&quot;)})使用 txpool.status可以看到交易状态 查看区块数据 eth.blockNumber eth.getTransaction(&quot;0x0c59f431068937cbe9e230483bc79f59bd7146edc8ff5ec37fea6710adcab825&quot;) eth.getBlock(1) 通过区块号查看区块 私有链图形节点启动Ubuntu下私有链图形节点首先按上面的步骤启动Geth并创建了账号，在geth运行的时候，再运行下面的命令1ethereumwallet --gethpath /usr/bin/geth --gethpath改成你实际安装的geth的路径 启动Windows下私有链图形节点首先按上面的步骤启动Geth并创建了账号，然后解压缩Ethereum-Wallet，运行Ethereum-Wallet.exe,即启动成功，如果区块链正常的话，会在右上角显示“PRIVATE-NET”，点击“LAUNCH APPLICATION”进入图形界面即可。 连接其他节点首先要知道自己的节点信息，在Geth命令行界面下输入命令,注意大小写1admin.nodeInfo 系统会显示1enode:\"enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303“ 其中enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@0.0.0.0:30303就是自己节点的信息，注意要把0.0.0.0换成你自己的IP。将这个信息发送给其他节点，在其他节点的命令行中输入：1admin.addPeer(‘enode://1e3c1727cd3bee9f25edeb5dbb3b880e03e41f8eec99566557f3ee0422734a8fcad17c161aa93d61bdbfb28ed152c143c7eb501db58bc63502a104a84b62d742@192.168.1.101:30303’) 如果添加成功，输入admin.peers会显示出新添加的节点。 使用节点进行挖矿在Geth命令行界面下，输入miner.start()即启动挖矿，挖矿后，会不停刷屏，输入miner.stop()即停止，不用管刷屏导致的命令不全，命令会正常执行。到这一步，已经组建一个私有链的网络，可以像其他区块链一样不停的扩充这个网络，下一篇文章，我会介绍如何在私有链上编写、调试和部署智能合约。 参考文章： http://blog.csdn.net/sportshark/article/details/51855007 http://tech.lab.carl.pro/kb/ethereum/testnet_setup http://www.ethdocs.org/en/latest/network/test-networks.html#setting-up-a-local-private-testnet https://github.com/ethereum/go-ethereum/wiki/Connecting-to-the-network https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console https://github.com/ethereum/go-ethereum/wiki/Mining https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts https://github.com/janx/ethereum-bootstrap https://forum.qtum.org/topic/127/以太坊私链与智能合约部署入门教程/2","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://xichen.pub/tags/区块链/"}]},{"title":"ubuntu--apt-get update（由于没有公钥，无法验证下列签名）","slug":"2017-11-29-apt-get-update-GPG错误","date":"2017-11-29T13:52:00.000Z","updated":"2018-01-05T00:45:28.288Z","comments":true,"path":"2017/11/29/2017-11-29-apt-get-update-GPG错误/","link":"","permalink":"http://xichen.pub/2017/11/29/2017-11-29-apt-get-update-GPG错误/","excerpt":"","text":"当 apt-get update 更新后，出现下面错误时的解决方法：123...bash正在读取软件包列表… 完成 W: GPG 错误：http://ppa.launchpad.net trusty InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 2EA8F35793D8809A 解决办法:1$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9 结果：12345Executing: gpg –ignore-time-conflict –no-options –no-default-keyring –secret-keyring /tmp/tmp.uxUmi4wF1r –trustdb-name /etc/apt/trustdb.gpg –keyring /etc/apt/trusted.gpg –primary-keyring /etc/apt/trusted.gpg –keyserver keyserver.ubuntu.com –recv-keys 2EA8F35793D8809A gpg: 下载密钥‘93D8809A’，从 hkp 服务器 keyserver.ubuntu.com gpg: 密钥 93D8809A：公钥“Launchpad PPA for Martin Wimpress”已导入 gpg: 合计被处理的数量：1 gpg: 已导入：1 (RSA: 1)","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://xichen.pub/tags/ubuntu/"}]},{"title":"Go 爬虫总结","slug":"2017-11-27-go爬虫总结","date":"2017-11-27T13:52:00.000Z","updated":"2018-01-05T00:45:28.287Z","comments":true,"path":"2017/11/27/2017-11-27-go爬虫总结/","link":"","permalink":"http://xichen.pub/2017/11/27/2017-11-27-go爬虫总结/","excerpt":"","text":"爬虫目的：爬导航和爬商品 爬虫架构： electron虚拟浏览器 proxy代理ip dashboard网页端调控 爬虫APP 实现的功能： url拼接，过滤出商品 url翻页，点击翻页，无限流，loadmore按钮 过滤文本中包含某text的url，过滤url中包含某url的url，定点过滤特定的url，只爬文本中包含某text的url，只爬url中包含某url的url 失败移至末尾重试（次数，本次返回的状态码，延时） 控制爬取频率，控制递归爬取深度 用electron防止cookie或ajax动态加载页面，有WaitSelector，直到WaitSelector出现才返回渲染后的页面给spider，否则返回错误码 分布式，高并发 多个proxy负载均衡 proxy权限控制 dashboard网页端爬虫调度，导航log和简单报表分析，商品log和简单报表分析，服务器上当前所有配置一览 我负责的模块： 配置文件template 测试被反爬虫的条件，计算最大爬取频率 实现同时爬取多个网站，单线程和并发可选 默认 http client 不会缓存 DNS 记录，而爬虫会有大量的请求，所以自己专门对 DNS 做缓存 调查并分析站点请求不成功的url占比超过 20% 的原因并修复 发现并解决 ssl 证书问题 网站改版，及时更新配置文件 给timeout设一个下界 返回408原因：（1）商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408（2）翻页超过最大页数，没有商品，返回408。这个原因导致的408一般 成堆 出现（3）无限流需要较长时间来翻页，timeout较小会408（4）目标网站有的商品下架，没有商品，返回408（5）目标网站反爬策略，封ip后也不返回500，只有提示性的html，等不到商品，返回408（6）目标网站必须用https 解决方案：（这几个印象深刻，其他的想不起来了） 商品Selector作为WaitSelector，有的页面是介绍页，没有商品，返回408 有2个waitSelector，一个Selector做监督，一个选商品Selector，如果监督Selector出现了而商品Selector没出来，就判定没商品 效果好 时间成本高 只要1个errorSelector，出现提示性的error，判定为没有商品 实现简单，时间成本低，逻辑清晰 不全面，有些站点如果没有商品，也不出现提示性文字 electron不处理，无论是否408都把页面返回，交给spider处理 electron端实现简单，效果好，易于扩展 spider端实现困难，给spider端挖坑，有隐患 ssl 证书问题 请求时不检测证书 http 请求 换成https请求 getsockopt: no route to host 和firewall有关，我们对昂贵的proxy做权限控制，而我在本地没有这个proxy的权限，必须到服务器上搞 getsockopt: connection time out 需要特殊的header，不然在命令行是不能成功请求的 DNS解析 原来的每次都要new一个，修复后只要一个持久化 团队共享用到的软件（我们都是远程办公） slack:交流讨论 quip：共享文件 trello：任务管理 zoom：远程会议 google图表：共享文件","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://xichen.pub/tags/Go/"},{"name":"Spider","slug":"Spider","permalink":"http://xichen.pub/tags/Spider/"}]},{"title":"Ubuntu中使用dpkg安装deb文件提示依赖关系问题，仍未被配置","slug":"2017-10-11-dpkg-error","date":"2017-10-14T17:54:00.000Z","updated":"2018-01-05T00:45:28.283Z","comments":true,"path":"2017/10/15/2017-10-11-dpkg-error/","link":"","permalink":"http://xichen.pub/2017/10/15/2017-10-11-dpkg-error/","excerpt":"","text":"使用dpkg时，提示：dpkg：处理软件包XXX时出错：依赖关系问题，仍未被配置 问题 出现上图时，使用如下命令1sudo apt-get install -f 解决 等分析完之后，重新使用dpkg –i XXX.deb，就可以了 解决","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Python Tweepy 翻墙抓取Twitter信息","slug":"2017-10-11-python-proxy","date":"2017-10-13T02:13:00.000Z","updated":"2018-01-05T00:45:28.284Z","comments":true,"path":"2017/10/13/2017-10-11-python-proxy/","link":"","permalink":"http://xichen.pub/2017/10/13/2017-10-11-python-proxy/","excerpt":"","text":"repo在此，如果觉得做得好，给个star鼓励下吧！ 在看《Python数据挖掘入门与实践》的时候，随书附带的代码已经过时几年了，现在边看书边修，很是辛苦 在学习第六章”使用朴素贝叶斯进行社交媒体挖掘”时，数据集需要通过twitter的API来获取 （玛蛋，为毛不随书附带数据集） twitter在国内被墙了，只能翻墙 浏览器翻墙容易，弄个lantern或者shadowsockets就可以了 但是，由于ubuntu的代理不是全局代理，在命令行中翻墙要设proxy，在代码中翻墙也要设proxy 所以难处在于代码要就twitter的python接口翻墙 如果只是一个简单的加proxy网络请求，几行就可以搞定： 12import urllib.requestproxy_support = urllib.request.ProxyHandler(&#123;'http' : 'http://127.0.0.1:80'&#125;) 可是twitter的python接口是自动发起请求的呀 懒得去改源码 只好看看怎么在代码中设置好翻墙 账号准备首先需要在twitter官方注册twitter账号，并新建一个应用，链接：新建应用如果新建应用不成功，国内大多数情况都是无法验证手机号，可以参考这个教程，亲测有效，链接：验证手机号注册成功后，可以查看自己的keys and access token，如下图： Consumer Key and Consumer Secret Access Token and Access Token Secret 环境准备python3.5+ 安装tweepy： 在命令行中输入：pip install tweepy 发起请求12345678910111213141516# -*- coding: utf-8 -*-import tweepyfrom tweepy import OAuthHandlerconsumer_key = 'replace your own account consumer_key'consumer_secret = 'replace your own account consumer_secret'access_token = 'replace your own account access_token'access_secret = 'replace your own account access_secret'auth = OAuthHandler(consumer_key,consumer_secret)auth.set_access_token(access_token,access_secret)api = tweepy.API(auth)for status in tweepy.Cursor(api.home_timeline).items(2): print (status.text) 报错一:挂代理翻墙报错信息如下： 1tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x0000000002FC6E80&gt;: Failed to establish a new connection: [Errno 10061] ',))) 主要原因就是twitter被墙了，twitter的api当然也被墙了。 这时候就需要挂代理翻墙了，我使用的是自己搭建的shadowsockets。其它翻墙软件或者服务器网上有很多，请自行查找。 代理打开了之后，在原代码中，将1api = tweepy.API(auth) 改为1api = tweepy.API(auth,proxy=\"127.0.0.1:1080\") 报错二:请求的配置没有写对报错信息如下： 1tweepy.error.TweepError: Twitter error response: status code = 401 原因： 这几个发起请求的配置没有写对，仔细修改 consumer_key consumer_secret access_token access_secret 改过了还是不对，刷新Regenerate Consumer Key and Secret和Regenerate My Access Token and Token Secret，重新填写请求 报错三报错信息如下： 1tweepy.error.TweepError: Failed to send request: HTTPSConnectionPool(host='api.twitter.com', port=443): Max retries exceeded with url: /1.1/statuses/home_timeline.json (Caused by ProxyError('Cannot connect to proxy.', timeout('timed out',))) 原因是Shadowsocks使用的是socks5代理，并非是http代理。 emmm，简单，大手一挥，稍微修改一下即可 1api = tweepy.API(auth, proxy=\"socks5://127.0.0.1:1080\") 报错四报错信息如下： 1tweepy.error.TweepError: Failed to send request: SOCKSHTTPSConnectionPool(host='api.twitter.com', port=443): Read timed out. (read timeout=60) 原因是tweepy使用的是http代理，不能用socks5代理（我日）。 所以需要将socks5代理转换为http代理来支持tweepy访问twitter REST API,这里参考以下地址：为终端设置Shadowsocks代理 最后不要忘记在代码里加上代理： 1api = tweepy.API(auth, proxy=\"127.0.0.1:8123\") 还没完 tweepy 这个库的资料比较少,我自己摸索着试了试,把代码发上来 一.按照关键字搜索Twitter的内容 12345678910#接上面的代码(q = 关键字 ,count = 返回的数据量 . 推特一次最多返回100条??)search_results = api.search(q='python',count=100)#对对象进行迭代for tweet in search_results: #tweet还是一个对象,推特的相关信息在tweer._json里 #这里是检测消息是否含有'text'键,并不是所有TWitter返回的所有对象都是消息(有些可能是用来删除消息或者其他内容的动作--这个没有确认),区别就是消息对象中是否含有'text'键 if 'text' in tweet._json: print(tweet._json['text']) #这里是把内容给打印出来了,如果需要保存到文件需要用json库的dumps函数转换为字符串形式后写入到文件中 #例如 :output_file.write(json.dumps(tweet._json)) 二.根据Twitter消息的ID批量获取消息12#其中id_list 是消息ID组成的list 长度也不要超过100search_result = api.statuses_lookup(id_list) 这时，就可以成功访问了 成功访问","categories":[{"name":"Python","slug":"Python","permalink":"http://xichen.pub/categories/Python/"},{"name":"Proxy","slug":"Python/Proxy","permalink":"http://xichen.pub/categories/Python/Proxy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://xichen.pub/tags/Python/"},{"name":"Proxy","slug":"Proxy","permalink":"http://xichen.pub/tags/Proxy/"}]},{"title":"algorithms-Bit-Options","slug":"2017-10-11-算法之位运算","date":"2017-10-11T06:25:00.000Z","updated":"2018-01-05T00:45:28.285Z","comments":true,"path":"2017/10/11/2017-10-11-算法之位运算/","link":"","permalink":"http://xichen.pub/2017/10/11/2017-10-11-算法之位运算/","excerpt":"","text":"算法常用的一个等式：-n = ~(n - 1) = ~n + 1 获得int型最大值123456int getMaxInt()&#123; return (1 &lt;&lt; 31) - 1;//2147483647,由于优先级关系,括号不可省略 return ~(1 &lt;&lt; 31); //2147483647 return (1 &lt;&lt; -1) - 1;//2147483647 return ((unsigned int) - 1) &gt;&gt; 1;//2147483647&#125; 获得int型最小值1234int getMinInt()&#123; return 1 &lt;&lt; 31;//-2147483648 return 1 &lt;&lt; -1;//-2147483648&#125; 获得long类型的最大值1234long getMaxLong()&#123; return ((unsigned long) - 1) &gt;&gt; 1;//2147483647 c语言版 return ((long)1 &lt;&lt; 127) - 1;//9223372036854775807 java版&#125; 获得long最小值，和其他类型的最大值，最小值同理. 2运算1234n &lt;&lt; 1 // 乘以2n &gt;&gt; 1 // 除以2n &lt;&lt; m // 乘以2的m次方n &gt;&gt; m // 除以2的m次方 判断一个数的奇偶性123boolean isOddNumber(int n)&#123; return (n &amp; 1) == 1;&#125; 不用临时变量交换两个数（面试常考）123void swap(int *a,int *b)&#123; (*a) ^= (*b) ^= (*a) ^= (*b);&#125; 通用版（一些语言中得分开写）123a ^= b;b ^= a;a ^= b; 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高） 123456int abs(int n)&#123; return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31);/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */&#125; 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高） 1234int max(int a,int b)&#123; return b &amp; ((a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125; C语言版12345int max(int x,int y)&#123; return x ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高） 1234int min(int a,int b)&#123; return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31); /*如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1*/&#125; C语言版12345int min(int x,int y)&#123; return y ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/&#125; 判断符号是否相同123boolean isSameSign(int x, int y)&#123; //有0的情况例外 return (x ^ y) &gt;= 0; // true 表示 x和y有相同的符号， false表示x，y有相反的符号。&#125; 计算2的n次方123int getFactorialofTwo(int n)&#123;//n &gt; 0 return 2 &lt;&lt; (n-1);//2的n次方&#125; 判断一个数是不是2的幂12345boolean isFactorialofTwo(int n)&#123; return n &gt; 0 ? (n &amp; (n - 1)) == 0 : false; /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果为0*/&#125; 对2的n次方取余12345int quyu(int m,int n)&#123;//n为2的次方 return m &amp; (n - 1); /*如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果保留m在n范围的非0的位*/&#125; 求两个整数的平均值12345678int getAverage(int x, int y)&#123; return (x + y) &gt;&gt; 1;&#125;int getAverage(int x, int y)&#123; return ((x ^ y) &gt;&gt; 1) + (x &amp; y); /*(x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2， x&amp;y得到x，y都为1的部分，加一起就是平均数了*/&#125; 下面是三个最基本对二进制位的操作 从低位到高位,取n的第m位123int getBit(int n, int m)&#123; return (n &gt;&gt; (m-1)) &amp; 1;&#125; 从低位到高位.将n的第m位置设为112345int setBitToOne(int n, int m)&#123; return n | (1 &lt;&lt; (m-1)); /*将1左移m-1位找到第m位，得到000...1...000 n在和这个数做或运算*/&#125; 从低位到高位,将n的第m位置设为012345int setBitToZero(int n, int m)&#123; return n &amp; ~(1 &lt;&lt; (m-1)); /* 将1左移m-1位找到第m位，取反后变成111...0...1111 n再和这个数做与运算*/&#125; 另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）123456n+1 = -~nn-1 = ~-n-n = ~n+1-n = (n^-1)+1x = a ^ b ^ x &lt;=&gt; if(x == a) x = b; if(x == b) x = a;sign(x) = !!n - (((unsigned)n &gt;&gt; 31) &lt;&lt; 1) 获取整数二进制表示中最右侧的11n &amp; (-n) &lt;=&gt; n &amp; ~(n - 1) 二进制中1的个数用到了n &amp; (n - 1)由x &amp; (x - 1)消去x最后一位的1可知。不断使用 x &amp; (x - 1) 消去x最后一位的1，计算总共消去了多少次即可。12345678int countOnes(int num) &#123; int count = 0; while(num != 0) &#123; num = num &amp; (num-1); count++; &#125; return count;&#125; 翻转123456789// 翻转unsigned int Bit_Reverse(unsigned int v) &#123; v = ((v &gt;&gt; 1) &amp; 0x55555555) | ((v &lt;&lt; 1) &amp; 0xaaaaaaaa); v = ((v &gt;&gt; 2) &amp; 0x33333333) | ((v &lt;&lt; 2) &amp; 0xcccccccc); v = ((v &gt;&gt; 4) &amp; 0x0f0f0f0f) | ((v &lt;&lt; 4) &amp; 0xf0f0f0f0); v = ((v &gt;&gt; 8) &amp; 0x00ff00ff) | ((v &lt;&lt; 8) &amp; 0xff00ff00); v = ((v &gt;&gt; 16) &amp; 0x0000ffff) | ((v &lt;&lt; 16) &amp; 0xffff0000); return v;&#125; 输入两个数A和B，输出将A转换为B所需改变的二进制的位数。首先，A异或B得到的是A和B中不相同位数组成的数，然后再求这个数二进制表示中1的个数，即为所求。1countOnes(A^B); 数组中只出现一次的数字用到了n &amp; (n - 1) 和 a ^ b ^ b = a 数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数因为只有一个数恰好出现一个，剩下的都出现过两次，所以只要将所有的数异或起来，就可以得到唯一的那个数。参考文章：http://zhedahht.blog.163.com/blog/static/2541117420071128950682/ 数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的数因为数是出现三次的，也就是说，对于每一个二进制位，如果只出现一次的数在该二进制位为1，那么这个二进制位在全部数字中出现次数无法被3整除。 膜3运算只有三种状态：00,01,10，因此我们可以使用两个位来表示当前位%3，对于每一位，我们让Two，One表示当前位的状态，B表示输入数字的对应位，Two+和One+表示输出状态。 参考文章：http://zhedahht.blog.163.com/blog/static/25411174201283084246412/ 数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的数有了第一题的基本的思路，我们可以将数组分成两个部分，每个部分里只有一个元素出现一次，其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。不妨假设出现一个的两个元素是x，y，那么最终所有的元素异或的结果就是res = x^y。并且res！=0，那么我们可以找出res二进制表示中的某一位是1。对于原来的数组，我们可以根据这个位置是不是1就可以将数组分成两个部分。x，y在不同的两个子数组中。而且对于其他成对出现的元素，要么在x所在的那个数组，要么在y所在的那个数组。 位操作实现加减乘除运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//加法int BinaryAdd(int a, int b) &#123; int carry, add; do &#123; add = a ^ b; //该操作得到本位的加法结果 carry = (a &amp; b) &lt;&lt; 1; //该操作得到该位对高位的进位值 a = add; b = carry; &#125; while (carry != 0); //循环直到某次运算没有进位，运算结束 return add;&#125;//减法int BinarySub(int a, int b) &#123; return BinaryAdd(a, BinaryAdd(~b, 1));&#125;/*乘法 该过程中的bit_map是为了快速得到乘法过程中某位相乘的中间结果S[i] 需要位移的位数。bit_map的键值是2^0, 2^1,2^2, ……之类的数，对应的 值是0，1,2,……(即需要位移的位数)。 */int BinaryMultiply(int a, int b) &#123; bool neg = (b &lt; 0); if(b &lt; 0) b = -b; int sum = 0; map&lt;int, int&gt; bit_map; for(int i = 0; i &lt; 32; i++) &#123; bit_map.insert(pair&lt;int, int&gt;(1 &lt;&lt; i, i)); &#125; while(b &gt; 0) &#123; /* b &amp; ~(b - 1)可以得到乘数b的二进制表示中最右侧1的位置 last_bit记录被乘数a需要位移的位数 */ int last_bit = bit_map[b &amp; ~(b - 1)]; //将得到的乘法结果全部相加即为最后结果 sum += (a &lt;&lt; last_bit); b &amp;= b - 1; //每次将b的二进制表示的最右侧1去掉用于下一次乘法 &#125; if(neg) sum = -sum; return sum;&#125;//除法int BinaryDivide(int a, int b)&#123; bool neg = (a &gt; 0) ^ (b &gt; 0); if(a &lt; 0) a = -a; if(b &lt; 0) b = -b; if(a &lt; b) return 0; int msb = 0; //msd记录除数需要左移的位数 for(msb = 0; msb &lt; 32; msb++) &#123; if((b &lt;&lt; msb) &gt;= a) break; &#125; int q = 0; //记录每次除法的商 for(int i = msb; i &gt;= 0; i--) &#123; if((b &lt;&lt; i) &gt; a) continue; q |= (1 &lt;&lt; i); a -= (b &lt;&lt; i); &#125; if(neg) return -q; return q;&#125; reference: 优秀程序员不得不知道的20个位运算技巧http://blog.csdn.net/zmazon/article/details/8262185 位操作实现加减乘除四则运算http://blog.csdn.net/u013074465/article/details/42680239","categories":[{"name":"algorithms","slug":"algorithms","permalink":"http://xichen.pub/categories/algorithms/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://xichen.pub/tags/算法/"}]},{"title":"面向过程，面向对象，函数式","slug":"2017-9-18-面向过程-面向对象-函数式","date":"2017-09-17T22:42:14.000Z","updated":"2018-01-05T00:45:28.299Z","comments":true,"path":"2017/09/18/2017-9-18-面向过程-面向对象-函数式/","link":"","permalink":"http://xichen.pub/2017/09/18/2017-9-18-面向过程-面向对象-函数式/","excerpt":"","text":"如何把大象关进冰箱里？面向过程：1把冰箱门打开 =&gt; 大象放冰箱里 =&gt; 冰箱门关上 面向对象：123冰箱.开门（）冰箱.放入（大象）冰箱.关门（） or 1冰箱.开门().放入(大象).关门() 函数式：12关进（冰箱，大象）: 关门（放入（开门（冰箱），大象））","categories":[{"name":"杂思","slug":"杂思","permalink":"http://xichen.pub/categories/杂思/"}],"tags":[{"name":"杂思","slug":"杂思","permalink":"http://xichen.pub/tags/杂思/"}]},{"title":"terminal tips","slug":"2017-08-28-Terminal-tips","date":"2017-08-27T20:46:00.000Z","updated":"2018-01-05T00:45:28.282Z","comments":true,"path":"2017/08/28/2017-08-28-Terminal-tips/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Terminal-tips/","excerpt":"","text":"打开 快捷键：Ctrl+Alt-T 空白处右键：有选项在终端打开 处于命令行窗口：Ctrl+T选项卡形式，Ctrl+N窗口形式 颜色颜色代码 前景 背景 颜色 30 40 黑色 31 41 紅色 32 42 綠色 33 43 黃色 34 44 藍色 35 45 紫紅色 36 46 青藍色 37 47 白色 ——- ———– ——— 1 透明色 ——- 代码 意义 0 OFF 1 高亮显示 4 underline 5 闪烁 7 反白显示 8 不可见 序列说明 | \\a | ASCII响铃字符（也可以键入 \\007） | | \\d | “Wed Sep 06”格式的日期 | | \\e | ASCII转义字符（也可以键入 \\033） | | \\h | 主机名的第一部分（如 “mybox”） | | \\H | 主机的全称（如 “mybox.mydomain.com”） | | \\j | 在此 shell中通过按 ^Z挂起的进程数 | | \\l | 此 shell的终端设备名（如 “ttyp4”） | | \\n | 换行符 | | \\r | 回车符 | | \\s | shell的名称（如 “bash”） | | \\t | 24小时制时间（如 “23:01:01”） | | \\T | 12小时制时间（如 “11:01:01”） | | \\@ | 带有 am/pm的 12小时制时间 | | \\u | 用户名 | | \\v | bash的版本（如 2.04） | | \\V | Bash版本（包括补丁级别） ?/td&gt;; | | \\w | 当前工作目录（如 “/home/drobbins”） | | \\W | 当前工作目录的“基名 (basename)”（如 “drobbins”） | | ! | 当前命令在历史缓冲区中的位置 | | # | 命令编号（只要您键入内容，它就会在每次提示时累加） | | \\$ | 如果您不是超级用户 (root)，则插入一个 “$”；如果您是超级用户，则显示一个 “#” | | \\xxx | 插入一个用三位数 xxx（用零代替未使用的数字，如 “/007”）表示的 ASCII 字符 | | \\ | 反斜杠 | | [ | 这个序列应该出现在不移动光标的字符序列（如颜色转义序列）之前。它使 bash能够正确计算自动换行。 | | ] | 这个序列应该出现在非打印字符序列之后。 | 颜色的设置公式1颜色=\\033[代码;前景;背景m 如：\\033[1;32;40m表示高亮显示字体为绿色，背景色为黑色（颜色定义见本文前面的表格） 注意： 要将全部非打印字符用专用的 bash 转义序列 “[“和 “]“括起来。这两个序列通知 bash，被括起来的字符不占用行上的任何空间，这样就使自动换行能够继续正常工作。 这点很关键要不然等你设好了颜色，你的终端换行会乱七八糟 套路默认的就很好看，打开~/.bashrc，其中有几行声明 12345if [ \"$color_prompt\" = yes ]; then PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ 'else PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ 'fi 下面这个就是默认的配色方案1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 要修改配色方案，在文件末尾加上1PS1=`balabala` ROOT身份下的终端颜色打开/root/.bash.rc1vi /root/.bash.rc 按i进入插入字符模式，在文件末尾加上一行(把默认的贴过去)1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 按下Esc然后输入:wq保存修改 再输入source ~/.bashrc刷新 SSH会话下的终端颜色通过在.bashrc文件中更改与ssh连接的每个主机名上的PS1值 在托管的机器上(lxy @ ubuntu)同样打开文件~/.bashrc1vi ~/.bashrc 在文件末尾加上一行(把默认的贴过去)1PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' 按下Esc然后输入:wq保存修改 再输入source ~/.bashrc刷新 zsh安装zsh1sudo apt-get install zsh 安装oh-my-zsh12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/tmplates/zshrc.zsh-template ~/.zshrc Powerline 主题1234git clone git://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme ~/.ohmyzsh-powerlinecd ~/.ohmyzsh-powerlinecp powerline.zsh-theme ~/.oh-my-zsh/themes/powerline.zsh-themerm -rf ~/.ohmyzsh-powerline 把zsh设为默认1chsh -s /bin/zsh 卸载zsh1sudo apt remove zsh 今天手残装了zsh和oh-my-zsh后又卸载掉，导致su进不去1无法执行 /usr/bin/zsh: 没有那个文件或目录 只要把 /usr/bin/zsh 改成 /bin/bash 就可以了1sudo vim /etc/passwd 第一句改成1root:x:0:0:root:/root:/bin/bash 或者直接运行1sudo chsh -s /bin/bashrc","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"}]},{"title":"Golang程序配置方案小结","slug":"2017-08-28-Golang-setting","date":"2017-08-27T20:19:00.000Z","updated":"2018-01-05T00:45:28.281Z","comments":true,"path":"2017/08/28/2017-08-28-Golang-setting/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Golang-setting/","excerpt":"","text":"背景无论使用任何编程语言开发应用，都离不开配置数据。配置数据提供的形式有多样，不外乎命令行选项(options)、参数（parameters)，环境 变量（env vars)以及配置文件等。Golang也不例外。Golang内置flag标准库，可以用来支持部分命令行选项和参数的解析；Golang通过os包提 供的方法可以获取当前环境变量；但Golang没有规定标准配置文件格式(虽说内置支持xml、json)，多通过第三方 包来解决配置文件读取的问题。Golang配置相关的第三方包邮很多，作者在本文中给出的配置方案中就包含了主流的第三方配置数据操作包。 一个良好的应用配置层次应该是这样的： 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。 下面循序渐进探讨golang程序配置方案。 解析命令行选项和参数这一节关注golang程序如何访问命令行选项和参数。 golang对访问到命令行参数提供了内建的支持：1234567891011121314151617181920212223//cmdlineargs.gopackage mainimport ( // \"fmt\" \"os\" \"path/filepath\")func main() &#123; println(\"I am \", os.Args[0]) baseName := filepath.Base(os.Args[0]) println(\"The base name is \", baseName) // The length of array a can be discovered using the built-in function len println(\"Argument # is \", len(os.Args)) // the first command line arguments if len(os.Args) &gt; 1 &#123; println(\"The first command line argument: \", os.Args[1]) &#125;&#125; 执行结果如下：123456$go build cmdlineargs.go$cmdlineargs test oneI am cmdlineargsThe base name is cmdlineargsArgument # is 3The first command line argument: test 对于命令行结构复杂一些的程序，我们最起码要用到golang标准库内置的flag包：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//cmdlineflag.gopackage mainimport ( \"flag\" \"fmt\" \"os\" \"strconv\")var ( // main operation modes write = flag.Bool(\"w\", false, \"write result back instead of stdout\\n\\t\\tDefault: No write back\") // layout control tabWidth = flag.Int(\"tabwidth\", 8, \"tab width\\n\\t\\tDefault: Standard\") // debugging cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to this file\\n\\t\\tDefault: no default\"))func usage() &#123; // Fprintf allows us to print to a specifed file handle or stream fmt.Fprintf(os.Stderr, \"\\nUsage: %s [flags] file [path ...]\\n\\n\", \"CommandLineFlag\") // os.Args[0] flag.PrintDefaults() os.Exit(0)&#125;func main() &#123; fmt.Printf(\"Before parsing the flags\\n\") fmt.Printf(\"T: %d\\nW: %s\\nC: '%s'\\n\", *tabWidth, strconv.FormatBool(*write), *cpuprofile) flag.Usage = usage flag.Parse() // There is also a mandatory non-flag arguments if len(flag.Args()) &lt; 1 &#123; usage() &#125; fmt.Printf(\"Testing the flag package\\n\") fmt.Printf(\"T: %d\\nW: %s\\nC: '%s'\\n\", *tabWidth, strconv.FormatBool(*write), *cpuprofile) for index, element := range flag.Args() &#123; fmt.Printf(\"I: %d C: '%s'\\n\", index, element) &#125;&#125; 这个例子中： 说明了三种类型标志的用法：Int、String和Bool。 说明了每个标志的定义都由类型、命令行选项文本、默认值以及含义解释组成。 最后说明了如何处理标志选项(flag option)以及非option参数。 不带参数运行：1234567891011121314$cmdlineflagBefore parsing the flagsT: 8W: falseC: ''Usage: CommandLineFlag [flags] file [path ...] -cpuprofile=\"\": write cpu profile to this file Default: no default -tabwidth=8: tab width Default: Standard -w=false: write result back instead of stdout Default: No write back 带命令行标志以及参数运行(一个没有flag，一个有两个flag)：12345678910111213141516171819202122$cmdlineflag aa bbBefore parsing the flagsT: 8W: falseC: ''Testing the flag packageT: 8W: falseC: ''I: 0 C: 'aa'I: 1 C: 'bb'$cmdlineflag -tabwidth=2 -w aaBefore parsing the flagsT: 8W: falseC: ''Testing the flag packageT: 2W: trueC: ''I: 0 C: 'aa' 从例子可以看出，简单情形下，你无需编写自己的命令行parser或使用第三方包，使用go内建的flag包即可以很好的完成工作。但是golang的 flag包与命令行Parser的事实标准：Posix getopt（C/C++/Perl/Shell脚本都可用）相比，还有较大差距，主要体现在： 无法支持区分long option和short option，比如：-h和–help。 不支持short options合并，比如：ls -l -h &lt;=&gt; ls -hl 命令行标志的位置不能任意放置，比如无法放在non-flag parameter的后面。 不过毕竟flag是golang内置标准库包，你无须付出任何cost，就能使用它的功能。另外支持bool型的flag也是其一大亮点。 TOML，Go配置文件的事实标准（这个可能不能得到认同）命令行虽然是一种可选的配置方案，但更多的时候，我们使用配置文件来存储静态的配置数据。就像Java配xml，ruby配yaml，windows配 ini，Go也有自己的搭配组合，那就是TOML（Tom’s Obvious, Minimal Language）。 初看toml语法有些类似windows ini，但细致研究你会发现它远比ini强大的多，下面是一个toml配置文件例子：123456789101112131415161718192021222324252627282930313233# This is a TOML document. Boom.title = \"TOML Example\"[owner]name = \"Lance Uppercut\"dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?[database]server = \"192.168.1.1\"ports = [ 8001, 8001, 8002 ]connection_max = 5000enabled = true[servers] # You can indent as you please. Tabs or spaces. TOML don't care. [servers.alpha] ip = \"10.0.0.1\" dc = \"eqdc10\" [servers.beta] ip = \"10.0.0.2\" dc = \"eqdc10\"[clients]data = [ [\"gamma\", \"delta\"], [1, 2] ]# Line breaks are OK when inside arrayshosts = [ \"alpha\", \"omega\"] 看起来很强大，也很复杂，但解析起来却很简单。以下面这个toml 文件为例：12345Age = 25Cats = [ \"Cauchy\", \"Plato\" ]Pi = 3.14Perfection = [ 6, 28, 496, 8128 ]DOB = 1987-07-05T05:45:00Z 和所有其他配置文件parser类似，这个配置文件中的数据可以被直接解析成一个golang struct：1234567type Config struct &#123; Age int Cats []string Pi float64 Perfection []int DOB time.Time // requires `import time`&#125; 其解析的步骤也很简单：1234var conf Configif _, err := toml.Decode(tomlData, &amp;conf); err != nil &#123; // handle error&#125; 是不是简单的不能简单了！ 不过toml也有其不足之处。想想如果你需要使用命令行选项的参数值来覆盖这些配置文件中的选项，你应该怎么做？事实上，我们常常会碰到类似下面这种三层配置结构的情况： 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。 在go中，toml映射的结果体字段没有初始值。而且go内建flag包也没有将命令行参数值解析为一个go结构体，而是零散的变量。这些可以通过第三方工具来解决，但如果你不想用第三方工具，你也可以像下面这样自己解决，虽然难看一些。1234567891011121314151617181920212223242526func ConfigGet() *Config &#123; var err error var cf *Config = NewConfig() // set default values defined in the program cf.ConfigFromFlag() //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) // Load config file, from flag or env (if specified) _, err = cf.ConfigFromFile(*configFile, os.Getenv(\"APPCONFIG\")) if err != nil &#123; log.Fatal(err) &#125; //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) // Override values from command line flags cf.ConfigToFlag() flag.Usage = usage flag.Parse() cf.ConfigFromFlag() //log.Printf(\"P: %d, B: '%s', F: '%s'\\n\", cf.MaxProcs, cf.Webapp.Path) cf.ConfigApply() return cf&#125; 就像上面代码中那样，你需要： 用命令行标志默认值设置配置(cf)默认值。 接下来加载配置文件 用配置值(cf)覆盖命令行标志变量值 解析命令行参数 用命令行标志变量值覆盖配置(cf)值。 少一步你都无法实现三层配置能力。 超越TOML本节将关注如何克服TOML的各种局限。 为了达成这个目标，很多人会说：使用viper，不过在介绍viper这一重量级选手 之前，我要为大家介绍另外一位不那么知名的选手：multiconfig。 有些人总是认为大的就是好的，但我相信适合的还是更好的。因为： viper太重量级，使用viper时你需要pull另外20个viper依赖的第三方包 事实上，viper单独使用还不足以满足需求，要想得到viper全部功能，你还需要另外一个包配合，而后者又依赖13个外部包 与viper相比，multiconfig使用起来更简单。 好了，我们再来回顾一下我们现在面临的问题： 在程序里定义默认配置，这样我们就无需再在toml中定义它们了。 用toml配置文件中的数据override默认配置 用命令行或环境变量的值override从toml中读取的配置。 下面是一个说明如何使用multiconfig的例子：123456789101112131415161718func main() &#123; m := multiconfig.NewWithPath(\"config.toml\") // supports TOML and JSON // Get an empty struct for your configuration serverConf := new(Server) // Populated the serverConf struct m.MustLoad(serverConf) // Check for error fmt.Println(\"After Loading: \") fmt.Printf(\"%+v\\n\", serverConf) if serverConf.Enabled &#123; fmt.Println(\"Enabled field is set to true\") &#125; else &#123; fmt.Println(\"Enabled field is set to false\") &#125;&#125; 这个例子中的toml文件如下：12345678910Name = \"koding\"Enabled = falsePort = 6066Users = [\"ankara\", \"istanbul\"][Postgres]Enabled = truePort = 5432Hosts = [\"192.168.2.1\", \"192.168.2.2\", \"192.168.2.3\"]AvailabilityRatio = 8.23 toml映射后的go结构如下：12345678910111213141516171819type ( // Server holds supported types by the multiconfig package Server struct &#123; Name string Port int `default:\"6060\"` Enabled bool Users []string Postgres Postgres &#125; // Postgres is here for embedded struct feature Postgres struct &#123; Enabled bool Port int Hosts []string DBName string AvailabilityRatio float64 &#125;) multiconfig的使用是不是很简单，后续与viper对比后，你会同意我的观点的。 multiconfig支持默认值，也支持显式的字段赋值需求。支持toml、json、结构体标签（struct tags)以及环境变量。你可以自定义配置源（例如一个远程服务器），如果你想这么做的话。可高度扩展（通过loader接口），你可以创建你自己的loader。 下面是例子的运行结果，首先是usage help：123456789101112131415161718192021222324252627$cmdlinemulticonfig -helpUsage of cmdlinemulticonfig: -enabled=false: Change value of Enabled. -name=koding: Change value of Name. -port=6066: Change value of Port. -postgres-availabilityratio=8.23: Change value of Postgres-AvailabilityRatio. -postgres-dbname=: Change value of Postgres-DBName. -postgres-enabled=true: Change value of Postgres-Enabled. -postgres-hosts=[192.168.2.1 192.168.2.2 192.168.2.3]: Change value of Postgres-Hosts. -postgres-port=5432: Change value of Postgres-Port. -users=[ankara istanbul]: Change value of Users.Generated environment variables: SERVER_NAME SERVER_PORT SERVER_ENABLED SERVER_USERS SERVER_POSTGRES_ENABLED SERVER_POSTGRES_PORT SERVER_POSTGRES_HOSTS SERVER_POSTGRES_DBNAME SERVER_POSTGRES_AVAILABILITYRATIO$cmdlinemulticonfigAfter Loading:&amp;&#123;Name:koding Port:6066 Enabled:false Users:[ankara istanbul] Postgres:&#123;Enabled:true Port:5432 Hosts:[192.168.2.1 192.168.2.2 192.168.2.3] DBName: AvailabilityRatio:8.23&#125;&#125;Enabled field is set to false 检查一下输出结果吧，是不是每项都符合我们之前的预期呢！ Viper我们的重量级选手viper该出场了！ 毫无疑问，viper非常强大。但如果你想用命令行参数覆盖预定义的配置项值，viper自己还不足以。要想让viper爆发，你需要另外一个包配合，它就是cobra。 不同于注重简化配置处理的multiconfig，viper让你拥有全面控制力。不幸的是，在得到这种控制力之前，你需要做一些体力活。 我们再来回顾一下使用multiconfig处理配置的代码：123456789101112131415161718func main() &#123; m := multiconfig.NewWithPath(\"config.toml\") // supports TOML and JSON // Get an empty struct for your configuration serverConf := new(Server) // Populated the serverConf struct m.MustLoad(serverConf) // Check for error fmt.Println(\"After Loading: \") fmt.Printf(\"%+v\\n\", serverConf) if serverConf.Enabled &#123; fmt.Println(\"Enabled field is set to true\") &#125; else &#123; fmt.Println(\"Enabled field is set to false\") &#125;&#125; 这就是使用multiconfig时你要做的所有事情。现在我们来看看使用viper和cobra如何来完成同样的事情：123456789101112131415161718192021222324252627282930313233343536373839404142func init() &#123; mainCmd.AddCommand(versionCmd) viper.SetEnvPrefix(\"DISPATCH\") viper.AutomaticEnv() /* When AutomaticEnv called, Viper will check for an environment variable any time a viper.Get request is made. It will apply the following rules. It will check for a environment variable with a name matching the key uppercased and prefixed with the EnvPrefix if set. */ flags := mainCmd.Flags() flags.Bool(\"debug\", false, \"Turn on debugging.\") flags.String(\"addr\", \"localhost:5002\", \"Address of the service\") flags.String(\"smtp-addr\", \"localhost:25\", \"Address of the SMTP server\") flags.String(\"smtp-user\", \"\", \"User to authenticate with the SMTP server\") flags.String(\"smtp-password\", \"\", \"Password to authenticate with the SMTP server\") flags.String(\"email-from\", \"noreply@example.com\", \"The from email address.\") viper.BindPFlag(\"debug\", flags.Lookup(\"debug\")) viper.BindPFlag(\"addr\", flags.Lookup(\"addr\")) viper.BindPFlag(\"smtp_addr\", flags.Lookup(\"smtp-addr\")) viper.BindPFlag(\"smtp_user\", flags.Lookup(\"smtp-user\")) viper.BindPFlag(\"smtp_password\", flags.Lookup(\"smtp-password\")) viper.BindPFlag(\"email_from\", flags.Lookup(\"email-from\")) // Viper supports reading from yaml, toml and/or json files. Viper can // search multiple paths. Paths will be searched in the order they are // provided. Searches stopped once Config File found. viper.SetConfigName(\"CommandLineCV\") // name of config file (without extension) viper.AddConfigPath(\"/tmp\") // path to look for the config file in viper.AddConfigPath(\".\") // more path to look for the config files err := viper.ReadInConfig() if err != nil &#123; println(\"No config file found. Using built-in defaults.\") &#125;&#125; 可以看出，你需要使用BindPFlag来让viper和cobra结合一起工作。但这还不算太糟。 cobra的真正威力在于提供了subcommand能力。同时cobra还提供了与posix 全面兼容的命令行标志解析能力，包括长短标志、内嵌命令、为command定义你自己的help或usage等。 下面是定义子命令的例子代码：1234567891011121314151617181920// The main command describes the service and defaults to printing the// help message.var mainCmd = &amp;cobra.Command&#123; Use: \"dispatch\", Short: \"Event dispatch service.\", Long: `HTTP service that consumes events and dispatches them to subscribers.`, Run: func(cmd *cobra.Command, args []string) &#123; serve() &#125;,&#125;// The version command prints this service.var versionCmd = &amp;cobra.Command&#123; Use: \"version\", Short: \"Print the version.\", Long: \"The version of the dispatch service.\", Run: func(cmd *cobra.Command, args []string) &#123; fmt.Println(version) &#125;,&#125; 有了上面subcommand的定义，我们就可以得到如下的help信息了：123456789101112131415161718Usage: dispatch [flags] dispatch [command]Available Commands: version Print the version. help Help about any commandFlags: –addr=\"localhost:5002\": Address of the service –debug=false: Turn on debugging. –email-from=\"noreply@example.com\": The from email address. -h, –help=false: help for dispatch –smtp-addr=\"localhost:25\": Address of the SMTP server –smtp-password=\"\": Password to authenticate with the SMTP server –smtp-user=\"\": User to authenticate with the SMTP serverUse \"dispatch help [command]\" for more information about a command.","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"}]},{"title":"Golang并发","slug":"2017-08-28-Golang-concurency","date":"2017-08-27T20:19:00.000Z","updated":"2018-01-05T00:45:28.280Z","comments":true,"path":"2017/08/28/2017-08-28-Golang-concurency/","link":"","permalink":"http://xichen.pub/2017/08/28/2017-08-28-Golang-concurency/","excerpt":"","text":"运行期线程Go允许使用go语句开启一个新的运行期线程，即 goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享同一个地址空间。 Goroutine非常轻量，除了为之分配的栈空间，其所占用的内存空间微乎其微。并且其栈空间在开始时非常小，之后随着堆存储空间的按需分配或释放而变化。内部实现上，goroutine会在多个操作系统线程上多路复用。如果一个goroutine阻塞了一个操作系统线程，例如：等待输入，这个线程上的其他goroutine就会迁移到其他线程，这样能继续运行。开发者并不需要关心/担心这些细节。 下面所示程序会输出“Hello from main goroutine”。也可能会输出“Hello from another goroutine”，具体依赖于两个goroutine哪个先结束。12345678func main() &#123; go fmt.Println(\"Hello from another goroutine\") fmt.Println(\"Hello from main goroutine\") // 至此，程序运行结束， // 所有活跃的goroutine被杀死&#125;goroutine1.go 接下来的这个程序，多数情况下，会输出“Hello from main goroutine”和“Hello from another goroutine”，输出的顺序不确定。但还有另一个可能性是：第二个goroutine运行得极其慢，在程序结束之前都没来得及输出相应的消息。 1234567func main() &#123; go fmt.Println(\"Hello from another goroutine\") fmt.Println(\"Hello from main goroutine\") time.Sleep(time.Second) // 等待1秒，等另一个goroutine结束&#125;//goroutine2.go 下面则是一个相对更加实际的示例，其中定义了一个函数使用并发来推迟触发一个事件。123456789// 函数Publish在给定时间过期后打印text字符串到标准输出 // 该函数并不会阻塞而是立即返回func Publish(text string, delay time.Duration) &#123; go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) &#125;() // 注意这里的括号。必须调用匿名函数&#125;//publish1.go 你可能会这样使用Publish函数：12345678910func main() &#123; Publish(\"A goroutine starts a new thread of execution.\", 5*time.Second) fmt.Println(\"Let’s hope the news will published before I leave.\") // 等待发布新闻 time.Sleep(10 * time.Second) fmt.Println(\"Ten seconds later: I’m leaving now.\")&#125;//publish1.go 这个程序，绝大多数情况下，会输出以下三行，顺序固定，每行输出之间相隔5秒。1234$ go run publish1.goLet’s hope the news will published before I leave.BREAKING NEWS: A goroutine starts a new thread of execution.Ten seconds later: I’m leaving now. 一般来说，通过睡眠的方式来编排线程之间相互等待是不太可能的。下一章节会介绍Go语言中的一种同步机制 - 管道，并演示如何使用管道让一个goroutine等待另一个goroutine。 管道（channel）管道是Go语言的一个构件，提供一种机制用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于指定管道的方向，发送或接收。如果未指定方向，则为双向管道。123chan Sushi // 可用来发送和接收Sushi类型的值chan&lt;- float64 // 仅可用来发送float64类型的值&lt;-chan int // 仅可用来接收int类型的值 管道是引用类型，基于make函数来分配。12ic := make(chan int) // 不带缓冲的int类型管道wc := make(chan *Work, 10) // 带缓冲的Work类型指针管道 如果通过管道发送一个值，则将&lt;-作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用：12ic &lt;- 3 // 往管道发送3work := &lt;-wc // 从管道接收一个指向Work类型值的指针 如果管道不带缓冲，发送方会阻塞直到接收方从管道中接收了值。如果管道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 关闭管道（Close） close 函数标志着不会再往某个管道发送值。在调用close之后，并且在之前发送的值都被接收后，接收操作会返回一个零值，不会阻塞。一个多返回值的接收操作会额外返回一个布尔值用来指示返回的值是否发送操作传递的。123456789ch := make(chan string)go func() &#123; ch &lt;- \"Hello!\" close(ch)&#125;()fmt.Println(&lt;-ch) // 输出字符串\"Hello!\"fmt.Println(&lt;-ch) // 输出零值 - 空字符串\"\"，不会阻塞fmt.Println(&lt;-ch) // 再次打印输出空字符串\"\"v, ok := &lt;-ch // 变量v的值为空字符串\"\"，变量ok的值为false 一个带有range子句的for语句会依次读取发往管道的值，直到该管道关闭：123456789101112131415161718func main() &#123; // 译注：要想运行该示例，需要先定义类型Sushi，如type Sushi string var ch &lt;-chan Sushi = Producer() for s := range ch &#123; fmt.Println(\"Consumed\", s) &#125;&#125;func Producer() &lt;-chan Sushi &#123; ch := make(chan Sushi) go func()&#123; ch &lt;- Sushi(\"海老握り\") // Ebi nigiri ch &lt;- Sushi(\"鮪とろ握り\") // Toro nigiri close(ch) &#125;() return ch&#125;//sushi.go 同步下一个示例中，我们让Publish函数返回一个管道 - 用于在发布text变量值时广播一条消息：123456789101112// 在给定时间过期时，Publish函数会打印text变量值到标准输出// 在text变量值发布后，该函数会关闭管道waitfunc Publish(text string, delay time.Duration) (wait &lt;-chan struct&#123;&#125;) &#123; ch := make(chan struct&#123;&#125;) go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) close(ch) // 广播 - 一个关闭的管道都会发送一个零值 &#125;() return ch&#125;//publish2.go 注意：我们使用了一个空结构体的管道：struct{}。这明确地指明该管道仅用于发信号，而不是传递数据。 我们可能会这样使用这个函数：1234567func main() &#123; wait := Publish(\"Channels let goroutines communicate.\", 5*time.Second) fmt.Println(\"Waiting for the news...\") &lt;-wait fmt.Println(\"The news is out, time to leave.\")&#125;//publish2.go 这个程序会按指定的顺序输出以下三行内容。最后一行在新闻（news）一出就会立即输出。1234$ go run publish2.goWaiting for the news...BREAKING NEWS: Channels let goroutines communicate.The news is out, time to leave. 死锁现在我们在Publish函数中引入一个bug：12345678910func Publish(text string, delay time.Duration) (wait &lt;-chan struct&#123;&#125;) &#123; ch := make(chan struct&#123;&#125;) go func() &#123; time.Sleep(delay) fmt.Println(\"BREAKING NEWS:\", text) // 译注：注意这里将close函数调用注释掉了 //close(ch) &#125;() return ch&#125; 主程序还是像之前一样开始运行：输出第一行，然后等待5秒，这时Publish函数开启的goroutine会输出突发新闻（breaking news），然后退出，留下主goroutine独自等待。1234567func main() &#123; wait := Publish(\"Channels let goroutines communicate.\", 5*time.Second) fmt.Println(\"Waiting for the news...\") // 译注：注意下面这一句 &lt;-wait fmt.Println(\"The news is out, time to leave.\")&#125; 此刻之后，程序无法再继续往下执行。众所周知，这种情形即为死锁。 死锁是线程之间相互等待，其中任何一个都无法向前运行的情形。 Go语言对于运行时的死锁检测具备良好的支持。当没有任何goroutine能够往前执行的情形发生时，Go程序通常会提供详细的错误信息。以下就是我们的问题程序的输出：123456789101112131415Waiting for the news...BREAKING NEWS: Channels let goroutines communicate.fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive]:main.main() .../goroutineStop.go:11 +0xf6goroutine 2 [syscall]:created by runtime.main .../go/src/pkg/runtime/proc.c:225goroutine 4 [timer goroutine (idle)]:created by addtimer .../go/src/pkg/runtime/ztime_linux_amd64.c:73 大多数情况下找出Go程序中造成死锁的原因都比较容易，那么剩下的就是如何解决这个bug了。 数据竞争（data race）死锁也许听起来令人挺忧伤的，但伴随并发编程真正灾难性的错误其实是数据竞争，相当常见，也可能非常难于调试。 当两个线程并发地访问同一个变量，并且其中至少一个访问是写操作时，数据竞争就发生了。 下面的这个函数就有数据竞争问题，其行为是未定义的。例如，可能输出数值1。代码之后是一个可能性解释，试图搞清楚这一切是如何发生得。1234567891011121314func race() &#123; wait := make(chan struct&#123;&#125;) n := 0 go func() &#123; // 译注：注意下面这一行 n++ // 一次访问: 读, 递增, 写 close(wait) &#125;() // 译注：注意下面这一行 n++ // 另一次冲突的访问 &lt;-wait fmt.Println(n) // 输出：未指定&#125;//datarace.go 代码中的两个goroutine（假设命名为g1和g2）参与了一次竞争，我们无法获知操作会以何种顺序发生。以下是诸多可能中的一种：1234567g1 从 n 中获取值0g2 从 n 中获取值0g1 将值从0增大到1g1 将1写到 ng2 将值从0增大到1g2 将1写到 n程序输出 n 的值，当前为1 “数据竞争（data race）”这名字有点误导的嫌疑。不仅操作的顺序是未定义的，其实根本没有任何保证（no guarantees whatsoever）。编译器和硬件为了得到更好的性能，经常都会对代码进行上下内外的顺序变换。如果你看到一个线程处于中间行为状态时，那么当时的场景可能就像下图所示的一样： 避免数据竞争的唯一方式是线程间同步访问所有的共享可变数据。有几种方式能够实现这一目标。Go语言中，通常是使用管道或者锁。（sync和sync/atomic包中还有更低层次的机制可供使用，但本文中不做讨论）。 Go语言中，处理并发数据访问的推荐方式是使用管道从一个goroutine中往下一个goroutine传递实际的数据。有格言说得好：“不要通过共享内存来通讯，而是通过通讯来共享内存”。123456789101112func sharingIsCaring() &#123; ch := make(chan int) go func() &#123; n := 0 // 仅为一个goroutine可见的局部变量. n++ ch &lt;- n // 数据从一个goroutine离开... &#125;() n := &lt;-ch // ...然后安全到达另一个goroutine. n++ fmt.Println(n) // 输出: 2&#125;//datarace.go 以上代码中的管道肩负双重责任 - 从一个goroutine将数据传递到另一个goroutine，并且起到同步的作用：发送方goroutine会等待另一个goroutine接收数据，接收方goroutine也会等待另一个goroutine发送数据。 Go语言内存模型 - 要保证一个goroutine中对一个变量的读操作得到的值正好是另一个goroutine中对同一个变量写操作产生的值，条件相当复杂，但goroutine之间只要通过管道来共享所有可变数据，那么就能远离数据竞争了。 互斥锁有时，通过显式加锁，而不是使用管道，来同步数据访问，可能更加便捷。Go语言标准库为这一目的提供了一个互斥锁 - sync.Mutex。 要想这类加锁起效的话，关键之处在于：所有对共享数据的访问，不管读写，仅当goroutine持有锁才能操作。一个goroutine出错就足以破坏掉一个程序，引入数据竞争。 因此，应该设计一个自定义数据结构，具备明确的API，确保所有的同步都在数据结构内部完成。下例中，我们构建了一个安全、易于使用的并发数据结构，AtomicInt，用于存储一个整型值。任意数量的goroutine都能通过Add和Value方法安全地访问这个数值。12345678910111213141516171819202122232425262728293031323334// AtomicInt是一个并发数据结构，持有一个整数值// 该数据结构的零值为0type AtomicInt struct &#123; mu sync.Mutex // 锁，一次仅能被一个goroutine持有。 n int&#125;// Add方法作为一个原子操作将n加到AtomicIntfunc (a *AtomicInt) Add(n int) &#123; a.mu.Lock() // 等待锁释放，然后持有它 a.n += n a.mu.Unlock() // 释放锁&#125;// Value方法返回a的值func (a *AtomicInt) Value() int &#123; a.mu.Lock() n := a.n a.mu.Unlock() return n&#125;func lockItUp() &#123; wait := make(chan struct&#123;&#125;) var n AtomicInt go func() &#123; n.Add(1) // 一个访问 close(wait) &#125;() n.Add(1) // 另一个并发访问 &lt;-wait fmt.Println(n.Value()) // 输出: 2&#125;//datarace.go 检测数据竞争竞争有时非常难于检测。下例中的这个函数有一个数据竞争问题，执行这个程序时会输出55555。尝试一下，也许你会得到一个不同的结果。（sync.WaitGroup是Go语言标准库的一部分；用于等待一组goroutine结束运行。）123456789101112131415func race() &#123; var wg sync.WaitGroup wg.Add(5) // 译注：注意下面这行代码中的i++ for i := 0; i &lt; 5; i++ &#123; go func() &#123; // 注意下一行代码会输出什么？为什么？ fmt.Print(i) // 6个goroutine共享变量i wg.Done() &#125;() &#125; wg.Wait() // 等待所有（5个）goroutine运行结束 fmt.Println()&#125;//raceClosure.go 对于输出55555，一个貌似合理的解释是：执行i++的goroutine在其他goroutine执行打印语句之前就完成了5次i++操作。实际上变量i更新后的值为其他goroutine所见纯属巧合。 一个简单的解决方案是：使用一个局部变量，然后当开启新的goroutine时，将数值作为参数传递：12345678910111213func correct() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; go func(n int) &#123; // 使用局部变量 fmt.Print(n) wg.Done() &#125;(i) &#125; wg.Wait() fmt.Println()&#125;//raceClosure.go 这次代码就对了，程序会输出期望的结果，如：24031。注意：goroutine之间的运行顺序是不确定的。 仍旧使用闭包，但能够避免数据竞争也是可能的，必须小心翼翼地让每个goroutine使用一个独有的变量。1234567891011121314func alsoCorrect() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; n := i // 为每个闭包创建一个独有的变量 go func() &#123; fmt.Print(n) wg.Done() &#125;() &#125; wg.Wait() fmt.Println()&#125;//raceClosure.go 数据竞争自动检测一般来说，不太可能能够自动检测发现所有可能的数据竞争情况，但Go（从版本1.1开始）有一个强大的数据竞争检测器。 这个工具用起来也很简单：只要在使用go命令时加上-race标记即可。开启检测器运行上面的程序会给出清晰且信息量大的输出：1234567891011121314151617181920212223242526272829303132$ go run -race raceClosure.goRace:==================WARNING: DATA RACERead by goroutine 2: main.func·001() ../raceClosure.go:22 +0x65Previous write by goroutine 0: main.race() ../raceClosure.go:20 +0x19b main.main() ../raceClosure.go:10 +0x29 runtime.main() ../go/src/pkg/runtime/proc.c:248 +0x91Goroutine 2 (running) created at: main.race() ../raceClosure.go:24 +0x18b main.main() ../raceClosure.go:10 +0x29 runtime.main() ../go/src/pkg/runtime/proc.c:248 +0x91==================55555Correct:01234Also correct:01324Found 1 data race(s)exit status 66 该工具发现一处数据竞争，包含：一个goroutine在第20行对一个变量进行写操作，跟着另一个goroutine在第22行对同一个变量进行了未同步的读操作。 注意：竞争检测器只能发现在运行期确实发生的数据竞争（译注：我也不太理解这话，请指导） Select语句select语句是Go语言并发工具集中的终极工具。select用于从一组可能的通讯中选择一个进一步处理。如果任意一个通讯都可以进一步处理，则从中随机选择一个，执行对应的语句。否则，如果又没有默认分支（default case），select语句则会阻塞，直到其中一个通讯完成。 以下是一个玩具示例，演示select语句如何用于实现一个随机数生成器：1234567891011121314// RandomBits函数 返回一个管道，用于产生一个比特随机序列func RandomBits() &lt;-chan int &#123; ch := make(chan int) go func() &#123; for &#123; select &#123; case ch &lt;- 0: // 注意：分支没有对应的处理语句 case ch &lt;- 1: &#125; &#125; &#125;() return ch&#125;//randBits.go 下面是相对更加实际一点的例子：如何使用select语句为一个操作设置一个时间限制。代码会输出变量news的值或者超时消息，具体依赖于两个接收语句哪个先执行：123456select &#123;case news := &lt;-NewsAgency: fmt.Println(news)case &lt;-time.After(time.Minute): fmt.Println(\"Time out: no news in one minute.\")&#125; 函数 time.After 是Go语言标准库的一部分；它会在等待指定时间后将当前的时间发送到返回的管道中。 综合所有示例花点时间认真研究一下这个示例。如果你完全理解，也就对Go语言中并发的应用方式有了全面的掌握。 这个程序演示了如何将管道用于被任意数量的goroutine发送和接收数据，也演示了如何将select语句用于从多个通讯中选择一个。12345678910111213141516171819202122232425262728func main() &#123; people := []string&#123;\"Anna\", \"Bob\", \"Cody\", \"Dave\", \"Eva\"&#125; match := make(chan string, 1) // 为一个未匹配的发送操作提供空间 wg := new(sync.WaitGroup) wg.Add(len(people)) for _, name := range people &#123; go Seek(name, match, wg) &#125; wg.Wait() select &#123; case name := &lt;-match: fmt.Printf(\"No one received %s’s message.\\n\", name) default: // 没有待处理的发送操作 &#125;&#125;// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait groupfunc Seek(name string, match chan string, wg *sync.WaitGroup) &#123; select &#123; case peer := &lt;-match: fmt.Printf(\"%s sent a message to %s.\\n\", peer, name) case match &lt;- name: // 等待某个goroutine接收我的消息 &#125; wg.Done()&#125;//matching.go 示例输出：1234$ go run matching.goCody sent a message to Bob.Anna sent a message to Eva.No one received Dave’s message. 并行计算并发的一个应用是将一个大的计算切分成一些工作单元，调度到不同的CPU上同时地计算。 将计算分布到多个CPU上更多是一门艺术，而不是一门科学。以下是一些经验法则： 每个工作单元应该花费大约100微秒到1毫秒的时间用于计算。如果单元粒度太小，切分问题以及调度子问题的管理开销可能就会太大。如果单元粒度太大，整个计算也许不得不等待一个慢的工作项结束。这种缓慢可能因为多种原因而产生，比如：调度、其他进程的中断或者糟糕的内存布局。（注意：工作单元的数目是不依赖于CPU的数目的） 尽可能减小共享的数据量。并发写操作的代价非常大，特别是如果goroutine运行在不同的CPU上。读操作之间的数据共享则通常不会是个问题。 数据访问尽量利用良好的局部性。如果数据能保持在缓存中，数据加载和存储将会快得多得多，这对于写操作也格外地重要。 下面的这个示例展示如何切分一个开销很大的计算并将其分布在所有可用的CPU上进行计算。先看一下有待优化的代码：1234567891011121314151617181920212223type Vector []float64// 函数Convolve 计算 w = u * v，其中 w[k] = Σ u[i]*v[j], i + j = k// 先决条件：len(u) &gt; 0, len(v) &gt; 0func Convolve(u, v Vector) (w Vector) &#123; n := len(u) + len(v) - 1 w = make(Vector, n) for k := 0; k &lt; n; k++ &#123; w[k] = mul(u, v, k) &#125; return&#125;// 函数mul 返回 Σ u[i]*v[j], i + j = k.func mul(u, v Vector, k int) (res float64) &#123; n := min(k+1, len(u)) j := min(k, len(v)-1) for i := k - j; i &lt; n; i, j = i+1, j-1 &#123; res += u[i] * v[j] &#125; return&#125; 思路很简单：确定合适大小的工作单元，然后在不同的goroutine中执行每个工作单元。以下是并发版本的 Convolve：123456789101112131415161718192021222324252627func Convolve(u, v Vector) (w Vector) &#123; n := len(u) + len(v) - 1 w = make(Vector, n) // 将 w 切分成花费 ~100μs-1ms 用于计算的工作单元 size := max(1, 1&lt;&lt;20/n) wg := new(sync.WaitGroup) wg.Add(1 + (n-1)/size) for i := 0; i &lt; n &amp;&amp; i &gt;= 0; i += size &#123; // 整型溢出后 i &lt; 0 j := i + size if j &gt; n || j &lt; 0 &#123; // 整型溢出后 j &lt; 0 j = n &#125; // 这些goroutine共享内存，但是只读 go func(i, j int) &#123; for k := i; k &lt; j; k++ &#123; w[k] = mul(u, v, k) &#125; wg.Done() &#125;(i, j) &#125; wg.Wait() return&#125;//convolution.go 工作单元定义之后，通常情况下最好将调度工作交给运行时和操作系统。然而，对于Go 1.* 你也许需要告诉运行时希望多少个goroutine来同时地运行代码。1234func init() &#123; numcpu := runtime.NumCPU() runtime.GOMAXPROCS(numcpu) // 尝试使用所有可用的CPU&#125;","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"}]},{"title":"代理","slug":"2017-08-21-代理","date":"2017-08-21T01:29:00.000Z","updated":"2018-01-05T00:45:28.278Z","comments":true,"path":"2017/08/21/2017-08-21-代理/","link":"","permalink":"http://xichen.pub/2017/08/21/2017-08-21-代理/","excerpt":"","text":"1.lantern浏览器代理https://github.com/getlantern/lantern 命令行代理打开蓝灯后，终端下输入： 123export http_proxy=http://127.0.0.1:8787export https_proxy=http://127.0.0.1:8787 :8787是端口号，具体查看系统设置–网络–网络代理","categories":[{"name":"proxy","slug":"proxy","permalink":"http://xichen.pub/categories/proxy/"}],"tags":[{"name":"proxy","slug":"proxy","permalink":"http://xichen.pub/tags/proxy/"},{"name":"lantern","slug":"lantern","permalink":"http://xichen.pub/tags/lantern/"}]},{"title":"GO的安装和配置","slug":"2017-08-21-Go的安装和配置","date":"2017-08-21T01:29:00.000Z","updated":"2018-01-05T00:45:28.277Z","comments":true,"path":"2017/08/21/2017-08-21-Go的安装和配置/","link":"","permalink":"http://xichen.pub/2017/08/21/2017-08-21-Go的安装和配置/","excerpt":"","text":"0.Install Go 不要用apt-get install golang！这个目前只有1.6版，最新版已经到1.8+ 在linux 系统下，如ubuntu debian ，安装golang 最方便的方式是用apt-get install。 但不推荐这种方式安装，建议使用源码安装，如果你不小心用apt-get 等方式安装了，就先把它卸载：1sudo apt-get purge golang-go 然后用源码安装，如果想升级也可以直接覆盖安装位置的原文件，golang 还算很干净。 套路:12345678curl -O https://storage.googleapis.com/golang/go1.7.3.linux-amd64.tar.gztar -C /usr/local -zxvf go1.7.3.linux-amd64.tar.gzmkdir -p ~/go/srcecho \"export GOROOT=/usr/local/go\"echo \"export GOPATH=$HOME/go\" &gt;&gt; ~/.bashrcecho \"export PATH=$PATH:$GOPATH/bin:$GOROOT/bin\" &gt;&gt; ~/.bashrcsource ~/.bashrcgo version GOROOT:根目录，设置了这个才指定解释器，也是标准库所在 GOPATH:工作目录，放你自己的代码．该目录下要有一定的结构，因为外来库要用go get安装在该目录下 PATH:系统环境变量，不破坏原来的环境变量的方法为PATH=$PATH:/usr/local/go表示在原来环境变量的基础上添加/usr/local/go Tips:命令行下输入export可查看当前所有变量，包括PATH,GOROOT等等，方便确认是否设置成功 1.GOROOTGOROOT就是go的安装路径 在~/.bash_profile中添加下面语句: 1export GOROOT=/usr/local/go 当然, 要执行go命令和go工具, 就要配置go的可执行文件的路径,操作如下: 在~/.bash_profile中配置如下:1export $PATH:$GOROOT/bin 如果是windows需要使用;符号分割两个路径, mac和类unix都是用:符号分割 2.GOPATHgo install/go get和 go的工具等会用到GOPATH环境变量. GOPATH是作为编译后二进制的存放目的地和import包时的搜索路径 (其实也是你的工作目录, 你可以在src下创建你自己的go源文件, 然后开始工作)。 GOPATH之下主要包含三个目录: bin、pkg、src bin目录主要存放可执行文件; pkg目录存放编译好的库文件, 主要是*.a文件; src目录下主要存放go的源文件 不要把GOPATH设置成go的安装路径, 可以自己在用户目录下面创建一个目录, 如gopath 操作如下:12cd ~mkdir gopath 在~/.bash_profile中添加如下语句:1GOPATH=/Users/username/gopath GOPATH可以是一个目录列表, go get下载的第三方库, 一般都会下载到列表的第一个目录里面需要把GOPATH中的可执行目录也配置到环境变量中, 否则你自行下载的第三方go工具就无法使用了, 操作如下:在~/bash_profile中配置,1export $PATH:$GOPATH/bin 创建一个go项目, 并且编译运行:123mkdir goprojectcd goprojecttouch hello.go 在hello.go中输入:12345package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, GO !\")&#125; 在项目根目录下执行go build命令来构建你的项目, 构建后会生成hello文件运行生成的文件./hello, terminal中输出:Hello, GO !当然你也可以直接运行命令go run hello.go来执行程序. 附：源：https://dl.gocn.io/查看其他GO相关的环境变量：go env","categories":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/categories/GO/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://xichen.pub/tags/GO/"},{"name":"Install","slug":"Install","permalink":"http://xichen.pub/tags/Install/"},{"name":"Settings","slug":"Settings","permalink":"http://xichen.pub/tags/Settings/"}]},{"title":"jupyter-notebook-sen-usage","slug":"2017-08-20-jupyter-notebook-sen-usage","date":"2017-08-20T05:42:14.000Z","updated":"2018-01-05T00:45:28.276Z","comments":true,"path":"2017/08/20/2017-08-20-jupyter-notebook-sen-usage/","link":"","permalink":"http://xichen.pub/2017/08/20/2017-08-20-jupyter-notebook-sen-usage/","excerpt":"","text":"安装jupyter-notebook1$ pip install jupyter 配置jupyter-notebook配置可以同时使用python2和python3内核12345$ ipython kernel install --user$ python3 -m ipykernel install --user$ pip2 install -U ipykernel$ python2 -m ipykernel install --user$ jupyter-notebook //运行，会自动web界面，可以同时运行python2，python3，ctrl+c结束 生成配置文件123$ cd $ jupyter notebook --generate-configWriting default config to: /root/.jupyter/jupyter_notebook_config.py 生成密码运行jupyter1234567In [1]: from notebook.auth import passwd passwd() Enter password: ········ Verify password: ········ Out[1]: 'sha1:c3a52264ad87:f6a2c3503ee3370c67da1f723ae1e8e79477f5f7' 设置密码将前面生成的一串密码替换到配置文件中12$ vim /root/.jupyter/jupyter_notebook_config.py c.NotebookApp.password=u'sha1:c3a52264ad87:f6a2c3503ee3370c67da1f723ae1e8e79477f5f7' //前面u表示转换成unicode字符，python2的时候需要带 其它设置1234c.NotebookApp.ip = '*' //访问ip限制c.NotebookApp.notebook_dir = '/home/knmax/Desktop/Python/jupyter-project' //工作目录,路径不能出现中文c.NotebookApp.open_browser = False //不自动打开浏览器c.NotebookApp.port = 88 //运行监听的端口 以服务方式运行每次运行打开都是终端交互的界面，关闭会话终端也结束了jupyter，很不方便，这里做成以systemctl方式启动，适用于Debain、CentOS 7、Ubuntu 1234567891011121314$ vim /lib/systemd/system/jupyter.service //这个目录不同发行版可能也不同[Unit]Description=jupyter After=network.target[Service]Tpye=forkingEnvironmentFile=/usr/local/bin/jupyter-notebookExecStart=/usr/local/bin/jupyter-notebookExecStop=/usr/bin/pkill jupyter-notebookKillMode=processRestart=on-failureRestartSec=30s[Install]WantedBy=multi-user.target 创建好之后再操作下就行了123$ systemctl daemon-reload$ systemctl start jupyter$ systemctl enable jupyter 局域网访问jupyter notebook用电脑开wifi，手机连上电脑的wifi，手机可以直接从电脑的局域网ip访问到电脑上的jupyter notebook 安装额外插件或kernel显示稿插件 1234$ pip install RISE $ pip3 install RISE $ jupyter-nbextension install rise --py --sys-prefix $ jupyter nbextension enable rise --py --sys-prefix 安装Jupyter Notebook extensions–&gt;Jupyter拓展插件!!! 123456789101112131415161718192021$ conda install -c conda-forge jupyter_contrib_nbextensions或者$ pip install jupyter_contrib_nbextensions还不行就把下面的都试一遍...$ pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip3 install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip install jupyter_nbextensions_configurator$ pip3 install jupyter_nbextensions_configurator$ jupyter contrib nbextension install --user $ jupyter nbextensions_configurator enable --user $ systemctl restart jupyter还有......再试一试又不会怀孕...$ pip install https://github.com/ipython-contrib/jupyter_contrib_nbextensions/tarball/master $ pip install jupyter_nbextensions_configurator $ jupyter contrib nbextension install –user $ jupyter nbextensions_configurator enable –user 开启toc2插件命令行输入jupyter notebook运行,在浏览器打开notebook的Home页面，多了一个Nbextensions,点进去就懂了这个用起来很爽，可以增加许多功能，尤其是里面可以增加侧边栏，这个用起来对代码管理就看起来层次分明多了，找代码也更方便了~~ 顺便note一下,代码折叠,生成目录，自动格式化很有用~~~ 安装主题、字体1234$ pip install --upgrade jupyterthemes$ pip3 install --upgrade jupyterthemes$ jt -l 查看可用主题$ jt -t grade3 -f ptmono -fs 115 参考地址 jupyter支持的内核参考地址 多指针Jupyter支持多个指针同步编辑，类似Sublime Text编辑器。按下Alt键并拖拽鼠标即可实现。====这个我用着很不顺手，按住ctrl后用移动鼠标可实现一样的多次选中，我还是喜欢用这个。。 隐藏代码只显示代码输出123456789101112131415from IPython.display import HTMLHTML('''&lt;script&gt;code_show=true; function code_toggle() &#123; if (code_show)&#123; $('div.input').hide(); &#125; else &#123; $('div.input').show(); &#125; code_show = !code_show&#125; $( document ).ready(code_toggle);&lt;/script&gt;&lt;form action=\"javascript:code_toggle()\"&gt;&lt;input type=\"submit\" value=\"Click here to toggle on/off the raw code.\"&gt;&lt;/form&gt;''') 也可以这样：123456789101112code_show=true;function code_toggle() &#123; if (code_show)&#123; $('div.input').hide(); &#125; else &#123; $('div.input').show(); &#125; code_show = !code_show&#125;$([IPython.events]).on(\"app_initialized.NotebookApp\", function () &#123; $(\"#view_menu\").append(\"&lt;li id=\\\"toggle_toolbar\\\" title=\\\"Show/Hide code cells\\\"&gt;&lt;a href=\\\"javascript:code_toggle()\\\"&gt;Toggle Code Cells&lt;/a&gt;&lt;/li&gt;\") 或者这样:123456789from IPython.display import displayfrom IPython.display import HTMLimport IPython.core.display as di # Example: di.display_html('&lt;h3&gt;%s:&lt;/h3&gt;' % str, raw=True)# This line will hide code by default when the notebook is exported as HTMLdi.display_html('&lt;script&gt;jQuery(function() &#123;if (jQuery(\"body.notebook_app\").length == 0) &#123; jQuery(\".input_area\").toggle(); jQuery(\".prompt\").toggle();&#125;&#125;);&lt;/script&gt;', raw=True)# This line will add a button to toggle visibility of code blocks, for use with the HTML export versiondi.display_html('''&lt;button onclick=\"jQuery('.input_area').toggle(); jQuery('.prompt').toggle();\"&gt;Toggle code&lt;/button&gt;''', raw=True) 这样：123456789$([IPython.events]).on('notebook_loaded.Notebook', function()&#123; IPython.toolbar.add_buttons_group([ &#123; 'label' : 'toggle input cells', 'icon' : 'icon-refresh', 'callback': function()&#123;$('.input').slideToggle()&#125; &#125; ]);&#125;); 甚至可以这样：12345678910111213141516171819202122232425262728# This is a cell to hide code snippets from displaying# This must be at first cell!from IPython.display import HTMLhide_me = ''HTML('''&lt;script&gt;code_show=true; function code_toggle() &#123; if (code_show) &#123; $('div.input').each(function(id) &#123; el = $(this).find('.cm-variable:first'); if (id == 0 || el.text() == 'hide_me') &#123; $(this).hide(); &#125; &#125;); $('div.output_prompt').css('opacity', 0); &#125; else &#123; $('div.input').each(function(id) &#123; $(this).show(); &#125;); $('div.output_prompt').css('opacity', 1); &#125; code_show = !code_show&#125; $( document ).ready(code_toggle);&lt;/script&gt;&lt;form action=\"javascript:code_toggle()\"&gt;&lt;input style=\"opacity:0\" type=\"submit\" value=\"Click here to toggle on/off the raw code.\"&gt;&lt;/form&gt;''') 惊不惊喜？刺不刺激？[参考]：(http://stackoverflow.com/questions/27934885/how-to-hide-code-from-cells-in-ipython-notebook-visualized-with-nbviewer) 全部显示有一点已经众所周知。把变量名称或没有定义输出结果的语句放在cell的最后一行，无需print语句，Jupyter也会显示变量值。当使用Pandas DataFrames时这一点尤其有用，因为输出结果为整齐的表格。 鲜为人知的是，你可以通过修改内核选项ast_node_interactivity，使得Jupyter对独占一行的所有变量或者语句都自动显示，这样你就可以马上看到多个语句的运行结果了。 123In [1]: from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = \"all\" 如果你想在各种情形下（Notebook和Console）Jupyter都同样处理，用下面的几行简单的命令创建文件~/.ipython/profile_default/ipython_config.py即可实现：12345c = get_config()# Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = \"all\" 这个刚了解时用起来很开心，不过当用到matplotlib时会输出很多信息，看起来比较丑，我就弃用了… 末句函数不输出有时候不让末句的函数输出结果比较方便，比如在作图的时候，此时，只需在该函数末尾加上一个分号即可===这个用起来作的图看起来就清爽多了； 嘿嘿嘿… 在notebook中作图如果不想每次用matplotlib 作图后都要输入plt.show()来弹出显示图，可以如下： matplotlib （事实标准）（http://matplotlib.org/），可通过%matplotlib inline 激活，（https://www.dataquest.io/blog/matplotlib-tutorial/） ===常用 %matplotlib notebook 提供交互性操作，但可能会有点慢，因为响应是在服务器端完成的。 ===需要调整图形时这个用着不错 mpld3（https://github.com/mpld3/mpld3） 提供matplotlib代码的替代性呈现（通过d3），虽然不完整，但很好。 ===没用过 bokeh（http://bokeh.pydata.org/en/latest/） 生成可交互图像的更好选择。 ====没用过 plot.ly（https://plot.ly/） 可以生成非常好的图，可惜是付费服务。===没用过 Jupyter notebook的magic操作上面介绍的%matplotlib inline就是其中的一个魔术操作，作图时用起来流畅极了； %run ====用来运行代码脚本 %store ====命令可以在两个notebook文件之间传递变量，没用过。。 %who ====不加任何参数，命令可以列出所有的全局变量。加上参数 str 将只列出字符串型的全局变量 有两种用于计时的jupyter magic命令：当你有一些很耗时的代码，想要查清楚问题出在哪时，这两个命令非常给力。 %%time 会告诉你cell内代码的单次运行时间信息。 %%timeit 使用了Python的 timeit 模块，该模块运行某语句100，000次（默认值），然后提供最快的3次的平均值作为结果。 %prun+函数声明 会给你一个按顺序排列的表格，显示每个内部函数的耗时情况，每次调用函数的耗时情况，以及累计耗时。 Jupyter 有自己的调试界面The Python Debugger (pdb)===这个貌似很强大的样子，暂时还没用过，有机会我要试试~（https://docs.python.org/3.5/library/pdb.html），使得进入函数内部检查错误成为可能。Pdb中可使用的命令见链接（https://docs.python.org/3.5/library/pdb.html#debugger-commands） 运行Shell命令在notebook中可以用cd 来切换目录；ls用来显示当前目录内容；$ pip install或者$ conda install用来使用cmd下的命令操作； Jupyter-Notebook 的快捷键Jupyter Notebook 有两种键盘输入模式。编辑模式，允许你往单元中键入代码或文本；这时的单元框线是绿色的。命令模式，键盘输入运行程序命令；这时的单元框线是灰色。 命令模式 (按键 Esc 开启)1234567891011121314151617181920212223242526272829303132333435363738394041Enter : 转入编辑模式Shift-Enter : 运行本单元，选中下个单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在其下插入新单元Y : 单元转入代码状态M :单元转入markdown状态R : 单元转入raw状态1 : 设定 1 级标题2 : 设定 2 级标题3 : 设定 3 级标题4 : 设定 4 级标题5 : 设定 5 级标题6 : 设定 6 级标题Up : 选中上方单元K : 选中上方单元Down : 选中下方单元J : 选中下方单元Shift-K : 扩大选中上方单元Shift-J : 扩大选中下方单元A : 在上方插入新单元B : 在下方插入新单元X : 剪切选中的单元C : 复制选中的单元Shift-V : 粘贴到上方单元V : 粘贴到下方单元Z : 恢复删除的最后一个单元D,D : 删除选中的单元Shift-M : 合并选中的单元Ctrl-S : 文件存盘S : 文件存盘L : 转换行号O : 转换输出Shift-O : 转换输出滚动Esc : 关闭页面Q : 关闭页面H : 显示快捷键帮助I,I : 中断Notebook内核0,0 : 重启Notebook内核Shift : 忽略Shift-Space : 向上滚动Space : 向下滚动 编辑模式 ( Enter 键启动)123456789101112131415161718192021222324252627Tab : 代码补全或缩进Shift-Tab : 提示Ctrl-] : 缩进Ctrl-[ : 解除缩进Ctrl-A : 全选Ctrl-Z : 复原Ctrl-Shift-Z : 再做Ctrl-Y : 再做Ctrl-Home : 跳到单元开头Ctrl-Up : 跳到单元开头Ctrl-End : 跳到单元末尾Ctrl-Down : 跳到单元末尾Ctrl-Left : 跳到左边一个字首Ctrl-Right : 跳到右边一个字首Ctrl-Backspace : 删除前面一个字Ctrl-Delete : 删除后面一个字Esc : 进入命令模式Ctrl-M : 进入命令模式Shift-Enter : 运行本单元，选中下一单元Ctrl-Enter : 运行本单元Alt-Enter : 运行本单元，在下面插入一单元Ctrl-Shift-- : 分割单元Ctrl-Shift-Subtract : 分割单元Ctrl-S : 文件存盘Shift : 忽略Up : 光标上移或转入上一单元Down :光标下移或转入下一单元","categories":[{"name":"Tools","slug":"Tools","permalink":"http://xichen.pub/categories/Tools/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://xichen.pub/tags/notebook/"}]},{"title":"RNN","slug":"2017-08-10-RNN","date":"2017-08-09T15:10:24.000Z","updated":"2018-01-05T00:45:28.275Z","comments":true,"path":"2017/08/09/2017-08-10-RNN/","link":"","permalink":"http://xichen.pub/2017/08/09/2017-08-10-RNN/","excerpt":"","text":"0.总结 本文主要讲了N vs N，N vs 1、1 vs N、N vs M四种经典的RNN模型，以及如何使用Attention结构。 1.从单层网络谈起 在学习RNN之前，首先要了解一下最基本的单层网络，它的结构如图： 单层网络 输入是x，经过变换Wx+b和激活函数f得到输出y 2.经典的RNN结构(N vs N) 在实际应用中，我们还会遇到很多序列形的数据： 序列形的数据 如： 自然语言处理问题．x1可以看做是第一个单词，x2可以看做是第二个单词，依次类推。 语音处理．此时，x1、x2、x3……是每帧的声音信号。 时间序列问题．例如每天的股票价格等等 序列形的数据就不太好用原始的神经网络处理了。 为了建模序列问题，RNN引入了隐状态h（hidden state）的概念，h可以对序列形的数据提取特征，接着再转换为输出。 先从h1的计算开始看： h1的计算 图示中记号的含义是： 圆圈或方块表示的是向量 一个箭头就表示对该向量做一次变换。如上图中h0和x1分别有一个箭头连接，就表示对h0和x1各做了一次变换。 在很多论文中也会出现类似的记号，初学的时候很容易搞乱，但只要把握住以上两点，就可以比较轻松地理解图示背后的含义。 h2的计算和h1类似。要注意的是，在计算时，每一步使用的参数U、W、b都是一样的，也就是说每个步骤的参数都是共享的，这是RNN的重要特点，一定要牢记。 h2的计算 依次计算剩下来的（使用相同的参数U、W、b）： 计算 我们这里为了方便起见，只画出序列长度为4的情况，实际上，这个计算过程可以无限地持续下去。 我们目前的RNN还没有输出，得到输出值的方法就是直接通过h进行计算： 计算 正如之前所说，一个箭头就表示对对应的向量做一次类似于f(Wx+b)的变换，这里的这个箭头就表示对h1进行一次变换，得到输出y1。 剩下的输出类似进行（使用和y1同样的参数V和c）： 计算 OK！大功告成！这就是最经典的RNN结构，我们像搭积木一样把它搭好了。它的输入是x1, x2, …..xn，输出为y1, y2, …yn，也就是说，输入和输出序列必须要是等长的。 由于这个限制的存在，经典RNN的适用范围比较小，但也有一些问题适合用经典的RNN结构建模，如： 计算视频中每一帧的分类标签:因为要对每一帧进行计算，因此输入和输出序列等长。 输入为字符，输出为下一个字符的概率。 这就是著名的Char RNN（详细介绍请参考：The Unreasonable Effectiveness of Recurrent Neural Networks，Char RNN可以用来生成文章，诗歌，甚至是代码，非常有意思）。 3.N vs 1 有的时候，我们要处理的问题输入是一个序列，输出是一个单独的值而不是序列，应该怎样建模呢？ 实际上，我们只在最后一个h上进行输出变换就可以了： 输出变换 这种结构通常用来处理序列分类问题。 输入一段文字判别它所属的类别 输入一个句子判断其情感倾向 输入一段视频并判断它的类别等等。 4.1 VS N 输入不是序列而输出为序列的情况怎么处理？我们可以只在序列开始进行输入计算： 计算 还有一种结构是把输入信息X作为每个阶段的输入： 计算 下图省略了一些X的圆圈，是一个等价表示： 等价表示 这种1 VS N的结构可以处理的问题有： 从图像生成文字（image caption），此时输入的X就是图像的特征，而输出的y序列就是一段句子 从类别生成语音或音乐等 5.N VS M 下面我们来介绍RNN最重要的一个变种：N vs M。 这种结构又叫Encoder-Decoder模型，也可以称之为Seq2Seq模型。 原始的N vs N RNN要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。 为此，Encoder-Decoder结构先将输入数据编码成一个上下文向量c： Encoder 得到c有多种方式，最简单的方法就是把Encoder的最后一个隐状态赋值给c，还可以对最后的隐状态做一个变换得到c，也可以对所有的隐状态做变换。 拿到c之后，就用另一个RNN网络对其进行解码，这部分RNN网络被称为Decoder。具体做法就是将c当做之前的初始状态h0输入到Decoder中： Decoder 还有一种做法是将c当做每一步的输入： 输入 由于这种Encoder-Decoder结构不限制输入和输出的序列长度，因此应用的范围非常广泛，比如： 机器翻译:Encoder-Decoder的最经典应用，事实上这一结构就是在机器翻译领域最先提出的 文本摘要:输入是一段文本序列，输出是这段文本序列的摘要序列。 阅读理解:将输入的文章和问题分别编码，再对其进行解码得到问题的答案。 语音识别:输入是语音信号序列，输出是文字序列。 ………… 6.Attention机制 在Encoder-Decoder结构中，Encoder把所有的输入序列都编码成一个统一的语义特征c再解码。 因此， c中必须包含原始序列中的所有信息，它的长度就成了限制模型性能的瓶颈。 如机器翻译问题，当要翻译的句子较长时，一个c可能存不下那么多信息，就会造成翻译精度的下降。 Attention机制通过在每个时间输入不同的c来解决这个问题，下图是带有Attention机制的Decoder： Attention机制的Decoder 每一个c会自动去选取与当前所要输出的y最合适的上下文信息。 具体来说，我们用$$a_{ij}$$衡量Encoder中第j阶段的hj和解码时第i阶段的相关性，最终Decoder中第i阶段的输入的上下文信息$$ci$$就来自于所有$$a{ij}$$对的加权和。 以机器翻译为例（将中文翻译成英文）： 机器翻译 输入的序列是“我爱中国”，因此，Encoder中的h1、h2、h3、h4就可以分别看做是 “我” 、 “爱” 、 “中” 、 “国” 所代表的信息。 在翻译成英语时，第一个上下文c1应该和“我”这个字最相关，因此对应的就$$a{11}$$比较大，而相应的$$ a{12},a{13},a{14} $$就比较小。 c2应该和“爱”最相关，因此对应的$$ a{22} $$就比较大。最后的c3和h3、h4最相关，因此 $$ a{33},a_{34} $$的值就比较大。 至此，关于Attention模型，我们就只剩最后一个问题了，那就是： 这些权重$$ a_{ij} $$是怎么来的？ 事实上，$$ a_{ij} $$同样是从模型中学出的，它实际和Decoder的第i-1阶段的隐状态、Encoder第j个阶段的隐状态有关。 同样还是拿上面的机器翻译举例，$$ a_{1j} $$的计算（此时箭头就表示对h’和$$ h_j $$同时做变换）： $ a_{1j} $计算 $$ a_{2j} $$的计算: $ a_{2j} $计算 $$ a_{3j} $$的计算: $ a_{3j} $的计算","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://xichen.pub/categories/Deep-Learning/"}],"tags":[{"name":"rnn","slug":"rnn","permalink":"http://xichen.pub/tags/rnn/"}]},{"title":"Ubuntu的grub修复","slug":"2017-08-07-Ubuntu的grub修复","date":"2017-08-07T01:11:00.000Z","updated":"2018-01-05T00:45:28.274Z","comments":true,"path":"2017/08/07/2017-08-07-Ubuntu的grub修复/","link":"","permalink":"http://xichen.pub/2017/08/07/2017-08-07-Ubuntu的grub修复/","excerpt":"","text":"问题一：grub rescue调整磁盘，利用工具分割出新分区后重启 开机后有引导，可以正常进入win7系统，但选择Linux系统进入时跳到grub rescue模式 12345GRUB loadingerror:unknow filesystemgrub rescue&gt; 这是因为新分区导致grub混淆 在 grub rescue&gt;下输入以下命令： 123456grub rescue&gt;ls(hd0,1),...,(hd0,msdos9),(hd0,msdos10),(hd0,msdos11)grub rescue&gt;set root=(hd0,msdos11)grub rescue&gt;set prefix=(hd0,msdos11)/grubgrub rescue&gt;insmod normalgrub rescue&gt;normal 即可正常进入Ubuntu系统 但是问题依旧存在，下次要进入Ubuntu时还是先进入grub rescue，很烦 我们需要进入Linux中，对grub进行修复。 启动起来，进入ubuntu之后，在终端执行： 12sudo update-grubsudo grub-install /dev/sda （sda是你的硬盘号码，千万不要指定分区号码，例如sda1，sda5等都不对） 嗯，现在重启可以直接进入Ubuntu系统，不用进入grub rescue了 但是，有个问题…现在进不了win7了…win7的启动项弄没了，现在只能进ubuntu 问题二：win7的启动项消失注意到“Windows 7 (loader) (on /dev/sda1)”条目 开机时点进去…假的，直接紫色花屏，mmp 我觉得还可以再抢救一下 直接改一下grub.cfg文件 先Ctrl+alt+T打开终端，输入 1sudo gedit /boot/grub/grub.cfg 再打开的grub.cfg文件尾部添加一段： 12345menuentry 'Win7' &#123; set root=(hd0,1); ntldr /bootmgr boot&#125; 保存，退出。重启。也可以看到Win7启动条目了。 但这种做法不会像方法一那样更新了grub.cfg文件，删除掉了那条旧的“Windows 7 (loader) (on /dev/sda1)条目”。可以直接在grub.cfg文件中删除那一段则可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"grub","slug":"grub","permalink":"http://xichen.pub/tags/grub/"}]},{"title":"LSTM","slug":"2017-08-04-LSTM","date":"2017-08-04T04:32:24.000Z","updated":"2018-01-05T00:45:28.273Z","comments":true,"path":"2017/08/04/2017-08-04-LSTM/","link":"","permalink":"http://xichen.pub/2017/08/04/2017-08-04-LSTM/","excerpt":"","text":"原理Understanding LSTM Networks (译)理解 LSTM 网络 代码纯python实现 解读 如图为LSTM的类图 12345678910111213import randomimport numpy as npimport mathdef sigmoid(x): return 1. / (1 + np.exp(-x))def sigmoid_derivative(values): return values*(1-values)def tanh_derivative(values): return 1. - values ** 2 sigmoid(x) := $$ \\sigma(x)=\\frac{1}{1+e^x} $$ sigmoid_derivative(x) := $$ \\sigma ‘(x)=x(1-x) $$ tanh_derivative(x) := $$ \\tanh ‘(x)=1-x^2 $$ 1234# createst uniform random array w/ values in [a,b) and shape argsdef rand_arr(a, b, *args): np.random.seed(0) return np.random.rand(*args) * (b - a) + a np.random.seed(0)设置随机数种子以便复现结果,rand_arr(a,b,*args)函数用于初始化 rand_arr(a,b):= $$ x, x \\in [a,b) $$ rand_arr(a,b,$$\\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{bmatrix}$$):=$$\\begin{bmatrix} x_1 &amp; x_2 \\ x_3 &amp; x_4 \\end{bmatrix} ,x_1, x_2, x_3, x_4\\in [a,b) $$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class LstmParam: def __init__(self, mem_cell_ct, x_dim): self.mem_cell_ct = mem_cell_ct self.x_dim = x_dim concat_len = x_dim + mem_cell_ct # weight matrices self.wg = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wi = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wf = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) self.wo = rand_arr(-0.1, 0.1, mem_cell_ct, concat_len) # bias terms self.bg = rand_arr(-0.1, 0.1, mem_cell_ct) self.bi = rand_arr(-0.1, 0.1, mem_cell_ct) self.bf = rand_arr(-0.1, 0.1, mem_cell_ct) self.bo = rand_arr(-0.1, 0.1, mem_cell_ct) # diffs (derivative of loss function w.r.t. all parameters) self.wg_diff = np.zeros((mem_cell_ct, concat_len)) self.wi_diff = np.zeros((mem_cell_ct, concat_len)) self.wf_diff = np.zeros((mem_cell_ct, concat_len)) self.wo_diff = np.zeros((mem_cell_ct, concat_len)) self.bg_diff = np.zeros(mem_cell_ct) self.bi_diff = np.zeros(mem_cell_ct) self.bf_diff = np.zeros(mem_cell_ct) self.bo_diff = np.zeros(mem_cell_ct) def apply_diff(self, lr = 1): ''' lr:learningrate学习率 ''' self.wg -= lr * self.wg_diff self.wi -= lr * self.wi_diff self.wf -= lr * self.wf_diff self.wo -= lr * self.wo_diff self.bg -= lr * self.bg_diff self.bi -= lr * self.bi_diff self.bf -= lr * self.bf_diff self.bo -= lr * self.bo_diff # reset diffs to zero self.wg_diff = np.zeros_like(self.wg) self.wi_diff = np.zeros_like(self.wi) self.wf_diff = np.zeros_like(self.wf) self.wo_diff = np.zeros_like(self.wo) self.bg_diff = np.zeros_like(self.bg) self.bi_diff = np.zeros_like(self.bi) self.bf_diff = np.zeros_like(self.bf) self.bo_diff = np.zeros_like(self.bo) LSTM基本结构决定丢弃信息确定更新的信息更新细胞状态输出信息 以上公式的符号与变量名对应表 变量名 意义或公式符号 mem_cell_ct todo x_dim $$x_t$$的维数 wf $$W_f$$ wi $$W_i$$ wg $$W_C$$ wo $$W_o$$ bf $$b_f$$ bi $$b_i$$ bg $$b_C$$ bo $$b_o$$ wf_diff $$W_f$$的误差 wi_diff $$W_i$$的误差 wg_diff $$W_C$$的误差 wo_diff $$W_o$$的误差 bf_diff $$b_f$$的误差 bi_diff $$b_i$$的误差 bg_diff $$b_C$$的误差 bo_diff $$b_o$$的误差 12345678910class LstmState: def __init__(self, mem_cell_ct, x_dim): self.g = np.zeros(mem_cell_ct) self.i = np.zeros(mem_cell_ct) self.f = np.zeros(mem_cell_ct) self.o = np.zeros(mem_cell_ct) self.s = np.zeros(mem_cell_ct) self.h = np.zeros(mem_cell_ct) self.bottom_diff_h = np.zeros_like(self.h) self.bottom_diff_s = np.zeros_like(self.s) 变量名 意义或公式符号 f $$f_t$$ i $$i_t$$ g $$\\widetilde{C}_t$$ o $$o_t$$ s $$C_t$$ (state的缩写) h $$h_t$$ bottom_diff_h $$todo$$ bottom_diff_h $$todo$$ 1234567class LstmNode: def __init__(self, lstm_param, lstm_state): # store reference to parameters and to activations self.state = lstm_state self.param = lstm_param # non-recurrent input concatenated with recurrent input self.xc = None LSTM只有一个节点，该节点包含训练参数lstm_param和状态参数lstm_state 训练参数是模型的灵魂所在，网络学习的过程就是训练参数不断调整的过程，最好不要人为干预 状态参数可以根据不同的输入通过与训练参数计算而来 123456789101112131415161718def bottom_data_is(self, x, s_prev = None, h_prev = None): # if this is the first lstm node in the network if s_prev == None: s_prev = np.zeros_like(self.state.s) if h_prev == None: h_prev = np.zeros_like(self.state.h) # save data for use in backprop self.s_prev = s_prev self.h_prev = h_prev # concatenate x(t) and h(t-1) xc = np.hstack((x, h_prev)) self.state.g = np.tanh(np.dot(self.param.wg, xc) + self.param.bg) self.state.i = sigmoid(np.dot(self.param.wi, xc) + self.param.bi) self.state.f = sigmoid(np.dot(self.param.wf, xc) + self.param.bf) self.state.o = sigmoid(np.dot(self.param.wo, xc) + self.param.bo) self.state.s = self.state.g * self.state.i + s_prev * self.state.f self.state.h = self.state.s * self.state.o self.xc = xc 变量名 意义或公式符号 s_pre $$C_{t-1}$$ h_pre $$h_{t-1}$$ bottom_data_is(x,s_prev,h_prev) 相当于前向传播 12345678910111213141516171819202122232425262728293031323334def top_diff_is(self, top_diff_h, top_diff_s): # notice that top_diff_s is carried along the constant error carousel ds = self.state.o * top_diff_h + top_diff_s do = self.state.s * top_diff_h di = self.state.g * ds dg = self.state.i * ds df = self.s_prev * ds # diffs w.r.t. vector inside sigma / tanh function di_input = sigmoid_derivative(self.state.i) * di df_input = sigmoid_derivative(self.state.f) * df do_input = sigmoid_derivative(self.state.o) * do dg_input = tanh_derivative(self.state.g) * dg # diffs w.r.t. inputs self.param.wi_diff += np.outer(di_input, self.xc) self.param.wf_diff += np.outer(df_input, self.xc) self.param.wo_diff += np.outer(do_input, self.xc) self.param.wg_diff += np.outer(dg_input, self.xc) self.param.bi_diff += di_input self.param.bf_diff += df_input self.param.bo_diff += do_input self.param.bg_diff += dg_input # compute bottom diff dxc = np.zeros_like(self.xc) dxc += np.dot(self.param.wi.T, di_input) dxc += np.dot(self.param.wf.T, df_input) dxc += np.dot(self.param.wo.T, do_input) dxc += np.dot(self.param.wg.T, dg_input) # save bottom diffs self.state.bottom_diff_s = ds * self.state.f self.state.bottom_diff_h = dxc[self.param.x_dim:] 计算误差,相当于后向传播 123456class LstmNetwork(): def __init__(self, lstm_param): self.lstm_param = lstm_param self.lstm_node_list = [] # input sequence self.x_list = [] 一般的RNN网络结构 定义初始化网络 本实现中,Hidden Layer 和 Input Layer 和 Output Layer的长度都相同 变量名 意义或公式符号 lstm_node_list Hidden Layer x_list Input Layer 12345678910111213141516171819202122232425262728def y_list_is(self, y_list, loss_layer): \"\"\" Updates diffs by setting target sequence with corresponding loss layer. Will *NOT* update parameters. To update parameters, call self.lstm_param.apply_diff() \"\"\" assert len(y_list) == len(self.x_list) idx = len(self.x_list) - 1 # first node only gets diffs from label ... loss = loss_layer.loss(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h = loss_layer.bottom_diff(self.lstm_node_list[idx].state.h, y_list[idx]) # here s is not affecting loss due to h(t+1), hence we set equal to zero diff_s = np.zeros(self.lstm_param.mem_cell_ct) self.lstm_node_list[idx].top_diff_is(diff_h, diff_s) idx -= 1 ### ... following nodes also get diffs from next nodes, hence we add diffs to diff_h ### we also propagate error along constant error carousel using diff_s while idx &gt;= 0: loss += loss_layer.loss(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h = loss_layer.bottom_diff(self.lstm_node_list[idx].state.h, y_list[idx]) diff_h += self.lstm_node_list[idx + 1].state.bottom_diff_h diff_s = self.lstm_node_list[idx + 1].state.bottom_diff_s self.lstm_node_list[idx].top_diff_is(diff_h, diff_s) idx -= 1 return loss 根据y_list计算误差 y_list存的是target sequence 用index从最新的一个状态t=index到之前所有的状态进行遍历，累计误差 误差暂时储存在self.lstm_node_list[idx + 1].state.bottom_diff_h和self.lstm_node_list[idx + 1].state.bottom_diff_s 12345678910111213141516171819def x_list_clear(self): self.x_list = []def x_list_add(self, x): self.x_list.append(x) if len(self.x_list) &gt; len(self.lstm_node_list): # need to add new lstm node, create new state mem lstm_state = LstmState(self.lstm_param.mem_cell_ct, self.lstm_param.x_dim) self.lstm_node_list.append(LstmNode(self.lstm_param, lstm_state)) # get index of most recent x input idx = len(self.x_list) - 1 if idx == 0: # no recurrent inputs yet self.lstm_node_list[idx].bottom_data_is(x) else: s_prev = self.lstm_node_list[idx - 1].state.s h_prev = self.lstm_node_list[idx - 1].state.h self.lstm_node_list[idx].bottom_data_is(x, s_prev, h_prev) (一个时间步一个时间步地)将(代表一个句子的一个单词的)向量加入x_list中, 最终x_list是一个矩阵 例如(假设每个单词向量是n维,这里n=4): I——–&gt;[[1,2,3,4], want—&gt; [5,7,8,9], to——&gt; [1,5,8,7], watch–&gt; [5,2,3,1], movies– [4,8,2,6]]","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://xichen.pub/categories/Deep-Learning/"}],"tags":[{"name":"rnn","slug":"rnn","permalink":"http://xichen.pub/tags/rnn/"}]},{"title":"vim tips","slug":"2017-07-01-vim-tips","date":"2017-06-30T21:21:00.000Z","updated":"2018-01-05T00:45:28.271Z","comments":true,"path":"2017/07/01/2017-07-01-vim-tips/","link":"","permalink":"http://xichen.pub/2017/07/01/2017-07-01-vim-tips/","excerpt":"","text":"1. vim基本设置12345678set nuset listset listchars=tab:»\\ ,extends:›,precedes:‹,nbsp:·,trail:·filetype plugin onfiletype plugin indent onsyntax enablesyntax oncolorscheme molokai 在windows下的gvim中，可能会出现使用backspace不能往左删除的问题 这个是因为在windows下的gvim是默认启用了vi兼容模式的，这种模式下backspace配置是空的，所以我们需要禁用vi兼容模式： set nocp backspace键的默认模式有三种： 1230 same as “:set backspace=” (Vi compatible)1 same as “:set backspace=indent,eol”2 same as “:set backspace=indent,eol,start” indent,eol,start解释如下： 123indent: 如果用了:set indent,:set ai 等自动缩进，想用退格键将字段缩进的删掉，必须设置这个选项。否则不响应。eol:如果插入模式下在行开头，想通过退格键合并两行，需要设置eol。start：要想删除此次插入前的输入，需设置这个 所以禁用vi兼容模式之后，我们可以设置backspace键为set backspace=2，然后不能使用backspace往左删除的问题消失。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"使用vim编写fortran代码的一些相关设置","slug":"2017-07-01-使用vim编写fortran代码","date":"2017-06-30T07:58:00.000Z","updated":"2018-01-05T00:45:28.272Z","comments":true,"path":"2017/06/30/2017-07-01-使用vim编写fortran代码/","link":"","permalink":"http://xichen.pub/2017/06/30/2017-07-01-使用vim编写fortran代码/","excerpt":"","text":"最近开始干活了，实验室主流语言是fortran，一种很褒贬不一的语言。由于是Arch linux用户，所以需要对linux编写编译fortran代码做一些准备工作。 1.首先，在linux下fortran编译器还是很多的，有很方便就能安装的gfortran，还有诸如intel或者PGI这些公司提供的编译器。intel家的编译器对学生免费，所以自然就成了首选。详情请去这个链接查看。 2.安装intel parallel studio的过程是图形化的，一般不会出现什么问题。安装之后设置一下路径就能使用ifort命令编译fortran文件了。 3.在linux编写fortran代码我还是按照习惯选择了vim，然后我们需要在.vimrc中加入如下设置项： 1234567891011121314\"语法高亮syntax enablesyntax on\"fortran语言制表符设置let fortran_have_tabs=1\"设置制表符宽度set tabstop=4\"解决中文注释乱码set fileencodings=urf-8,gb18030,utf-16,big5\"设置代码折叠let fortran_fold=1set foldmethod=syntax\"设置默认文件打开后所有折叠自动展开set foldlevelstart=99 vim有关代码折叠的命令如下： 1234zc：折叠代码zo：展开代码zC：折叠所有代码zO：展开所有代码 最后效果图： 这里vim的配色主题为molokai。","categories":[],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Ubuntu 16.04安装jekyll","slug":"2017-06-26-Ubuntu安装jekyll","date":"2017-06-26T03:13:00.000Z","updated":"2018-01-05T00:45:28.271Z","comments":true,"path":"2017/06/26/2017-06-26-Ubuntu安装jekyll/","link":"","permalink":"http://xichen.pub/2017/06/26/2017-06-26-Ubuntu安装jekyll/","excerpt":"","text":"一直以来在github写博客习惯于直接git提交后在github pages看效果，这样来回修改就会繁琐的commit、push,所以还是搭建jekyll本地环境预览吧。 1.安装ruby 1sudo apt install ruby-full ruby-bundler 这里如果下意识的使用sudo apt install ruby安装ruby会导致下一步安装jekyll的时候出现如下错误： 2.安装jekyll 1sudo gem install jekyll 3.检测jekyll是否安装成功 1234jekyll -vjekyll new new-sitecd new-sitejekyll serve 在浏览器里打开http://localhost:4000可以看到预览效果。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://xichen.pub/tags/Ubuntu/"},{"name":"jekyll","slug":"jekyll","permalink":"http://xichen.pub/tags/jekyll/"}]},{"title":"latex tips","slug":"2017-06-26-Latex-tips","date":"2017-06-26T02:52:00.000Z","updated":"2018-01-05T00:45:28.270Z","comments":true,"path":"2017/06/26/2017-06-26-Latex-tips/","link":"","permalink":"http://xichen.pub/2017/06/26/2017-06-26-Latex-tips/","excerpt":"","text":"1.\\min的两种表示方法12\\min\\limits_&#123;a&#125;\\min\\nolimits&#123;a&#125; 对应的显示效果如下： 2. latex插入python代码 在latex里插入python代码需要使用包pythonhighlight,如果你使用tex live 2017的话，这个包已经安装了，可以直接使用； 如果你安装的latex版本默认没有这个包，你可以去这个地址下载pythonhighlight.sty文件，然后放到自己的.tex文件目录下，就可以使用了。 使用过程如下： 先在latex导言区输入： 12\\usepackage&#123;graphicx&#125;\\usepackage&#123;pythonhighlight&#125; 插入python代码有两种方式： 然后在需要插入代码的地方： 12345\\inputpython&#123;python_filename.py&#125;&#123;begin line number&#125;&#123;end line number&#125;%或者使用这种方式\\begin&#123;python&#125;contents\\end&#123;python&#125;","categories":[],"tags":[{"name":"Latex Tips","slug":"Latex-Tips","permalink":"http://xichen.pub/tags/Latex-Tips/"}]},{"title":"Ubuntu tips","slug":"2017-06-25-ubuntu-tips","date":"2017-06-25T08:50:00.000Z","updated":"2018-01-05T00:45:28.269Z","comments":true,"path":"2017/06/25/2017-06-25-ubuntu-tips/","link":"","permalink":"http://xichen.pub/2017/06/25/2017-06-25-ubuntu-tips/","excerpt":"","text":"1. 更换pip源为阿里云的镜像源官方帮助教程 编辑pip配置文件: vim ~/.pip/pip.conf 然后写入如下内容： 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = mirrors.aliyun.com 如果发现没有对应文件夹以及配置文件，请直接自行创建。 2. Ubuntu将默认的python版本换为python3.XUbuntu 16.04自带了python2.7和python3.5，且默认版本为python2.7，最近一直使用python3.×版本所以需讲python默认版本修改为3.5。 可以使用ls /usr/bin | grep python来查看目前存在的python版本 然后设置软链接，讲python3.5设为默认： sudo ln -s /usr/bin/python3.5 /usr/local/bin/python 此时python3.5已经成为默认。 然后此时需要注意的就是，如果以后主要在3.×的环境下工作，请安装对应3.×的包。 12sudo apt install python3-pippip3 install package_name 3. Ubuntu设置ssh密钥登录并关闭ssh密码登录连网的机器安全第一，所以ssh的安全性就是重中之重了。使用ssh密钥登录，并关闭密码认证是有效的防止机器被入侵的方式。 Ubuntu设置ssh密钥登录的步骤如下： 1.首先安装ssh sudo apt install ssh 2.制作密钥对 ssh-keygen 你应该会看到如下的内容： 1234Generating public/private rsa key pair.Enter file in which to save the key(/home/user/.ssh/id_rsa):...... 3.将公钥写入到对应文件里 12cd ~/.sshcat id_rsa.pug &gt;&gt; authorized_keys 然后确保对应文件的权限是正确的: 12chmod 600 authorized_keyschmod 700 ~/.ssh 4.设置ssh配置文件，打开密钥登录并关闭密码登录 编辑/etc/ssh/sshd_config文件，确定如下设置： 12RSAAuthentication yesPubkeyAuthentication yes 当你确定可以使用密钥方式登录成功之后，再禁用密码登录： PasswordAuthentication no 记得如果这些修改项是被注释掉的，记得把注释取消。 5.重启ssh服务 service sshd restart 6.关于putty使用id_rsa的一点儿说明 putty是不能直接使用id_rsa私钥的，需要使用puttygen转换。 首先从服务器下载id_rsa到本地，然后使用puttygen载入，然后选择Save private key讲私钥保存为putty能用的.ppk文件。然后就跟一般的putty使用key登录一样了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"},{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Ubuntu常用软件","slug":"2017-06-24-ubuntu常用软件","date":"2017-06-22T23:16:27.000Z","updated":"2018-01-05T00:45:28.268Z","comments":true,"path":"2017/06/23/2017-06-24-ubuntu常用软件/","link":"","permalink":"http://xichen.pub/2017/06/23/2017-06-24-ubuntu常用软件/","excerpt":"","text":"习惯了Arch的yaourt之后再使用ubuntu ppa就有一种就怕货比货的感觉。 收集一下常用的ubuntu软件安装，便于下次无脑重装。 1.Albert 这款软件是必装的了，一个很好用的Launcher。官方介绍如下： Access everything with virtually zero effort. Run applications, open files or their paths,open bookmarks in your browser, search the web, calculate things and a lot more … Ubuntu-PPA(hotice/webupd8) 123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install albert 2.chrome 1.将下载源添加到系统源： sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ 2.导入google软件公钥： wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - 3.更新源然后安装： 12sudo apt updatesudo apt install google-chrome-stable","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"Ubuntu以及Arch Linux更换清华源","slug":"2017-06-23-ubuntu换源以及Arch-linux更换清华源","date":"2017-06-22T23:16:27.000Z","updated":"2018-01-05T00:45:28.268Z","comments":true,"path":"2017/06/23/2017-06-23-ubuntu换源以及Arch-linux更换清华源/","link":"","permalink":"http://xichen.pub/2017/06/23/2017-06-23-ubuntu换源以及Arch-linux更换清华源/","excerpt":"","text":"UbuntuUbuntu清华源更换网址 这个地址里同样有其他Linux发行版的源使用帮助信息。 更换步骤 1.在上述网址选择ubuntu版本，生成对应的源地址； 2.备份原始文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 3.编辑源文件 sudo vim /etc/apt/sources.list 将sources.list中内容注释或者删除掉，然后将第一步中生成的源地址粘贴进去； 4.然后更新软件包缓存sudo apt update Arch Linux编辑­/etc/pacman.d/mirrorlist,在文件最顶端添加： Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后更新软件包缓存sudo pacman -Syy","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"Tips about git and jupyter","slug":"2017-05-25-Tips","date":"2017-05-24T07:41:00.000Z","updated":"2018-01-05T00:45:28.267Z","comments":true,"path":"2017/05/24/2017-05-25-Tips/","link":"","permalink":"http://xichen.pub/2017/05/24/2017-05-25-Tips/","excerpt":"","text":"git push 免密码1.使用文件创建用户名和密码 文件创建在用户主目录下： 123touch .git-credentialsvim .git-credentialshttps://&#123;username&#125;:&#123;password&#125;@github.com 记得在真正输入的时候是没有大括号的。 2.添加git config内容 git config --global credential.helper store 执行此命令后，用户主目录下的.gitconfig文件会多了一项： [credential] helper = store 重新git push就不需要用户名密码了。 git add 使用tab键自动补全的中文文件名乱码文件名乱码如下所示： 解决方法为： git config --global core.quotepath false 效果如下： 可以看出中文已经正确显示了。 jupyter notebook 创建密码产生jupyter notebook的配置文件： 1jupyter notebook --generate-config 生成的配置文件位置为：~/.jupyter/jupyter_notebook_config.py 打开jupyter，新建一个notebook，创建密码以及生成密码的sha1密钥，所需代码如下： 12from notebook.auth import passwdpasswd() 输入一遍你想设置的密码，然后再输入一遍确认，记录下生成的sha1密钥值。形式如：‘sha1:xxxxxxx’ 然后将这段值按如下格式粘贴到配置文件中对应的c.NotebookApp.password = u&#39;sha1:xxxx&#39;位置上，如果你不想寻找文件中的这个位置，你也可以在文件末尾新建一个。 重启jupyter，密码生效。","categories":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"}]},{"title":"Arch linux安装过程整理","slug":"2017-05-24-Arch-Linux安装过程整理","date":"2017-05-24T03:32:00.000Z","updated":"2018-01-05T00:45:28.266Z","comments":true,"path":"2017/05/24/2017-05-24-Arch-Linux安装过程整理/","link":"","permalink":"http://xichen.pub/2017/05/24/2017-05-24-Arch-Linux安装过程整理/","excerpt":"","text":"整理一下这个教程便于以后可以无脑重装Arch Linux，美滋滋啊。 准备以及分区1.准备 准备内容 USB stick Arch Linux ISO image Arch Linux Download Addr 创建启动盘 On windows: Rufus On linux: dd if12345678910111213141516&gt; sdx代表你的U盘，可以用lsblk命令查看得到。接下来就是设置bios启动方式，教程基于UEFI+GPT的引导启动方式。请自行设置。**设置USB为下一次的引导路径，然后重启之后我们就能进入Arch安装环境了**查看EFI mode是否开启`efivar -l`如果有输出，就说明已经开启。**2.分区**`lsblk` gdisk /dev/sdx (x representing your drive)x # into expert modez # clear the disky # confirmy # confirm1234567891011121314151617创建分区**分区设定如下：**sda- sda1(boot partition)- sda2(our swap partition)- sda3(our root partition)- sda4(our home partition)**使用cgdisk分区：**`cgdisk /dev/sdx` [New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 1024MiB -&gt;press EnterHex Code: EF00 press EnterEnter new partition name: boot -&gt;press Enter123**boot分区**的Hex Code为**EF00**，千万不要弄错，有些资料会说是EF02，实测EF00才有效。arch wiki上说boot分区分配200-300mb就行了，但是为了以后的双系统等未知需求，分配1Gb。 [New] Press EnterFirst Sector: Leave this blank -&gt;press EnterSize in sectors: 8GiB -&gt;press EnterHex Code: 8200 -&gt;press EnterEnter new partition name: swap -&gt;press Enter12345678910111213141516171819**swap分区**的Hex Code是**8200**。swap分区的开启与否以及大小设置一直是争论焦点。这里贴出参考：[askubuntu\\_swap](https://askubuntu.com/questions/49109/i-have-16gb-ram-do-i-need-32gb-swap/49130#49130)[serverfault\\_swap](https://serverfault.com/questions/5841/how-much-swap-space-on-a-2-4gb-system)下面建立root分区和home分区。两者Hex code都是默认的**8300**。如果不独立设置home分区，就可以直接把剩余空间都设置为root分区。如果设置独立的home分区，可以分配30G左右给root分区，剩余空间分配给home分区。分区全部建立完毕之后，我们就要设置分区格式了。```shellmkfs.fat -F32 /dev/sda1mkswap /dev/sda2swapon /dev/sda2mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4 3.安装Arch 以及配置启动挂载分区 12345mount /dev/sda3 /mntmkdir /mnt/bootmkdir /mnt/homemount /dev/sda1 /mnt/bootmount /dev/sda4 /mnt/home 设置mirrorlist 学校有ipv6的学生可以用清华的源，ipv6直连，美滋滋。 nano /etc/pacman.d/mirrorlist 然后在最前面加上 12# TsinghuaServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后安装系统 1pacstrap -i /mnt base base-devel 然后创建fstab文件到新安装系统： 1genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab 可以通过nano /mnt/etc/fstab查看是否创建成功 接下来就可以切换到我们新安装的系统了 arch-chroot /mnt 接下来设置语言，linux下界面语言还是用英文吧。 nano /etc/locale.gen 然后取消掉en_US.UTF-8和zh_CN.UTF-8前面的注释。 使其生效： locale-gen 接下来设置语言： 12echo LANG=en_US.UTF-8 &gt; /etc/locale.confexport LANG=en_US.UTF-8 设置时区： ln -s /usr/share/zoneinfo/Asia/Shanghai &gt; /etc/localtime 请自觉使用tab补全以免出错。 设置硬件时钟： hwclock --systohc --utc 设置主机名： echo hostname &gt; /etc/hostname 然后编辑pacman.conf取消multilib前面的注释： 这个是为了在64位机器上运行32位程序 12[multilib]Include = /etc/pacman.d/mirrorlist 然后强烈推荐添加的yaourt 123[archlinuxfr]SigLevel = NeverServer = http://repo.archlinux.fr/$arch 一定要注意大小写。 必须添加的archlinuxcn源，里面有很多中国特色软件，比如网易云、有道词典之类的，同样推荐清华源。 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 然后安装archlinuxcn-keyring包以导入GPG key。 这个时候就可以保存pacman.conf文件了。 设置root账户的密码： passwd 添加日常用户： useradd -m -g users -G wheel,storage,power -s /bin/bash yourusername 设置密码： passwd yourusername 然后是设置sudoers： EDITOR=nano visudo 然后取消注释： %wheel ALL=(ALL) ALL 然后让使用sudo命令的用户必须输入root密码： Defaults rootpw 然后就可以保存文件了。 安装补全命令： pacman -S bash-completion 安装引导 确保EFI变量被挂载 mount -t efivarfs efivarfs /sys/firmware/efi/efivars 使用Gummiboot作为我们的启动管理，这个已经整合到了bootctl/system-boot里，所以安装方式为： bootctl install 下面，我需要把/root分区的PARTUUID加入到启动设置里： blkid -s PARTUUID -o value /dev/sdxY x代表设备代号，本次为a，Y是/root partition的排号，本次为3. 然后添加gummiboot manager配置文件： 123456nano /boot/loader/entries/arch.conf# 下面是内容：title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=PARTUUID=上个命令得到的 rw 保存并退出 添加intel支持： pacman -S intel-ucode 然后写入到启动管理设置里： 123nano /boot/loader/entries/arch.confinitrd /intel-ucode.imginitrd /initramfs-linux.img 这个时候基本的操作已经完成了，我们可以重启试试了。 123exitumount -R /mntreboot 5.安装xfce4桌面环境1234567sudo pacman -S mesasudo pacman -S xorg-server xorg-server-common xorg-xinitsudo pacman -S xfce4sudo pacman -S xfce4-goodiessudo pacman -S sddmsudo systemctl enable sddm.servicereboot 安装完成，可以使用了。美滋滋。 6.安装Tex Live123yaourt -S texlive-mostyaourt -S texlive-langchineseyaourt -S texstudio 安装完成之后使用tex --version测试： 12345678910-&lt;%&gt;- tex --versionTeX 3.14159265 (TeX Live 2016/Arch Linux)kpathsea version 6.2.2Copyright 2016 D.E. Knuth.There is NO warranty. Redistribution of this software iscovered by the terms of both the TeX copyright andthe Lesser GNU General Public License.For more information about these matters, see the filenamed COPYING and the TeX source.Primary author of TeX: D.E. Knuth. 使用texstudio编写测试文件： 新建test.tex,内容如下： 123456789101112131415\\documentclass&#123;article&#125;\\usepackage&#123;graphicx&#125;\\begin&#123;document&#125;\\begin&#123;figure&#125; \\includegraphics[width=\\linewidth]&#123;favicon.jpg&#125; \\caption&#123;A boat.&#125; \\label&#123;fig:boat1&#125;\\end&#123;figure&#125;Figure \\ref&#123;fig:boat1&#125; shows a boat.\\end&#123;document&#125; Build &amp; View查看运行结果，正常结果如下：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"正则表达式入门笔记","slug":"2017-05-20-正则表达式入门","date":"2017-05-19T22:43:00.000Z","updated":"2018-01-05T00:45:28.265Z","comments":true,"path":"2017/05/20/2017-05-20-正则表达式入门/","link":"","permalink":"http://xichen.pub/2017/05/20/2017-05-20-正则表达式入门/","excerpt":"","text":"这是主要参考文献：正则表达式入门，本文只是做了修改以便于自己记忆。 1. 元字符 metacharater \\b 代表着单词的开头或者结尾，也就是单词的分界处； . 匹配除了换行符以外的任意字符； \\d 匹配一位数字； \\s 匹配任意的空白符，包括空格，制表符，换行符，中文全角空格等； \\w 匹配字母或数字或下划线或者汉字等； ^ 匹配字符串的开始； $ 匹配字符串的结束； 字符转义仍然是使用\\ 2. 限定 + 指定前面的内容可以连续重复1次或者更多次； * 指定前面的内容可以连续重复任意次（包括0次)； ? 重复零次或者一次； {n} 重复n次； {n,1} 重复n次或者更多次； {n,m} 重复n次到m次； 3. 字符类可以利用方括号来匹配所需字符，[acb]代表可以匹配abc其中的一个，所以[]只用来匹配没有元字符对应的字符集中的单个字符 比如[0-9],就跟\\d是完全一致的，也就是匹配单个数字 4.分支条件 正则表达式分支条件示例：\\d{5}-\\d{4}|\\d{5} 这个例子含有一个小的tricky的地方，就是它说明了一个问题：用分支条件时，要注意各个条件的顺序。如果把这个表达式改为\\d{5}|\\d{5}-\\d{4}，那么就只会匹配五位的邮编以及9位邮编的前5位。 原因是匹配分支条件时，将会从左到右地测试每个条件，如果满足了某个分支的话，就不会再管其它条件。 5. 分组上面所说的都是重复单个字符的方法，如果想要重复多个字符可以用小括号来指定子表达式（也叫作分组），这也是当我们需要（字符本身时需要对其进行转义的原因。 (\\d{1,3}.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。 6.反义 代码语法 说明 \\W 匹配任意不是字母、数字、下划线、汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 7.后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容）可以在表达式或者其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左到右，以分组的左括号为标志，第一个出现的分组组号为1，第二个为2，以此类推。 分组0对应整个正则表达式； 实际上组号分配过程是要从左到右扫描两遍：第一遍只给未命名组分配，第二遍只给命名组分配–因此所有的命名组的组号都大于未命名组的组号； 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权。 \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 常用分组语法： 待补充 8. 零宽断言","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]},{"title":"python Tips","slug":"2017-9-18-python-require-install","date":"2017-05-19T22:43:00.000Z","updated":"2018-01-05T00:45:28.298Z","comments":true,"path":"2017/05/20/2017-9-18-python-require-install/","link":"","permalink":"http://xichen.pub/2017/05/20/2017-9-18-python-require-install/","excerpt":"","text":"自动生成和安装requirements.txt依赖requirements.txt可以通过pip命令自动生成和安装 生成requirements.txt文件 1pip freeze &gt; requirements.txt 安装requirements.txt依赖 1pip install -r requirements.txt","categories":[{"name":"python","slug":"python","permalink":"http://xichen.pub/categories/python/"},{"name":"Tips","slug":"python/Tips","permalink":"http://xichen.pub/categories/python/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"http://xichen.pub/tags/Tips/"},{"name":"python","slug":"python","permalink":"http://xichen.pub/tags/python/"}]},{"title":"使用Arch Linux时出现的问题","slug":"2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux","date":"2017-05-18T22:32:24.000Z","updated":"2018-01-05T00:45:28.264Z","comments":true,"path":"2017/05/19/2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux/","link":"","permalink":"http://xichen.pub/2017/05/19/2017-05-17-Problems-I-encountered-when-I-use-Arch-Linux/","excerpt":"","text":"使用了Arch快半年了，这个文章实在是写晚了。。 1. oh my zsh 安装使用首先安装Zsh 1sudo pacman -S zsh 安装oh my zsh 1sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 切换shell从bash到zsh 首先查看可用shell列表： 1234567➜ ~ cat /etc/shells# /etc/shells/bin/sh/bin/bash# End of file/bin/zsh/usr/bin/zsh 切换到zsh 1chsh -s /usr/bin/zsh 2. error: failed to commit transaction (conflicting files)问题描述：这个问题已经碰到了几次，原因暂未知。 1234error: failed to commit transaction (conflicting files)python-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/PKG-INFO exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/SOURCES.txt exists in filesystempython-markupsafe: /usr/lib/python3.6/site-packages/MarkupSafe-1.0-py3.6.egg-info/dependency_links.txt exists in filesystem 解决方法：首先，检测一下冲突文件有没有包在使用1pacman -Qo /path/to/file 结果一般就是没有包在使用。。所以下面就rm掉所有引起冲突的文件就行了，问题解决。最近碰见了这个问题好几次，但是出现原因暂未知。。太烦了。 3. 窗口撕裂问题描述：我不知道这个问题应不应该叫做窗口撕裂：在上下滚动内容的时候，滚动方向最下面的内容会出现重影，显得好像屏幕刷新有延迟。 解决方法： 1sudo vim /etc/X11/xorg.conf.d/20-intel.conf 然后添加如下内容： 123456Section \"Device\" Identifier \"Intel Graphics\" Driver \"intel\" Option \"TearFree\" \"true\" Option \"AccelMethod\" \"uxa\"EndSection 默认的AccelMethod的值为sna，在我这里使用sna会出现滚动延迟的情况，但是使用uxa就没有这种现象。但是更改了这个值之后发现了一个新问题就是笔记本不合盖子屏幕自动关闭之后不能唤醒，只有切到tty之后再切回来才行。待解决。 4. signature from xxx is marginal trust问题描述： error: archlinuxcn-keyring: signature from “Jiachen Yang \\“ is marginal trust:: File /var/cache/pacman/pkg/archlinuxcn-keyring-20170522-1-any.pkg.tar.xz is corrupted (invalid or corrupted package (PGP signature)). 解决办法： sudo pacman-key --refresh-keys 代码运行结果就是新导入了很多PGP signature, 然后问题解决。 解决方法二 1234sudo rm -R /etc/pacman.d/gnupg/pacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcn 可以看出这也是走的更新key的路数。 但是出现这种问题执行pacman -S archlinux-keyring重装archlinux-keyring是没有用的。 还有一种说法是系统时间不正确 不知道这个系统时间是指哪个时间。 5. /opt sysmlink file conflicts问题描述：由于在安装Arch系统时，/home分区是独立于/root分区的，而yaourt安装的大型软件都是会安装到/opt下面，导致系统分区会被很快用光。所以我的解决方法是在/home分区下新建opt分区，然后建立软链接： ln -s /home/opt /opt 但是这样做之后会导致在yaourt安装软件是出现/opt already exists的file conflicts错误。 官方解释如下： Directory Symlink Handling: Example time! Arch Linux has a /lib -&gt; /usr/lib symlink. Previously, if pacman was installing a package and it found files in /lib, it would follow the symlink and install it in /usr/lib. However the filelist for that package still recorded the file in /lib. This caused heaps of difficulty in conflict resolving – primarily the need to resolve every path of all package files to look for conflicts. That was a stupid idea! So now if pacman sees a /lib directory in a package, it will detect a conflict with the symlink on the filesystem. If you were using this feature to install files elsewhere, you probably need to look into what a bind mount is! Note that this change requires us to correct the local package file list for any package installed using this mis-feature, so we bumped the database version. Upgrade using pacman-db-upgrade. Thanks to Andrew! 解决方法： 在/etc/fstab里加入如下内容： 12# solve the /opt sysbolink file conficts errors/home/opt /opt none bind problems solved, splendid! ### 6. wine下TIM中文界面部分乱码 问题描述： 已经通过winetricks corefonts cjkfonts安装了字体，但是qq登录界面以及消息预览界面的中文都是方块。 解决方法： 123456789101112131415161718vim .wine/system.reg搜索： LogPixels找到的行应该是：[System\\\\CurrentControlSet\\\\Hardware Profiles\\\\Current\\\\Software\\\\Fonts]将其中的：“LogPixels”=dword:00000060改为：“LogPixels”=dword:00000070搜索： FontSubstitutes找到的行应该是：[Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\FontSubstitutes]将其中的：“MS Shell Dlg”=”Tahoma”“MS Shell Dlg 2″=”Tahoma”改为：“MS Shell Dlg”=”SimSun”“MS Shell Dlg 2″=”SimSun” SimSun代表windows下的simsun.ttc字体，这里提供下载：下载simsun.ttc 7. xfce4下开机时某些非自启应用会自动运行问题描述：已经关闭了auto save sessions，但是在登录之后某些应用仍然会自动启动，具体表现为某次关机前系统的工作状态。 解决方法： 1rm -r .cache/sessions/* All clear!!!","categories":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://xichen.pub/tags/Linux/"}]}]}